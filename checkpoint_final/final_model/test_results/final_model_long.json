[
  {
    "id": 0,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , \"Missing descriptor data\\\\n\" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , \"Zero length descriptor\\\\n\" ) ; return NULL ; } <vul-start> while ( buflen > 0 ) { <vul-end> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , \"Found union header\\\\n\" ) ; <vul-start> return union_desc ; <vul-end> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , \"Missing CDC union descriptor\\\\n\" ) ; return NULL ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , \"Too large descriptor\\\\n\" ) ; return NULL ; } <vul-end> if ( union_desc <vul-start> \"Found union header\\\\n\" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , \"Union descriptor to short (%d vs %zd\\\\n)\" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <vul-end> ; } buflen\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if (! intf -> desc_desc ) { dev_err ( & intf -> dev, \"Missing descriptor\\\\n\" ) ; return NULL ; } <vul-start> \"Found union header\\\\n\" ) ; if (! intf -> desc_desc ) { dev_err ( & intf -> dev, \"Invalid descriptor buffer\\\\n\" ) ; return NULL ; }\n"
  },
  {
    "id": 1,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <vul-end> ; break ; <vul-start> n ) && ( <vul-start> ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <vul-start> += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , \"bare * has associated type comment\" ) ; return NULL ; } <vul-start> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <vul-end> if ( i <vul-start> ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <vul-end> ; break ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> arg ) ; if ( i + 2 >= NCH ( n ) ) { ast_error ( c, CHILD ( n, i ), \"too many arguments\" ) ; return NULL ; } <vul-start> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == COMMA ) { int res = 0 ; res = handle_keywordonly_args ( c, n, i, kwonlyargs, kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c, ch ) ; if (! vararg ) return NULL ; assert ( kwonlyargs!= NULL ) ; assert ( kwdefaults!= NULL ) ; asdl_seq_SET ( posdefaults, k ++, kwdefaults ) ; i += 3 ; } arg = ast_for_arg ( c, ch ) ; if (! arg ) return NULL ; asdl_seq_SET ( posargs, k ++, arg ) ; i += <vul-start> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) == COMMA ) { int res = 0 ; res = handle_keywordonly_args ( c, n, i, kwonlyargs, kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { int res = 0 ; res = handle_keywordonly_args ( c, n, i, kwonlyargs, kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } else { arg = ast_for_arg ( c, ch ) ; if (! kwarg ) return NULL ; asdl_seq_SET ( posargs, k ++, arg ) ; i += 3 ; break ; case STAR : if ( i + 1 == NCH ( n ) && TYPE ( CHILD ( n, i ) ) == COMMA ) { int res = 0 ; res = handle_keywordonly_args ( c, n, i, kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { arg = ast_for_arg ( c, ch ) ; if (! kwarg ) return NULL ; i += 3 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n, i ) ) =="
  },
  {
    "id": 2,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) <vul-start> return ( 0 ) ; <vul-end> tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <vul-start> 0 ) ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; return ( 0 ) ; } <vul-end> tif -> tif_rawcc\n"
  },
  {
    "id": 3,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ; <vul-start> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <vul-end> <vul-start> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <vul-end> result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> u64 redir_content ; if <vul-end> ( redir_index < <vul-start> < IOAPIC_NUM_PINS ) <vul-end> redir_content = ioapic <vul-start> ] . bits ; else redir_content = ~ 0ULL\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> u64 redir_content ; if ( <vul-end> redir_index < IOAPIC_NUM_PINS <vul-start> IOAPIC_NUM_PINS ) { result = ( <vul-end> ioapic -> redirtbl <vul-start> ]. bits ) & 0xffffffff ; break ; } redir_content = ioapic -> redirtbl [ redir_index ]. bits\n"
  },
  {
    "id": 4,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length parameter must be greater than 0\" ) ; RETURN_FALSE ; } <vul-start> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <vul-end> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length parameter must be no more than %d\" , INT_MAX ) ; RETURN_FALSE ; }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX ) ; RETURN_FALSE ; }\n"
  },
  {
    "id": 5,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <vul-start> mmap_event -> event_id . header . size , 0 , 0 ) ; <vul-end> if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> header . size <vul-end> , 0 )\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> header. size <vul-end>, 0 )\n"
  },
  {
    "id": 6,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static void lockd_down_net ( struct svc_serv * serv , struct net * net ) { struct lockd_net * ln = net_generic ( net , lockd_net_id ) ; if ( ln -> nlmsvc_users ) { if ( -- ln -> nlmsvc_users == 0 ) { nlm_shutdown_hosts_net ( net ) ; <vul-start> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <vul-end> locks_end_grace ( & ln -> lockd_manager ) ; svc_shutdown_net ( serv , net ) ; dprintk ( \"lockd_down_net: per-net data destroyed; net=%p\\\\n\" , net ) ; } } else { printk ( KERN_ERR \"lockd_down_net: no users! task=%p, net=%p\\\\n\" , nlmsvc_task , net ) ; BUG ( ) ; } }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> net ) ; <vul-end> svc_shutdown_net ( serv\n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> net ) ; cancel_delayed_work_sync <vul-end> ( & ln\n"
  },
  {
    "id": 7,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static int cp2112_gpio_get_all ( struct gpio_chip * chip ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <vul-start> unsigned long flags ; <vul-end> int ret ; <vul-start> spin_lock_irqsave ( & dev -> lock , flags ) ; <vul-end> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_GET_LENGTH ) { hid_err ( hdev , \"error requesting GPIO values: %d\\\\n\" , ret ) ; ret = ret < 0 ? ret : - EIO ; goto exit ; } ret = buf [ 1 ] ; exit : <vul-start> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <vul-end> return ret ; }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; ret <vul-start> ; exit : mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; ret <vul-start> ; exit : mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; return\n"
  },
  {
    "id": 8,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <vul-start> kfree ( resp ) ; <vul-end> return res ; }",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> : kfree ( req ) ; kfree (\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; out : kfree ( req ) ;\n"
  },
  {
    "id": 9,
    "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { <vul-start> umode_t mode = inode -> i_mode ; <vul-end> <vul-start> error = posix_acl_equiv_mode ( acl , & mode ) ; <vul-end> <vul-start> if ( error <= 0 ) { <vul-end> acl = NULL ; if ( error < 0 ) return error ; <vul-start> } <vul-end> error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }",
    "golden_answers": [
      "CWE-285 Fixed Code Lines are: <vul-start> { umode_t mode <vul-end> ; error = <vul-start> ; error = posix_acl_update_mode ( inode <vul-end> , & mode <vul-start> , & mode , & acl <vul-start> if ( error <vul-end> ) return error <vul-start> return error ; <vul-end> error = xfs_set_mode\n"
    ],
    "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> ACL_TYPE_ACCESS ) { struct posix_acl * old_acl = acl ; umode_t new_mode = inode -> i_mode ; error = posix_acl_update_mode ( inode, & new_mode, & acl <vul-end> ) ; if <vul-start> <= 0 ) <vul-end> return error ; <vul-start> return error ; <vul-end> error = xfs_set_mode\n"
  },
  {
    "id": 10,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void aodv_extension ( netdissect_options * ndo , const struct aodv_ext * ep , u_int length ) { <vul-start> const struct aodv_hello * ah ; <vul-end> switch ( ep -> type ) { case AODV_EXT_HELLO : ah = ( const struct aodv_hello * ) ( const void * ) ep ; ND_TCHECK ( * ah ) ; if ( length < sizeof ( struct aodv_hello ) ) <vul-start> goto trunc ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\text HELLO %ld ms\" , ( unsigned long ) EXTRACT_32BITS ( & ah -> interval ) ) ) ; break ; default : ND_PRINT ( ( ndo , \"\\\\n\\\\text %u %u\" , ep -> type , ep -> length ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , \" [|hello]\" ) ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> aodv_hello * ah ; ND_TCHECK ( * ep ) <vul-start> goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\text HELLO - bad length %u\" , ep -> length ) ) ; break ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> aodv_hello * ah ; u_int i <vul-start> ) goto trunc ; for ( i = 0 ; i < length ; i ++ ) ND_TCHECK ( * ah )\n"
  },
  {
    "id": 11,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void mono_gc_cleanup ( void ) { # ifdef DEBUG g_message ( \"%s: cleaning up finalizer\" , __func__ ) ; # endif if ( ! gc_disabled ) { ResetEvent ( shutdown_event ) ; finished = TRUE ; if ( mono_thread_internal_current ( ) != gc_thread ) { mono_gc_finalize_notify ( ) ; if ( WaitForSingleObjectEx ( shutdown_event , 2000 , FALSE ) == WAIT_TIMEOUT ) { int ret ; suspend_finalizers = TRUE ; mono_thread_internal_stop ( gc_thread ) ; ret = WaitForSingleObjectEx ( gc_thread -> handle , 100 , TRUE ) ; if ( ret == WAIT_TIMEOUT ) { g_warning ( \"Shutting down finalizer thread timed out.\" ) ; } else { Sleep ( 100 ) ; } } } gc_thread = NULL ; # ifdef HAVE_BOEHM_GC GC_finalizer_notifier = NULL ; # endif } DeleteCriticalSection ( & handle_section ) ; DeleteCriticalSection ( & allocator_section ) ; DeleteCriticalSection ( & finalizer_mutex ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> finalizer_mutex ) ; DeleteCriticalSection ( & reference_queue_mutex ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> finalizer_mutex ) ; DeleteCriticalSection ( & reference_queue_mutex ) ;\n"
  },
  {
    "id": 12,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <vul-start> assert ( ( cc % stride ) == 0 ) ; <vul-end> if ( cc > stride ) { cc -= stride ; if ( stride == 3 ) { unsigned int r1 , g1 , b1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; do { r1 = cp [ 3 ] ; cp [ 3 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; cp += 3 ; } while ( ( cc -= 3 ) > 0 ) ; } else if ( stride == 4 ) { unsigned int r1 , g1 , b1 , a1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ]",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horDiff8 ( TIFF <vul-start> ) cp0 ; if <vul-end> ( ( cc <vul-start> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horDiff8\" , \"%s\" , \"(cc%stride)!=0\" ) ; return 0 ; } <vul-end> if ( cc <vul-start> ; } } return 1 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horDiff8 ( TIFF <vul-start> ) cp0 ; if <vul-end> ( ( cc <vul-start> % stride )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horDiff8\", \"%s\", \"(cc%stride)!=0\" ) ; return 0 ; } <vul-end> if ( cc <vul-start> ; } } return 1 ;\n"
  },
  {
    "id": 13,
    "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static ssize_t _hostsock_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <vul-start> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <vul-end> OE_RAISE_ERRNO ( OE_EINVAL ) ; <vul-start> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <vul-end> <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <vul-end> if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <vul-start> if ( ret > 0 ) <vul-end> { if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }",
    "golden_answers": [
      "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; size_t data_size = 0 ; <vul-start> , & buf_size , & data_size <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <vul-start> ( ret > ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret >\n"
    ],
    "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; size_t data_size = 0 ; <vul-start>, & buf_size, & data_size <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <vul-start> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n"
  },
  {
    "id": 14,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <vul-start> int x , y , pos ; <vul-end> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( \"Could not create WBMP\" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <vul-start> if ( gdImageGetPixel ( image , x , y ) == fg ) { <vul-end> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( \"Could not save WBMP\" ) ; } freewbmp ( wbmp ) ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> out ) { _gdImageWBMPCtx <vul-end> ( image , <vul-start> ( image , fg , out <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> out ) { gdImagePtr <vul-end> x, y <vul-start> { if ( _gdImageGetPixel <vul-end> ( image,\n"
  },
  {
    "id": 15,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int pci_emul_dinit ( struct vmctx * ctx , struct pci_vdev * dev , char * opts ) { <vul-start> int error ; <vul-end> struct pci_emul_dummy * dummy ; dummy = calloc ( 1 , sizeof ( struct pci_emul_dummy ) ) ; dev -> arg = dummy ; pci_set_cfgdata16 ( dev , PCIR_DEVICE , 0x0001 ) ; pci_set_cfgdata16 ( dev , PCIR_VENDOR , 0x10DD ) ; pci_set_cfgdata8 ( dev , PCIR_CLASS , 0x02 ) ; <vul-start> error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ; <vul-end> assert ( error == 0 ) ; <vul-start> error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ; <vul-end> assert ( error == 0 ) ; <vul-start> error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ; <vul-end> assert ( error == 0 ) ; error = pci_emul_alloc_bar ( dev , 2 , PCIBAR_MEM32 , DMEMSZ ) ; <vul-start> assert ( error == 0 ) ; <vul-end> return 0 ; }",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> opts ) { <vul-end> struct pci_emul_dummy * <vul-start> 0x02 ) ; return <vul-end> pci_emul_add_msicap ( dev <vul-start> , PCI_EMUL_MSI_MSGS ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> , DIOSZ ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> , DMEMSZ ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> DMEMSZ ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> opts ) { <vul-end> struct pci_emul_dummy * <vul-start> 0x02 ) ; return <vul-end> pci_emul_add_msicap ( dev <vul-start> PCI_EMUL_MSI_MSGS ) ; <vul-end> }     <vul-start> 0 ) ; return <vul-end> pci_emul_alloc_bar ( dev <vul-start> PCIBAR_IO, DIOSZ, DMEMSZ ) <vul-end> ; }  \n"
  },
  {
    "id": 16,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <vul-start> { <vul-end> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <vul-start> } else if ( ctx -> might_cancel ) { <vul-end> timerfd_remove_cancel ( ctx ) ; } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <vul-start> } } else { __timerfd_remove_cancel <vul-end> ( ctx ) <vul-start> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> flags ) { bool might_cancel ; <vul-start> ) ; } <vul-end> might_cancel = true <vul-start> ) ; } <vul-end> else if ( <vul-start> -> might_cancel ) <vul-end> timerfd_remove_cancel ( ctx <vul-start> ) ; } <vul-end>      \n"
  },
  {
    "id": 17,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void psf_asciiheader_printf ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; int maxlen ; char * start ; <vul-start> maxlen = strlen ( ( char * ) psf -> header ) ; <vul-end> <vul-start> start = ( ( char * ) psf -> header ) + maxlen ; <vul-end> <vul-start> maxlen = sizeof ( psf -> header ) - maxlen ; <vul-end> va_start ( argptr , format ) ; vsnprintf ( start , maxlen , format , argptr ) ; va_end ( argptr ) ; start [ maxlen - 1 ] = 0 ; <vul-start> psf -> headindex = strlen ( ( char * ) psf -> header ) ; <vul-end> return ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> psf -> header . ptr <vul-start> psf -> header . ptr <vul-start> ; maxlen = <vul-end> psf -> header <vul-start> psf -> header . len <vul-end> - maxlen ; <vul-start> ; psf -> header . indx <vul-end> = strlen ( <vul-start> psf -> header . ptr\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> psf -> header. ptr <vul-start> psf -> header. ptr <vul-start> psf -> header. ptr <vul-start> psf -> header. ptr <vul-start> ) psf -> header. ptr <vul-start> psf -> header. ptr\n"
  },
  {
    "id": 18,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <vul-start> int fd = accept ( socket -> fd , NULL , NULL ) ; <vul-end> if ( fd == INVALID_FD ) { LOG_ERROR ( \"%s unable to accept socket: %s\" , __func__ , strerror ( errno ) ) ; return NULL ; } socket_t * ret = ( socket_t * ) osi_calloc ( sizeof ( socket_t ) ) ; if ( ! ret ) { close ( fd ) ; LOG_ERROR ( \"%s unable to allocate memory for socket.\" , __func__ ) ; return NULL ; } ret -> fd = fd ; return ret ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> int fd = TEMP_FAILURE_RETRY ( <vul-start> NULL , NULL )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int fd = TEMP_FAILURE_RETRY ( <vul-start> NULL, NULL )\n"
  },
  {
    "id": 19,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <vul-start> struct desc_struct * desc ; <vul-end> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <vul-start> desc = get_desc ( sel ) ; <vul-end> <vul-start> if ( ! desc ) <vul-end> return - 1L ; <vul-start> return get_desc_base ( desc ) ; <vul-end> }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; short <vul-start> - 1L ; <vul-end> if ( ! <vul-start> if ( ! get_desc ( & desc , sel ) <vul-end> ) return - <vul-start> return get_desc_base ( &\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; short <vul-start> - 1L ; <vul-end> if (! <vul-start> if (! get_desc ( & desc, sel ) <vul-end> ) return - <vul-start> return get_desc_base ( & desc -> <vul-end> desc ) ;\n"
  },
  {
    "id": 20,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <vul-start> int err = 0 ; <vul-end> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> err = 0 ; if (! net_eq ( current_net ( ), sock_net ( sk ) -> sctp. addr_wq_head ) ) return - EINVAL\n"
  },
  {
    "id": 21,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <vul-start> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <vul-end> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <vul-start> encode_nops ( & hdr ) ; <vul-end> }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> + op_decode_hdr_maxsz + <vul-end> 1 ; encode_getattr_two <vul-start> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> + 1 ; if ( args -> acl_pgbase + args -> acl_len > NFS4_MAX_ACL_SIZE ) { nfs_set_rsp_error ( req, \"fattr bitmap exceeds the maximum allowed (%d)\", NFS4_MAX_ACL_SIZE ) ; return ; } <vul-start> acl_len ) ; xdr_inline_pages ( & req -> rq_rcv_buf, replen << 2, args -> acl_pages, args -> acl_pgbase, args -> acl_len ) ;\n"
  },
  {
    "id": 22,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void rpc_init_task ( struct rpc_task * task , const struct rpc_task_setup * task_setup_data ) { memset ( task , 0 , sizeof ( * task ) ) ; atomic_set ( & task -> tk_count , 1 ) ; task -> tk_flags = task_setup_data -> flags ; task -> tk_ops = task_setup_data -> callback_ops ; task -> tk_calldata = task_setup_data -> callback_data ; INIT_LIST_HEAD ( & task -> tk_task ) ; task -> tk_garb_retry = 2 ; task -> tk_cred_retry = 2 ; <vul-start> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <vul-end> task -> tk_owner = current -> tgid ; task -> tk_workqueue = task_setup_data -> workqueue ; if ( task -> tk_ops -> rpc_call_prepare != NULL ) task -> tk_action = rpc_prepare_task ; task -> tk_start = ktime_get ( ) ; dprintk ( \"RPC: new task initialized, procpid %u\\\\n\" , task_pid_nr ( current ) ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ; task -> tk_rebind_retry = 2 ; task ->\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> task_setup_data -> priority <vul-end> ; task ->\n"
  },
  {
    "id": 23,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \\'\\\\\"\\' ) { * ep = str ; return 0 ; } <vul-start> while ( * end_ptr != \\'\\\\\"\\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\\\\\' ) end_ptr ++ ; <vul-end> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\\\b' ; break ; case 'f' : * ptr2 ++ = '\\\\f' ; break ; case 'n' : * ptr2 ++ = '\\\\n' ; break ; case 'r' : * ptr2 ++ = '\\\\r' ; break ; case 't' : * ptr2 ++ = '\\\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ++ len ) { <vul-start> == '\\\\\\\\' ) { if ( * end_ptr == '\\\\0' ) { return 0 ; } end_ptr ++ ; } } <vul-end> out = (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } while ( ( end_ptr - str ) > 0 &&\n"
  },
  {
    "id": 24,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <vul-start> if ( ! fs_searchpaths ) <vul-end> Com_Error ( ERR_FATAL , \"Filesystem call made without initialization\" ) ; <vul-start> for ( search = fs_searchpaths ; search ; search = search -> next ) <vul-end> <vul-start> { <vul-end> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , \"%s\\\\n\" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> long len ; qboolean isLocalConfig ; <vul-start> \"Filesystem call made without initialization\" ) ; isLocalConfig = ! strcmp ( filename , \"autoexec.cfg\" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <vul-start> next ) { if ( isLocalConfig && search -> pack ) continue ;\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> long len ; search = fs_searchpaths ; <vul-start> ( search = <vul-end> fs_searchpaths ; search <vul-start> next ) { if (! search ) continue ;\n"
  },
  {
    "id": 25,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , \"arguments\" ) ) jsC_error ( J , catchvar , \"redefining \\'arguments\\' is not allowed in strict mode\" ) ; if ( ! strcmp ( catchvar -> string , \"eval\" ) ) jsC_error ( J , catchvar , \"redefining \\'eval\\' is not allowed in strict mode\" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; <vul-start> L3 = emitjump ( J , F , OP_JUMP ) ; <vul-end> } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, F, OP_JUMP_ASM <vul-end> ) ; }\n"
  },
  {
    "id": 26,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , <vul-start> unsigned int depth ) { <vul-end> struct lookahead_ctx * ctx = NULL ; depth = clamp ( depth , 1 , MAX_LAG_BUFFERS ) ; depth += MAX_PRE_FRAMES ; ctx = calloc ( 1 , sizeof ( * ctx ) ) ; if ( ctx ) { <vul-start> unsigned int i ; <vul-end> ctx -> max_sz = depth ; ctx -> buf = calloc ( depth , sizeof ( * ctx -> buf ) ) ; if ( ! ctx -> buf ) goto bail ; for ( i = 0 ; i < depth ; i ++ ) <vul-start> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <vul-end> width , height , subsampling_x , subsampling_y , <vul-start> VP9_ENC_BORDER_IN_PIXELS ) ) <vul-end> goto bail ; } return ctx ; bail : vp9_lookahead_destroy ( ctx ) ; return NULL ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <vul-start> ctx ) { const int legacy_byte_alignment = 0 ; <vul-start> ) if ( vpx_alloc_frame_buffer <vul-end> ( & ctx <vul-start> , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <vul-end> ) ) goto\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> unsigned int depth, vpx_bit_depth_t bit_depth <vul-start> ctx ) { const VP9_COMMON_CONTEXT * const cm = & ctx -> common ; <vul-start> i ++ ) { const VP9_COMMON_CONTEXT * const frame = <vul-end> & ctx -> <vul-start> [ i ] ; if (! frame ) goto bail ; if ( vp9_alloc_frame_buffer ( & frame -> <vul-end> img, width <vul-start>, subsampling_y, VPX_ENC_BORDER_IN_PIXELS ) ) goto bail ; } <vul-end> } return ctx\n"
  },
  {
    "id": 27,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <vul-start> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <vul-end> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> 0 ; i < <vul-end> SERDES_MAX ; i\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> regs ) ; if (! ctrl -> phys ) { dev_err ( & pdev -> dev, \"missing SERDES memory\\\\n\" ) ; return - EINVAL ; }\n"
  },
  {
    "id": 28,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ; <vul-start> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <vul-end> return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if (! tx32. stabil ) return - EINVAL ; if (\n"
  },
  {
    "id": 29,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; <vul-start> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <vul-end> if ( ret == - 1 ) { APPL_TRACE_ERROR ( \"poll ret -1, exit the thread, errno:%d, err:%s\" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( \"h:%d, process_cmd_sock return false, exit...\" , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( \"no data, select ret: %d\" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( \"socket poll thread exiting, h:%d\" , h ) ; return 0 ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> , - 1 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start>, - 1 )\n"
  },
  {
    "id": 30,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <vul-start> break ; <vul-end> } return TRUE ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> objp ) ; * objp = NULL ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> objp ) ; * objp = NULL ;\n"
  },
  {
    "id": 31,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } <vul-start> ret = copy_to_user ( uattr , attr , usize ) ; <vul-end> if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> , attr , attr -> size <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> usize ; } attr -> user = ( char * ) uattr ;\n"
  },
  {
    "id": 32,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 void bn_mul_comba4 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) { <vul-start> BN_ULONG t1 , t2 ; <vul-end> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ;",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> ) { BN_ULONG <vul-end> c1 , c2\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ) { BN_ULONG <vul-end> c1, c2\n"
  },
  {
    "id": 33,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  },
  {
    "id": 34,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <vul-start> if ( ! head ) { <vul-end> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <vul-start> } <vul-end> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; if ( WARN_ON_ONCE ( <vul-start> ! head ) ) <vul-end> return - EINVAL <vul-start> - EINVAL ; <vul-end> hlist_add_head_rcu ( &\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>! head ) <vul-end> return - EINVAL <vul-start> - EINVAL ; <vul-end> hlist_add_head_rcu ( &\n"
  },
  {
    "id": 35,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 void nlmsvc_grant_reply ( struct nlm_cookie * cookie , __be32 status ) { struct nlm_block * block ; dprintk ( \"grant_reply: looking for cookie %x, s=%d \\\\n\" , * ( unsigned int * ) ( cookie -> data ) , status ) ; if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) return ; <vul-start> if ( block ) { <vul-end> if ( status == nlm_lck_denied_grace_period ) { nlmsvc_insert_block ( block , 10 * HZ ) ; } else { nlmsvc_unlink_block ( block ) ; } <vul-start> } <vul-end> nlmsvc_release_block ( block ) ; }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> ; if ( <vul-end> status == nlm_lck_denied_grace_period <vul-start> ) ; } <vul-end> nlmsvc_release_block ( block\n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> ( block ) <vul-end> nlmsvc_insert_block ( block <vul-start> ) ; } <vul-end> nlmsvc_release_block ( block\n"
  },
  {
    "id": 36,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int ccid3_hc_tx_getsockopt ( struct sock * sk , const int optname , int len , u32 __user * optval , int __user * optlen ) { const struct ccid3_hc_tx_sock * hc = ccid3_hc_tx_sk ( sk ) ; struct tfrc_tx_info tfrc ; const void * val ; switch ( optname ) { case DCCP_SOCKOPT_CCID_TX_INFO : if ( len < sizeof ( tfrc ) ) return - EINVAL ; <vul-start> tfrc . tfrctx_x = hc -> tx_x ; <vul-end> tfrc . tfrctx_x_recv = hc -> tx_x_recv ; tfrc . tfrctx_x_calc = hc -> tx_x_calc ; tfrc . tfrctx_rtt = hc -> tx_rtt ; tfrc . tfrctx_p = hc -> tx_p ; tfrc . tfrctx_rto = hc -> tx_t_rto ; tfrc . tfrctx_ipi = hc -> tx_t_ipi ; len = sizeof ( tfrc ) ; val = & tfrc ; break ; default : return - ENOPROTOOPT ; } if ( put_user ( len , optlen ) || copy_to_user ( optval , val , len ) ) return - EFAULT ; return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> - EINVAL ; memset ( & tfrc, 0, sizeof ( tfrc ) ) ;\n"
  },
  {
    "id": 37,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( \"alloc\" , \"allocate a new management address (family: %d)\" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ; <vul-start> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <vul-end> memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> = family ; <vul-end> memcpy ( &\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> = family ; <vul-end> memcpy ( &\n"
  },
  {
    "id": 38,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int jp2_pclr_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_pclr_t * pclr = & box -> data . pclr ; int lutsize ; unsigned int i ; unsigned int j ; int_fast32_t x ; pclr -> lutdata = 0 ; <vul-start> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <vul-end> jp2_getuint8 ( in , & pclr -> numchans ) ) { return - 1 ; } lutsize = pclr -> numlutents * pclr -> numchans ; if ( ! ( pclr -> lutdata = jas_alloc2 ( lutsize , sizeof ( int_fast32_t ) ) ) ) { return - 1 ; } if ( ! ( pclr -> bpc = jas_alloc2 ( pclr -> numchans , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < pclr -> numchans ; ++ i ) { if ( jp2_getuint8 ( in , & pclr -> bpc [ i ] ) ) { return - 1 ; } } for ( i = 0 ; i < pclr -> numlutents ; ++ i ) { for ( j = 0 ; j < pclr -> numchans ; ++ j ) { if ( jp2_getint ( in , ( pclr -> bpc [ j ] & 0x80 ) != 0 , ( pclr -> bpc [ j ] & 0x7f ) + 1 , & x ) ) { return - 1 ; } pclr -> lutdata [ i * pclr -> numchans + j ] = x ; } }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> = 0 ; pclr -> bpc = 0 ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if (! ( pclr -> bpc = jas_alloc2 ( pclr -> numchans, sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } if (\n"
  },
  {
    "id": 39,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <vul-end> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <vul-start> vp9_fdct4x4_c ( input , output , stride ) ; <vul-end> } else { <vul-start> int16_t out [ 4 * 4 ] ; <vul-end> <vul-start> int16_t * outptr = & out [ 0 ] ; <vul-end> int i , j ; <vul-start> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <vul-end> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <vul-start> outptr [ j * 4 + i ] = temp_out [ j ] ; <vul-end> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * input , tran_low_t <vul-end> * output , <vul-start> DCT_DCT ) { vpx_fdct4x4_c <vul-end> ( input , <vul-start> } else { tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; <vul-end> int i , <vul-start> , j ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) out <vul-end> [ j *\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * input, tran_low_t <vul-end> * output, <vul-start> tx_type ) { vpx_fdct4x4_c <vul-end> ( input, <vul-start> } else { tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; <vul-end> int i, <vul-start>, j ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) out <vul-end> [ j *\n"
  },
  {
    "id": 40,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\\\n' ) s [ len - 1 ] = '\\\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , \"/FontName\" , 9 ) == 0 ) { <vul-start> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <vul-end> if ( * s == '/' ) { const char * t = ++ s ; <vul-start> while ( * t && ! isspace ( * t ) ) t ++ ; <vul-end> free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; isspace ( ( unsigned char ) <vul-start> ! isspace ( ( unsigned char )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> += 9 ; isprint ( * s ) && <vul-start>! isspace ( ( unsigned char )\n"
  },
  {
    "id": 41,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , \"Primer pack item length %d\" , item_len ) ; return AVERROR_PATCHWELCOME ; } <vul-start> if ( item_num > 65536 ) { <vul-end> av_log ( mxf -> fc , AV_LOG_ERROR , \"item_num %d is too large\\\\n\" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , \"Multiple primer packs\\\\n\" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> item_num > 65536 || item_num < 0\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> if ( item_num >= <vul-end> 65536 ) {\n"
  },
  {
    "id": 42,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 l_int32 gplotMakeOutput ( GPLOT * gplot ) { <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> char * cmdname ; l_int32 ignore ; PROCNAME ( \"gplotMakeOutput\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot not defined\" , procName , 1 ) ; gplotGenCommandFile ( gplot ) ; gplotGenDataFiles ( gplot ) ; cmdname = genPathname ( gplot -> cmdname , NULL ) ; # ifndef _WIN32 <vul-start> snprintf ( buf , L_BUF_SIZE , \"gnuplot %s\" , cmdname ) ; <vul-end> # else <vul-start> snprintf ( buf , L_BUF_SIZE , \"wgnuplot %s\" , cmdname ) ; <vul-end> # endif # ifndef OS_IOS ignore = system ( buf ) ; # endif LEPT_FREE ( cmdname ) ; return 0 ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf , L_BUFSIZE <vul-end> , \"gnuplot %s\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"wgnuplot %s\" ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf, L_BUFSIZE <vul-end>, \"gnuplot %s\", <vul-start> ( buf, L_BUFSIZE <vul-end>, \"wgnuplot %s\",\n"
  },
  {
    "id": 43,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void videobuf_vm_close ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; struct videobuf_queue * q = map -> q ; int i ; <vul-start> dprintk ( 2 , \"vm_close %p [count=%d,vma=%08lx-%08lx]\\\\n\" , map , <vul-end> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count -- ; if ( 0 == map -> count ) { dprintk ( 1 , \"munmap %p q=%p\\\\n\" , map , q ) ; mutex_lock ( & q -> lock ) ; for ( i = 0 ; i < VIDEO_MAX_FRAME ; i ++ ) { if ( NULL == q -> bufs [ i ] ) continue ; if ( q -> bufs [ i ] -> map != map ) continue ; q -> ops -> buf_release ( q , q -> bufs [ i ] ) ; q -> bufs [ i ] -> map = NULL ; q -> bufs [ i ] -> baddr = 0 ; } mutex_unlock ( & q -> lock ) ; kfree ( map ) ; } return ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( 2 , \"vm_close %p [count=%u,vma=%08lx-%08lx]\\\\n\" <vul-end> , map ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( 2, \"vm_close %p [count=%u,vma=%08lx-%08lx]\\\\n\" <vul-end>, map,\n"
  },
  {
    "id": 44,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static const char * parse_array ( cJSON * item , const char * value ) <vul-end> { cJSON * child ; if ( * value != '[' ) { <vul-start> ep = value ; <vul-end> return 0 ; } item -> type = cJSON_Array ; value = skip ( value + 1 ) ; if ( * value == ']' ) <vul-start> return value + 1 ; <vul-end> <vul-start> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <vul-end> return 0 ; <vul-start> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <vul-end> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <vul-start> child = new_item ; <vul-end> <vul-start> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <vul-end> return 0 ; } if ( * value == ']' ) <vul-start> return value + 1 ; <vul-end> ep = value ; return 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> char * value , const char * * ep <vul-start> '[' ) { * ep = value ; return 0 ; <vul-end> } item -> <vul-start> == ']' ) return value + 1 ; <vul-end> item -> child <vul-start> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <vul-end> value = skip <vul-start> ( value ) , ep ) ) ; if ( ! value ) <vul-end> return 0 ; <vul-start> = child ; child = new_item ; <vul-end> value = skip <vul-start> + 1 ) , ep ) ) ; if ( ! value ) <vul-end> return 0 ; <vul-start> == ']' ) return value + 1 ; * ep = value ; <vul-end> return 0 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char * value, const char * * ep ) { cJSON * child ; size_t new_size <vul-end> ; if ( <vul-start> '[' ) { * ep = value ; return 0 ; } if (! ep ) { <vul-end> item -> type <vul-start> == ']' ) goto error <vul-end> ; if ( <vul-start> cJSON_New_Item ( ), ep ) ) ) goto error <vul-end> ; if ( <vul-start> ) ) ) goto error <vul-end> ; while ( <vul-start> = child ; new_item -> next = child ; new_item -> prev = child ; <vul-start> == ']' ) goto error ; ep = value ; return 0 ; error : if ( ep ) * ep = new_size ; <vul-end> return 0 ;\n"
  },
  {
    "id": 45,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <vul-start> char * driver_override , * old = pdev -> driver_override , * cp ; <vul-end> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\\\n' ) ; if ( cp ) * cp = '\\\\0' ; <vul-start> if ( strlen ( driver_override ) ) { <vul-end> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <vul-start> kfree ( old ) ; <vul-end> return count ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> , * old <vul-end> , * cp <vul-start> = '\\\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <vul-start> NULL ; } device_unlock ( dev ) ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>, * old <vul-end>, * cp <vul-start> = '\\\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <vul-start> NULL ; } device_unlock ( dev ) ;\n"
  },
  {
    "id": 46,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { <vul-start> int i ; <vul-end> int ret ; <vul-start> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <vul-end> if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) <vul-start> * value |= PCI_COMMAND_IO ; <vul-end> if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ) { int ret = pci_read_config_word <vul-end> ( dev , <vul-start> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <vul-end> * value |= <vul-start> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <vul-end> return ret ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> data ) { struct pci_cmd_info * cmd = data ; int i, ret ; cmd -> value [ 0 ] = PCI_COMMAND_IO ; cmd -> value [ 1 ] = PCI_COMMAND_MEMORY ; <vul-end> ret = xen_pcibk_read_config_word <vul-start>, offset, & cmd -> value [ 0 ] <vul-end>, data ) <vul-start> * value |= cmd -> value [ PCI_COMMAND_IO ] <vul-end> ; } return\n"
  },
  {
    "id": 47,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) { <vul-start> Py_ssize_t i ; <vul-end> PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> self ) { size_t <vul-end> i ; PyObject\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> self ) { size_t <vul-end> i ; PyObject\n"
  },
  {
    "id": 48,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <vul-start> kern_msg -> msg_name = kern_address ; <vul-end> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> err ; } if ( kern_msg -> msg_name )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err ; } else { struct sockaddr_storage * s = kern_address ; if (! s ) return - EFAULT ; s -> msg_namelen = sizeof ( * s ) ; <vul-start> -> msg_name = get_name ( s, kern_address, kern_msg -> msg_namelen ) ; } <vul-end> } else kern_msg\n"
  },
  {
    "id": 49,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-end> int mi_row , int mi_col , vp9_reader * r ) { <vul-start> struct segmentation * const seg = & cm -> seg ; <vul-end> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; int segment_id ; if ( ! seg -> enabled ) return 0 ; <vul-start> if ( ! seg -> update_map ) <vul-end> <vul-start> return 0 ; <vul-end> segment_id = read_segment_id ( r , seg ) ; <vul-start> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <vul-end> return segment_id ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> const cm , int mi_offset , int x_mis , int y_mis , vpx_reader <vul-end> * r ) <vul-start> cm -> seg <vul-end> ; int segment_id <vul-start> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <vul-start> return 0 ; } <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , segment_id )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int read_segment_id ( <vul-end> MACROBLOCKD * const <vul-start> const xd, struct segmentation * const seg, <vul-start> r ) { <vul-end> int segment_id ; <vul-start> -> update_map ) { set_segment_id ( cm, bsize, mi_row, mi_col, segment_id ) ; return 0 ; } <vul-end> segment_id = read_segment_id <vul-start> seg ) ; <vul-end> return segment_id ;\n"
  },
  {
    "id": 50,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int <vul-start> ext2_xattr_cache_insert ( struct buffer_head * bh ) <vul-end> { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; <vul-start> struct mb_cache_entry * ce ; <vul-end> int error ; <vul-start> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <vul-end> if ( ! ce ) return - ENOMEM ; <vul-start> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <vul-end> if ( error ) { <vul-start> mb_cache_entry_free ( ce ) ; <vul-end> if ( error == - EBUSY ) { ea_bdebug ( bh , \"already in cache (%d cache entries)\" , atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; error = 0 ; } <vul-start> } else { <vul-end> <vul-start> ea_bdebug ( bh , \"inserting [%x] (%d cache entries)\" , ( int ) hash , <vul-end> atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; mb_cache_entry_release ( ce ) ; } return error ; }",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> int ext2_xattr_cache_insert ( struct mb2_cache * cache , <vul-start> h_hash ) ; <vul-end> int error ; <vul-start> int error ; error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <vul-end> , bh -> <vul-start> bh -> b_blocknr <vul-end> ) ; if <vul-start> error ) { <vul-end> if ( error <vul-start> } } else <vul-end> ea_bdebug ( bh <vul-start> ( bh , \"inserting [%x]\" <vul-end> , ( int <vul-start> int ) hash ) ; <vul-end> return error ;\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ext2_xattr_cache_insert ( struct mb2_cache * ext2_mb_cache, struct mb2_cache * ext2_mb_cache, struct <vul-start> h_hash ) ; <vul-end> int error ; <vul-start> int error ; error = mb2_cache_entry_create <vul-end> ( ext2_xattr_cache, <vul-start> ext2_xattr_cache, GFP_NOFS, ext2_mb_cache -> c_entry_count, hash, ext2_mb_cache -> c_mb_cache <vul-end> ) ; if <vul-start> ; error = mb2_cache_entry_insert ( ext2_mb_cache, ce, bh -> b_blocknr, hash, ext2_mb_cache -> c_entry_count <vul-end> ) ; if <vul-start> error ) { <vul-end> if ( error <vul-start> 0 ; } mb2_cache_entry_put ( ext2_mb_cache, ce ) ; <vul-start> error ) { <vul-end> if ( error <vul-start> 0 ; } mb2_cache_entry_put ( ext2_mb_cache, ce ) ; <vul-start> } else { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; struct mb2_cache_entry * ce = ext2_mb_cache -> c_ce ; <vul-start> ( bh, \"inserting [%x] (%d cache entries)\" <vul-end>, ( int <vul-start> ( int ) hash, atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; mb2_cache_entry_put ( ext2_mb_cache, ce <vul-end> ) ; }\n"
  },
  {
    "id": 51,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_decoder_remove ( VP9Decoder * pbi ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> int i ; <vul-start> vp9_remove_common ( cm ) ; <vul-end> vp9_worker_end ( & pbi -> lf_worker ) ; <vul-start> vpx_free ( pbi -> lf_worker . data1 ) ; <vul-end> for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { <vul-start> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <vul-end> <vul-start> vp9_worker_end ( worker ) ; <vul-end> <vul-start> vpx_free ( worker -> data1 ) ; <vul-end> <vul-start> vpx_free ( worker -> data2 ) ; <vul-end> } vpx_free ( pbi -> tile_workers ) ; <vul-start> if ( pbi -> num_tile_workers ) { <vul-end> const int sb_rows = mi_cols_aligned_to_sb ( cm -> mi_rows ) >> MI_BLOCK_SIZE_LOG2 ; <vul-start> vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ; <vul-end> } vpx_free ( pbi ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> pbi ) { <vul-end> int i ; <vul-start> int i ; vpx_get_worker_interface ( ) -> end <vul-end> ( & pbi <vul-start> lf_worker . data1 ) ; vpx_free ( pbi -> tile_data <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> i ] ; vpx_get_worker_interface ( ) -> end <vul-end> ( worker ) <vul-start> worker ) ; } vpx_free ( pbi -> tile_worker_data <vul-end> ) ; vpx_free <vul-start> ; vpx_free ( pbi -> tile_worker_info ) ; <vul-end> vpx_free ( pbi <vul-start> pbi -> num_tile_workers > 0 ) { <vul-end> vp9_loop_filter_dealloc ( & <vul-start> pbi -> lf_row_sync <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> pbi ) { VP9EncoderConfig <vul-end> * const cm <vul-start> int i ; vpx_remove_common <vul-end> ( & pbi <vul-start> lf_worker ) ; vpx_free <vul-end> ( pbi -> <vul-start> i ) { VP9WorkerConfig <vul-end> * const worker <vul-start> i ] ; vpx_free <vul-end> ( worker ) <vul-start> worker ) ; vpx_free <vul-end> ( worker -> <vul-start> data1 ) ; vpx_free <vul-end> ( worker -> <vul-start> data2 ) ; } vpx_free ( pbi -> tile_workers ) ; <vul-end> vpx_free ( pbi <vul-start> ( pbi -> lf_row_sync ) ; vpx_free ( pbi -> lf_worker. data1 ) ; vpx_free ( pbi -> lf_worker. data2 ) ; pbi -> num_tile_workers = 0 <vul-end> ; if ( <vul-start> >> MI_BLOCK_SIZE_LOG2 ; vpx_loop_filter_dealloc <vul-end> ( & pbi\n"
  },
  {
    "id": 52,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ; <vul-start> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <vul-end> ret = - EADDRNOTAVAIL ; rdsdebug ( \"addr %pI4 ret %d node type %d\\\\n\" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( ret || ! cm_id -> device ||\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( ret ||! cm_id -> device ||\n"
  },
  {
    "id": 53,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , \"MessagePack pack needs input.\" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , \"Too many arguments for MessagePack pack.\" ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <vul-start> lua_pushvalue ( L , i ) ; <vul-end> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ++ ) { luaL_checkstack ( L , 1 , \"in function mp_check\" ) ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ++ ) { luaL_checkstack ( L, nargs, \"Too many arguments for MessagePack pack.\" ) ;\n"
  },
  {
    "id": 54,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static inline int check_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , const nodemask_t * nodes , unsigned long flags , void * private ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; <vul-start> if ( pmd_none_or_clear_bad ( pmd ) ) <vul-end> continue ; if ( check_pte_range ( vma , pmd , addr , next , nodes , flags , private ) ) return - EIO ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ; if ( pmd_none_or_trans_huge_or_clear_bad <vul-end> ( pmd )\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if ( pmd_none_or_trans_huge_or_clear_bad <vul-end> ( pmd )\n"
  },
  {
    "id": 55,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <vul-start> pipe -> curbuf = 0 ; <vul-end> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ) ; } memset ( pipe -> curbuf, 0, nr_pages << pipe -> nrbufs ) ;\n"
  },
  {
    "id": 56,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) { <vul-start> unsigned int len ; <vul-end> unsigned long start = 0 , off ; <vul-start> struct au1200fb_device * fbdev = info -> par ; <vul-end> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ; <vul-start> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <vul-end> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> vma ) { <vul-end> struct au1200fb_device * <vul-start> info -> par <vul-end> ; vma -> <vul-start> _CACHE_MASK ; return vm_iomap_memory <vul-end> ( vma , <vul-start> ( vma , fbdev -> fb_phys , fbdev -> fb_len <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vma ) { <vul-end> struct au1200fb_device * <vul-start> info -> par ; int ret <vul-start> |= _CACHE_MASK ; ret = vm_iomap_memory ( vma ) ; if ( ret ) return ret ;\n"
  },
  {
    "id": 57,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } <vul-start> while ( offset < end_offset ) <vul-end> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; <vul-start> return offset ; <vul-end> }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> while ( offset > 0 && offset <vul-start> < end_offset ) { <vul-start> hf_keybuffer ) ; }\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> < end_offset ) { if ( di -> conformant_run ) { offset = dissect_spoolss_uint16uni ( tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer ) ; } else { <vul-start> hf_keybuffer ) ; } }\n"
  },
  {
    "id": 58,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 PHP_FUNCTION ( radius_get_vendor_attr ) { <vul-start> int res ; <vul-end> <vul-start> const void * data ; <vul-end> int len ; <vul-start> u_int32_t vendor ; <vul-end> <vul-start> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & data , & len ) == FAILURE ) { <vul-end> return ; } <vul-start> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <vul-end> if ( res == - 1 ) { RETURN_FALSE ; } else { array_init ( return_value ) ; <vul-start> add_assoc_long ( return_value , \"attr\" , res ) ; <vul-end> add_assoc_long ( return_value , \"vendor\" , vendor ) ; <vul-start> add_assoc_stringl ( return_value , \"data\" , ( char * ) data , len , 1 ) ; <vul-end> return ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> radius_get_vendor_attr ) { <vul-end> const void * <vul-start> void * data , * raw <vul-start> ; u_int32_t vendor ; unsigned char type ; size_t data_len <vul-start> \"s\" , & raw <vul-end> , & len <vul-start> return ; } if ( <vul-end> rad_get_vendor_attr ( & <vul-start> vendor , & type , & data , & data_len , raw , len ) <vul-end> == - 1 <vul-start> , \"attr\" , type <vul-end> ) ; add_assoc_long <vul-start> ) data , data_len <vul-end> , 1 )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { int res, vendor, len <vul-start> void * data <vul-end> ; u_int32_t vendor <vul-start> ; u_int32_t vendor ; size_t num_args = 0 <vul-start> TSRMLS_CC, \"s\", & data, & len ) ; if ( data == NULL || len == 0 ) { RETURN_FALSE ; } <vul-end> if ( zend_parse_parameters <vul-start> & vendor, <vul-end> data, ( <vul-start> ) & len, & num_args <vul-start> return_value ) ; add_assoc_long <vul-end> ( return_value, <vul-start> vendor ) ; add_assoc_stringl <vul-end> ( return_value,\n"
  },
  {
    "id": 59,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_resume_port ( struct asd_sas_phy * phy ) { struct domain_device * dev ; struct asd_sas_port * port = phy -> port ; struct sas_ha_struct * sas_ha = phy -> ha ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; if ( si -> dft -> lldd_port_formed ) si -> dft -> lldd_port_formed ( phy ) ; if ( port -> suspended ) port -> suspended = 0 ; else { return ; } list_for_each_entry ( dev , & port -> dev_list , dev_list_node ) { int i , rc ; rc = sas_notify_lldd_dev_found ( dev ) ; if ( rc ) { <vul-start> sas_unregister_dev ( port , dev ) ; <vul-end> continue ; } if ( dev -> dev_type == SAS_EDGE_EXPANDER_DEVICE || dev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) { dev -> ex_dev . ex_change_count = - 1 ; for ( i = 0 ; i < dev -> ex_dev . num_phys ; i ++ ) { struct ex_phy * phy = & dev -> ex_dev . ex_phy [ i ] ; phy -> phy_change_count = - 1 ; } } } sas_discover_event ( port , DISCE_RESUME ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> port , dev ) ; sas_destruct_devices ( port\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> rc ) { sas_destruct_devices ( port ) ;\n"
  },
  {
    "id": 60,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <vul-start> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <vul-end> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key , 0 <vul-end> ) ; up_write\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_positive ( key <vul-end> ) ; up_write\n"
  },
  {
    "id": 61,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { \"Title\" , \"\" } , { \"Author\" , \"\" } , { \"Subject\" , \"\" } , { \"Keywords\" , \"\" } , { \"Creator\" , \"\" } , { \"Producer\" , \"\" } , { \"CreationDate\" , \"\" } , { \"ModDate\" , \"\" } , { \"Trapped\" , \"\" } , } ; <vul-start> daddy = malloc ( sizeof ( creator_template ) ) ; <vul-end> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ; daddy = safe_calloc <vul-end> ( sizeof (\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; daddy = safe_calloc <vul-end> ( sizeof (\n"
  },
  {
    "id": 62,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int __ext4_expand_extra_isize ( struct inode * inode , unsigned int new_extra_isize , struct ext4_iloc * iloc , handle_t * handle , int * no_expand ) { struct ext4_inode * raw_inode ; struct ext4_xattr_ibody_header * header ; <vul-start> int error ; <vul-end> raw_inode = ext4_raw_inode ( iloc ) ; header = IHDR ( inode , raw_inode ) ; if ( ! ext4_test_inode_state ( inode , EXT4_STATE_XATTR ) || header -> h_magic != cpu_to_le32 ( EXT4_XATTR_MAGIC ) ) { memset ( ( void * ) raw_inode + EXT4_GOOD_OLD_INODE_SIZE + EXT4_I ( inode ) -> i_extra_isize , 0 , new_extra_isize - EXT4_I ( inode ) -> i_extra_isize ) ; EXT4_I ( inode ) -> i_extra_isize = new_extra_isize ; return 0 ; } error = ext4_expand_extra_isize_ea ( inode , new_extra_isize , raw_inode , handle ) ; if ( error ) { * no_expand = 1 ; } return error ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> * header ; unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; int error ; if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) { EXT4_ERROR_INODE ( inode , \"bad extra_isize %u (inode size %u)\" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ; return - EFSCORRUPTED ; } if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL <vul-end> ; raw_inode =\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; int error ; if ( ext4_should_dioread_nolock ( inode ) ) return 0\n"
  },
  {
    "id": 63,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; <vul-start> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <vul-end> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( sizeof ( * hdr <vul-end> ) / sizeof\n"
  },
  {
    "id": 64,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int sgi_clock_set ( clockid_t clockid , struct timespec * tp ) { u64 nsec ; <vul-start> u64 rem ; <vul-end> nsec = rtc_time ( ) * sgi_clock_period ; <vul-start> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <vul-end> if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ; else { sgi_clock_offset . tv_nsec = tp -> tv_sec + NSEC_PER_SEC - rem ; sgi_clock_offset . tv_sec -- ; } return 0 ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> u64 nsec ; u32 <vul-end> rem ; nsec <vul-start> -> tv_sec - div_u64_rem <vul-end> ( nsec ,\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> u64 nsec ; u32 <vul-end> rem ; nsec <vul-start> -> tv_sec - div_u64_rem <vul-end> ( nsec,\n"
  },
  {
    "id": 65,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ; <vul-start> value = 0 ; <vul-end> if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; } <vul-start> if ( msg -> oob ) { <vul-end> if ( bits == 8 ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , \"can\\'t read %d bits\" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) { <vul-start> nbits = bits & 7 ; <vul-end> for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <vul-start> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <vul-start> & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <vul-start> msg -> bit , msg -> cursize << 3 <vul-start> ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, nbits ; msg -> readcount = 0 ; <vul-start> msg -> oob && msg -> bit > 0 <vul-start> & 7 ; if ( msg -> readcount >= msg -> maxoffset ) { msg -> readcount = 0 ; msg -> bit = msg -> maxoffset + 1 ; return - 1 ; }\n"
  },
  {
    "id": 66,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int calc_iframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { <vul-start> const RATE_CONTROL * rc = & cpi -> rc ; <vul-end> int target ; if ( cpi -> common . current_video_frame == 0 ) { <vul-start> target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX ) <vul-end> <vul-start> ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; <vul-end> } else { const int initial_boost = 32 ; <vul-start> int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; <vul-end> <vul-start> if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) { <vul-end> kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / <vul-start> ( cpi -> output_framerate / 2 ) ) ; <vul-end> } <vul-start> target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ; <vul-end> } return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cpi -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <vul-start> = ( ( rc -> <vul-end> starting_buffer_level / 2 <vul-start> int ) ( rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <vul-end> kf_boost = MAX <vul-start> = MAX ( kf_boost , ( int ) ( 2 * framerate <vul-end> - 16 ) <vul-start> -> frames_since_key < framerate <vul-end> / 2 ) <vul-start> frames_since_key / ( framerate <vul-end> / 2 ) <vul-start> * rc -> avg_frame_bandwidth <vul-end> ) >> 4\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { const RATE_CONTROL_EXT * rc_ext = & cpi -> rc_ext <vul-end> ; int target <vul-start> target = ( rc_ext -> avg_frame_bandwidth <vul-end> > INT_MAX ) <vul-start>? INT_MAX : rc_ext -> avg_frame_bandwidth <vul-end> ; } else <vul-start> = 32 ; const int kf_boost = MIN ( initial_boost, rc_ext -> avg_frame_bandwidth <vul-end> ) ; if <vul-start> ( rc -> avg_frame_bandwidth <vul-end> < cpi -> <vul-start> < cpi -> oxcf. starting_buffer_level <vul-end> / 2 ) <vul-start> / 2 ) { kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / ( cpi -> oxcf. starting_buffer_level / 2 ) ) ; } else { const int kf_boost = ( int ) ( rc -> frames_since_key / ( cpi -> oxcf. starting_buffer_level / 2 ) ) ; if ( rc -> frames_since_key < cpi -> oxcf. starting_buffer_level / 2 ) { kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / ( cpi -> oxcf. starting_buffer_level / 2 ) ) ; } target = ( <vul-end> ( 16 + <vul-start> * rc -> avg_frame_bandwidth <vul-end> ) >> 4\n"
  },
  {
    "id": 67,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; <vul-start> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <vul-end> up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , XFRMA_TMPL , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> i ] ; memcpy_safe <vul-end> ( & up\n"
  },
  {
    "id": 68,
    "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 static int parse_token ( char * * name , char * * value , char * * cp ) { char * end ; if ( ! name || ! value || ! cp ) return - BLKID_ERR_PARAM ; if ( ! ( * value = strchr ( * cp , '=' ) ) ) return 0 ; * * value = '\\\\0' ; * name = strip_line ( * cp ) ; * value = skip_over_blank ( * value + 1 ) ; if ( * * value == \\'\"\\' ) { <vul-start> end = strchr ( * value + 1 , \\'\"\\' ) ; <vul-end> if ( ! end ) { DBG ( READ , ul_debug ( \"unbalanced quotes at: %s\" , * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++ ; * end = '\\\\0' ; <vul-start> end ++ ; <vul-end> } else { end = skip_over_word ( * value ) ; if ( * end ) { * end = '\\\\0' ; end ++ ; } } * cp = end ; return 1 ; }",
    "golden_answers": [
      "CWE-77 Fixed Code Lines are: <vul-start> \\'\"\\' ) { char * p = end = <vul-end> * value + <vul-start> value + 1 ; while ( * p ) { if ( * p == '\\\\\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \\'\"\\' ) break ; } p ++ ; end ++ ; } if ( * end != \\'\"\\' <vul-end> ) { DBG <vul-start> '\\\\0' ; end = ++ p <vul-end> ; } else\n"
    ],
    "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> { end = * value <vul-end> ; if ( <vul-start> ; end ++ ; if ( end == ( * value ) ) return - BLKID_ERR_CACHE\n"
  },
  {
    "id": 69,
    "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; markold ( g , g -> allgc , g -> reallyold ) ; markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; <vul-start> psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; <vul-end> sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }",
    "golden_answers": [
      "CWE-763 Fixed Code Lines are: <vul-start> L ) ; g -> gcstate = GCSswpallgc ;\n"
    ],
    "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start>, g, <vul-end> g -> allgc\n"
  },
  {
    "id": 70,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; <vul-start> s -> chunksize = - 1 ; <vul-end> for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , \"header=\\'%s\\'\\\\n\" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> chunksize = UINT64_MAX <vul-end> ; for (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = - 1 ; av_assert0 ( s -> filesize > 0 )\n"
  },
  {
    "id": 71,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static void audit_log_execve_info ( struct audit_context * context , struct audit_buffer * * ab ) { <vul-start> int i , len ; <vul-end> size_t len_sent = 0 ; <vul-start> const char __user * p ; <vul-end> char * buf ; p = ( const char __user * ) current -> mm -> arg_start ; <vul-start> audit_log_format ( * ab , \"argc=%d\" , context -> execve . argc ) ; <vul-end> <vul-start> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <vul-end> <vul-start> if ( ! buf ) { <vul-end> audit_panic ( \"out of memory for argv string\" ) ; return ; } <vul-start> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <vul-end> len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ; if ( len <= 0 ) break ; p += len ; } kfree ( buf ) ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ab ) { long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <vul-end> ; const char <vul-start> char __user * <vul-end> p = ( <vul-start> -> arg_start ; char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( \"out of memory for argv string\" ) ; return ; } buf = buf_head ; <vul-start> argc ) ; len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <vul-end> ) ; if <vul-start> if ( ! * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d_len=%lu\" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d[%d]=\" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d=\" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\\\0' ; audit_log_format ( * ab , \"%s\" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <vul-end> < context -> <vul-start> execve . argc ) ; out : kfree ( buf_head <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ab ) { <vul-end> const char __user <vul-start> char __user * buf ; size_t len <vul-end> ; audit_log_format ( <vul-start> * ab, \"argc=%d\" <vul-end>, context -> <vul-start> execve. argc ) ; buf = kzalloc ( MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL ) ; if (! buf ) { audit_panic ( \"out of memory for argv string\" ) ; return ; } for ( i = 0 ; i < <vul-end> context -> execve <vul-start> execve. argc <vul-end> ; i ++\n"
  },
  {
    "id": 72,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; <vul-start> r1 . event = event ; <vul-end> r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) return ; memset ( & r1, 0, sizeof ( r1 ) ) ;\n"
  },
  {
    "id": 73,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_ret_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <vul-start> unsigned long cs ; <vul-end> int cpl = ctxt -> ops -> cpl ( ctxt ) ; <vul-start> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <vul-end> if ( rc != X86EMUL_CONTINUE ) <vul-start> return rc ; <vul-end> if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ; rc = emulate_pop ( ctxt , & cs , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ; <vul-start> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <vul-end> return rc ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ; unsigned long eip , cs ; u16 old_cs <vul-end> ; int cpl <vul-start> ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <vul-start> ctxt , & eip <vul-end> , ctxt -> <vul-start> ) return rc <vul-end> ; rc = <vul-start> ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <vul-end> return rc ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> unsigned long cs = 0 <vul-start> ( ctxt, <vul-end> ctxt -> _eip <vul-start> ) return rc <vul-end> ; rc = <vul-start> return X86EMUL_UNHANDLEABLE ; if (! ( cs & 3 ) ) return X86EMUL_UNHANDLEABLE ;\n"
  },
  {
    "id": 74,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) { ECDSA_SIG * s ; <vul-start> int ret = - 1 ; <vul-end> s = ECDSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <vul-start> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <vul-end> ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ; err : <vul-start> ECDSA_SIG_free ( s ) ; <vul-end> return ( ret ) ; }",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <vul-start> s , & p <vul-end> , sig_len ) <vul-start> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <vul-start> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; <vul-start> s, & p <vul-end>, sig_len ) <vul-start> == NULL ) goto err ; der = i2d_ECDSA_SIG ( s, & der ) ; if ( der == NULL ) <vul-start> ; err : i2d_ECDSA_SIG_free ( der ) ;\n"
  },
  {
    "id": 75,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <vul-start> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <vul-end> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <vul-end> ; } else\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> { r = onig_filter_enc ( ci <vul-end>, ci ->\n"
  },
  {
    "id": 76,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; <vul-start> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <vul-end> rcu_read_unlock ( ) ; return res ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt )\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt ), <vul-end> np -> tclass\n"
  },
  {
    "id": 77,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static struct clock_source * dce120_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( * clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <vul-start> BREAK_TO_DEBUGGER ( ) ; <vul-end> return NULL ; }",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> base ; } kfree ( clk_src ) ;\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> base ; } kfree ( clk_src ) ;\n"
  },
  {
    "id": 78,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , <vul-start> OPJ_UINT32 * p_data_written , <vul-end> const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; <vul-start> opj_write_bytes ( p_data , J2K_MS_SOT , <vul-end> 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <vul-start> p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not enough bytes in output buffer to write SOT marker\\\\n\" ) ; return OPJ_FALSE ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> * p_data, <vul-end> const opj_stream_private_t * <vul-start> p_manager ) ; opj_write_bytes <vul-end> ( p_data,\n"
  },
  {
    "id": 79,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void ip4_datagram_release_cb ( struct sock * sk ) { const struct inet_sock * inet = inet_sk ( sk ) ; const struct ip_options_rcu * inet_opt ; __be32 daddr = inet -> inet_daddr ; <vul-start> struct flowi4 fl4 ; <vul-end> struct rtable * rt ; <vul-start> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <vul-end> return ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; <vul-start> if ( ! IS_ERR ( rt ) ) <vul-end> <vul-start> __sk_dst_set ( sk , & rt -> dst ) ; <vul-end> rcu_read_unlock ( ) ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> inet_daddr ; struct dst_entry * dst ; struct <vul-start> * rt ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <vul-start> if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst <vul-end> , 0 ) <vul-start> 0 ) ) { rcu_read_unlock ( ) ; return ; } <vul-end> inet_opt = rcu_dereference <vul-start> sk_bound_dev_if ) ; dst = <vul-end> ! IS_ERR ( <vul-start> ( rt ) ? <vul-end> & rt -> <vul-start> & rt -> dst : NULL ; sk_dst_set ( sk ,\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> inet_daddr ; struct dst_entry * dst ; struct <vul-start> * rt ; rcu_read_lock ( ) ; dst = rcu_dereference ( inet -> inet_dst ) ; if (! dst ||! <vul-end> __sk_dst_check ( sk <vul-start>, 0 ) ) goto out <vul-end> ; inet_opt = <vul-start> sk_bound_dev_if ) ; out : <vul-start> rt ) ) dst_put ( dst <vul-end> ) ; rcu_read_unlock\n"
  },
  {
    "id": 80,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_bit_string ( const u8 * inbuf , size_t inlen , void * outbuf , size_t outlen , int invert ) { const u8 * in = inbuf ; u8 * out = ( u8 * ) outbuf ; <vul-start> int zero_bits = * in & 0x07 ; <vul-end> <vul-start> size_t octets_left = inlen - 1 ; <vul-end> <vul-start> int i , count = 0 ; <vul-end> memset ( outbuf , 0 , outlen ) ; in ++ ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 ) - zero_bits ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <vul-start> & 0x07 ; <vul-end> octets_left = inlen <vul-start> - 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <vul-end> ) - zero_bits\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) outbuf ; const <vul-start> & 0x07 ; const <vul-start> - 1 ; const <vul-start> count = 0 ; if ( octets_left < 0 ) return SC_ERROR_BUFFER_TOO_SMALL\n"
  },
  {
    "id": 81,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) { <vul-start> u_char * b , * s , * t , c ; <vul-end> int i , proto ; const void * se ; if ( length <= 0 ) return ; <vul-start> b = ( uint8_t * ) malloc ( length ) ; <vul-end> if ( b == NULL ) return ; <vul-start> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <vul-end> c = * s ++ ; if ( c == 0x7d ) { <vul-start> if ( i > 1 ) { <vul-end> i -- ; <vul-start> c = * s ++ ^ 0x20 ; <vul-end> } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; default : break ; } if ( length < 2 ) goto trunc ; proto = EXTRACT_16BITS ( b ) ; switch ( proto ) { case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ; proto",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> b , * <vul-end> t , c <vul-start> t , c ; const u_char * s <vul-start> b = ( u_char <vul-end> * ) malloc <vul-start> ( s = <vul-end> p , t <vul-start> i > 0 && ND_TTEST ( * s ) <vul-start> if ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <vul-end> i -- ; <vul-start> ++ ^ 0x20 <vul-end> ; } *\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> length ) { netdissect_options_t <vul-end> * b, <vul-start> uint8_t * ) calloc ( length, sizeof ( uint8_t ) <vul-end> ) ; if <vul-start> ) return ; memcpy ( b, p, length ) ; <vul-end> if ( b <vul-start> 0x7d ) { <vul-end> c = * <vul-start> s ++ ^ 0x40 ; } else { c = * s ++ ; } <vul-end> * t ++\n"
  },
  {
    "id": 82,
    "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static int renameTableSelectCb ( Walker * pWalker , Select * pSelect ) { int i ; RenameCtx * p = pWalker -> u . pRename ; <vul-start> SrcList * pSrc = pSelect -> pSrc ; <vul-end> if ( pSrc == 0 ) { assert ( pWalker -> pParse -> db -> mallocFailed ) ; return WRC_Abort ; } for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pSrc -> a [ i ] ; if ( pItem -> pTab == p -> pTab ) { renameTokenFind ( pWalker -> pParse , p , pItem -> zName ) ; } } renameWalkWith ( pWalker , pSelect ) ; return WRC_Continue ; }",
    "golden_answers": [
      "CWE-674 Fixed Code Lines are: <vul-start> pSelect -> pSrc ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune\n"
    ],
    "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> pSelect -> pSrc ; assert ( p -> selFlags & SF_View )\n"
  },
  {
    "id": 83,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) { <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_8x8 ( tran_low_t <vul-end> * output , <vul-start> stride ) { store_output ( & res [ 0 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 1 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 2 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 3 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 4 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 5 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 6 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 7 ] , <vul-end> ( output + <vul-start> * stride ) <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_8x8 ( tran_low_t <vul-end> * output, <vul-start> * output, tran_low_t <vul-end> * res, <vul-start> stride ) { store_si128 ( output, <vul-end> res [ 0 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 1 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 2 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 3 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 4 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 5 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 6 <vul-start> ] ) ; store_si128 ( output, <vul-end> res [ 7\n"
  },
  {
    "id": 84,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\\\n\" , cb_info -> users ) ; <vul-start> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <vul-end> if ( ! serv ) { printk ( KERN_ERR \"nfs_callback_create_svc: create service failed\\\\n\" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( \"nfs_callback_create_svc: service created\\\\n\" ) ; return serv ; }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> ; serv = svc_create_pooled <vul-end> ( & nfs4_callback_program\n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> NFS4_CALLBACK_BUFSIZE, sv_ops, NULL\n"
  },
  {
    "id": 85,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 <vul-start> static void consume_one_event ( unsigned cpu , <vul-end> struct evtchn_fifo_control_block * control_block , <vul-start> unsigned priority , unsigned long * ready , <vul-end> bool drop ) { struct evtchn_fifo_queue * q = & per_cpu ( cpu_queue , cpu ) ; uint32_t head ; evtchn_port_t port ; event_word_t * word ; head = q -> head [ priority ] ; if ( head == 0 ) { virt_rmb ( ) ; head = control_block -> head [ priority ] ; } port = head ; word = event_word_from_port ( port ) ; head = clear_linked ( word ) ; if ( head == 0 ) clear_bit ( priority , ready ) ; if ( evtchn_fifo_is_pending ( port ) && ! evtchn_fifo_is_masked ( port ) ) { <vul-start> if ( unlikely ( drop ) ) <vul-end> pr_warn ( \"Dropping pending event for port %u\\\\n\" , port ) ; else <vul-start> handle_irq_for_port ( port ) ; <vul-end> } q -> head [ priority ] = head ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <vul-start> long * ready <vul-end> ) { struct <vul-start> ( unlikely ( ! ctrl <vul-end> ) ) pr_warn <vul-start> handle_irq_for_port ( port , ctrl\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> void consume_one_event ( struct evtchn_loop_ctrl * ctrl, <vul-start> long * ready <vul-end> ) { struct <vul-start> ) ) { struct evtchn_loop_ctrl * ctrl = & per_cpu ( cpu_queue, cpu ) ; <vul-start> handle_irq_for_port ( port, ctrl\n"
  },
  {
    "id": 86,
    "question": "CWE-347 Code Input Vulnerable Code Is: CWE-347 <vul-start> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <vul-end> PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } }",
    "golden_answers": [
      "CWE-347 Fixed Code Lines are: <vul-start> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }\n"
    ],
    "generated_answer": "CWE-347 Fixed Code Lines are: <vul-start> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }\n"
  },
  {
    "id": 87,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : <vul-start> case NPNVSupportsWindowless : <vul-end> type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NPNVSupportsXEmbedBool : case NPNVSupportsAdvancedKeyHandling : case\n"
  },
  {
    "id": 88,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , \"sorbo\" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( \"Inet check by %s %d\\\\n\" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; <vul-start> last_id = ntohs ( * pid ) ; <vul-end> if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( \"Got packet %d %d\" , last_id , plen ) ; if ( is_dup (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> - 2 ; if ( plen < 0 ) return 0 ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; last_id = ntohl <vul-end> ( * pid\n"
  },
  {
    "id": 89,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; <vul-start> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <vul-end> close ( fd ) ; return ret ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> msg , MSG_DONTWAIT )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start>, MSG_DONTWAIT ) )\n"
  },
  {
    "id": 90,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) { <vul-start> if ( length == 1 && bp [ 0 ] == 0xff ) { <vul-end> ND_PRINT ( ( ndo , \"isakmp-nat-keep-alive\" ) ) ; return ; } if ( length < 4 ) { goto trunc ; <vul-start> } <vul-end> if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , \"NONESP-encap: \" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , \"UDP-encap: \" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , \"[|isakmp]\" ) ) ; return ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <vul-start> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <vul-start> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;\n"
  },
  {
    "id": 91,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ; <vul-start> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <vul-end> old_eip = ctxt -> _eip ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <vul-start> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <vul-end> return X86EMUL_CONTINUE ; <vul-start> ctxt -> _eip = 0 ; <vul-end> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <vul-end> , VCPU_SREG_CS ) <vul-start> , VCPU_SREG_CS ) <vul-end> ; memcpy ( <vul-start> 2 ) ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <vul-end> ) return X86EMUL_CONTINUE <vul-start> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( ctxt, VCPU_SREG_EIP <vul-end> ) ; old_eip <vul-start> ( sel, VCPU_SREG_EIP <vul-end> ) ) return <vul-start> -> _eip = NULL <vul-end> ; memcpy (\n"
  },
  {
    "id": 92,
    "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 <vul-start> static void oidc_scrub_headers ( request_rec * r ) { <vul-end> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }",
    "golden_answers": [
      "CWE-287 Fixed Code Lines are: <vul-start>       <vul-end> void oidc_scrub_headers (\n"
    ],
    "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> r ) { oidc_scrub_headers_internal ( r ) ;\n"
  },
  {
    "id": 93,
    "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <vul-start> start = vma -> vm_start ; <vul-end> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }",
    "golden_answers": [
      "CWE-667 Fixed Code Lines are: <vul-start> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;\n"
    ],
    "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> vma -> vm_start <vul-end> ; if (\n"
  },
  {
    "id": 94,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <vul-start> unix_inflight ( scm -> fp -> fp [ i ] ) ; <vul-end> return max_level ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> -> fp -> user , scm -> fp ->\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> fp -> user, scm -> fp ->\n"
  },
  {
    "id": 95,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <vul-start> int count , i ; <vul-end> count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> * ace ; unsigned\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> count, i ; if (! aclp -> acl_entry ) return ERR_PTR ( - EINVAL )\n"
  },
  {
    "id": 96,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <vul-start> size_t e ; <vul-end> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <vul-start> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <vul-end> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <vul-start> } <vul-end> }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; size_t e ; mrb_value nil <vul-start> ) ) { <vul-end> mrb_gc_mark ( mrb <vul-start> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; size_t e ; mrb_value t <vul-start> ) ) { t = <vul-end> mrb_basic_ptr ( v <vul-start> ( v ) ; if ( t <vul-start> ; } } if (! mrb_gc_is_valid_location ( mrb, c -> stbase, e ) ) { c -> stbase [ i ] = mrb_nil_value ( ) ; } else { c -> stbase [ i ] = t ; }\n"
  },
  {
    "id": 97,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <vul-start> struct loop_device * lo = disk -> private_data ; <vul-end> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <vul-start> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <vul-end> }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <vul-end> disk -> private_data <vul-start> disk -> private_data ) ; <vul-end> mutex_unlock ( & <vul-start> mutex_unlock ( & loop_index_mutex <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( disk, mode <vul-end> ) ; } <vul-start> ) ; } <vul-end> }    \n"
  },
  {
    "id": 98,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 key_ref_t keyring_search ( key_ref_t keyring , struct key_type * type , const char * description ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <vul-start> . match_data . cmp = type -> match , <vul-end> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , } ; key_ref_t key ; <vul-start> int ret ; <vul-end> if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) return ERR_PTR ( ret ) ; } key = keyring_search_aux ( keyring , & ctx ) ; if ( type -> match_free ) type -> match_free ( & ctx . match_data ) ; return key ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> . cmp = key_default_cmp <vul-end> , . match_data <vul-start> ; int ret <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>. cmp = key_default_cmp <vul-end>,. match_data <vul-start> ; int ret ; if (! ctx. match_data. cmp ) return ERR_PTR ( - ENOKEY )\n"
  },
  {
    "id": 99,
    "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 void rfbSendServerCutText ( rfbScreenInfoPtr rfbScreen , char * str , int len ) { rfbClientPtr cl ; rfbServerCutTextMsg sct ; rfbClientIteratorPtr iterator ; <vul-start> iterator = rfbGetClientIterator ( rfbScreen ) ; <vul-end> while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) { sct . type = rfbServerCutText ; sct . length = Swap32IfLE ( len ) ; LOCK ( cl -> sendMutex ) ; if ( rfbWriteExact ( cl , ( char * ) & sct , sz_rfbServerCutTextMsg ) < 0 ) { rfbLogPerror ( \"rfbSendServerCutText: write\" ) ; rfbCloseClient ( cl ) ; UNLOCK ( cl -> sendMutex ) ; continue ; } if ( rfbWriteExact ( cl , str , len ) < 0 ) { rfbLogPerror ( \"rfbSendServerCutText: write\" ) ; rfbCloseClient ( cl ) ; } UNLOCK ( cl -> sendMutex ) ; rfbStatRecordMessageSent ( cl , rfbServerCutText , sz_rfbServerCutTextMsg + len , sz_rfbServerCutTextMsg + len ) ; } rfbReleaseClientIterator ( iterator ) ; }",
    "golden_answers": [
      "CWE-665 Fixed Code Lines are: <vul-start> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;\n"
    ],
    "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> rfbClientIteratorPtr iterator ; if ( len < 0 ) { rfbLogPerror ( \"rfbSendServerCutText: write, len 0 is zero\" ) ; rfbCloseClient ( cl ) ; return ; }\n"
  },
  {
    "id": 100,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int read_filesystem_tables_4 ( ) { <vul-start> long long directory_table_end , table_start ; <vul-end> if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) <vul-start> return FALSE ; <vul-end> if ( read_uids_guids ( & table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> if ( parse_exports_table ( & table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> <vul-start> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <vul-end> return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( \"read_filesystem_tables: xattr id table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_xattrs_from_disk <vul-start> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: id table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( \"read_filesystem_tables: Bad id count in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( \"read_filesystem_tables: Bad id count in super block\\\\n\" ) ; goto corrupted ; } if ( read_id_table <vul-end> ( & table_start <vul-start> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: lookup table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( parse_exports_table <vul-start> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: fragment table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( \"read_filesystem_tables: Bad fragment count in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_fragment_table <vul-start> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( \"read_filesystem_tables: fragment table start invalid in super block\\\\n\" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: directory table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( \"read_filesystem_tables: inode table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_inode_table <vul-start> == FALSE ) goto corrupted <vul-end> ; if ( <vul-start> return TRUE ; corrupted : ERROR ( \"File system corruption detected\\\\n\" ) ; return FALSE ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) { <vul-end> long long table_start <vul-start> == 0 ) { <vul-start> return FALSE ; } <vul-start> == FALSE ) { <vul-start> return FALSE ; } <vul-start> == FALSE ) { <vul-start> return FALSE ; } <vul-start> read_fragment_table ( & sBlk. s. <vul-start> == FALSE ) { <vul-start> return FALSE ; } <vul-start> == FALSE ) { <vul-start> return FALSE ; } <vul-start> == FALSE ) { <vul-start> return FALSE ; } <vul-start> TRUE ; } trunc : return FALSE ;\n"
  },
  {
    "id": 101,
    "question": "CWE-732 Code Input Vulnerable Code Is: CWE-732 static struct env * <vul-start> createenv ( const struct rule * rule ) <vul-end> { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ; <vul-start> env -> count = 0 ; <vul-end> if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } } <vul-start> } <vul-end> return env ; }",
    "golden_answers": [
      "CWE-732 Fixed Code Lines are: <vul-start> rule * rule , const struct passwd * mypw , const struct passwd * targpw <vul-start> count = 0 ; addnode ( env , \"DOAS_USER\" , mypw -> pw_name ) <vul-start> } } } else { static const char * copyset [ ] = { \"DISPLAY\" , \"TERM\" , NULL } ; addnode ( env , \"HOME\" , targpw -> pw_dir ) ; addnode ( env , \"LOGNAME\" , targpw -> pw_name ) ; addnode ( env , \"PATH\" , getenv ( \"PATH\" ) ) ; addnode ( env , \"SHELL\" , targpw -> pw_shell ) ; addnode ( env , \"USER\" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; }\n"
    ],
    "generated_answer": "CWE-732 Fixed Code Lines are: <vul-start> rule * rule, const char * prefix <vul-start> count = 0 <vul-end> ; for ( <vul-start> ; } } if ( prefix ) strlcpy ( env -> key, prefix, sizeof ( env -> key ) ) ;\n"
  },
  {
    "id": 102,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 BOOL rdp_read_share_control_header ( wStream * s , UINT16 * length , UINT16 * type , UINT16 * channel_id ) { <vul-start> if ( Stream_GetRemainingLength ( s ) < 2 ) <vul-end> return FALSE ; <vul-start> Stream_Read_UINT16 ( s , * length ) ; <vul-end> <vul-start> if ( * length == 0x8000 ) <vul-end> { <vul-start> rdp_read_flow_control_pdu ( s , type ) ; <vul-end> * channel_id = 0 ; * length = 8 ; return TRUE ; } <vul-start> if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) ) <vul-end> return FALSE ; Stream_Read_UINT16 ( s , * type ) ; * type &= 0x0F ; <vul-start> if ( * length > 4 ) <vul-end> Stream_Read_UINT16 ( s , * channel_id ) ; else * channel_id = 0 ; return TRUE ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> channel_id ) { UINT16 len ; <vul-start> ( s , len ) ; * length = len <vul-end> ; if ( <vul-start> ; if ( len <vul-end> == 0x8000 ) <vul-start> 0x8000 ) { if ( ! <vul-start> , type ) ) return FALSE <vul-start> if ( ( len < 4 ) || ( ( len <vul-end> - 2 ) <vul-start> Stream_GetRemainingLength ( s ) <vul-start> ; if ( len <vul-end> > 4 )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> { if (! Stream_GetRemainingLength ( s ) <vul-end> ) return FALSE <vul-start>, * length, & stream_default_length <vul-start> 0x8000 ) { if (! Stream_GetRemainingLength ( s ) ) return FALSE ; <vul-start> s, type, & stream_default_length ) ; * channel_id = 0 ; * length = 8 ; return TRUE ; } if ( Stream_GetRemainingLength ( s ) < * length - 2 ) return FALSE ; Stream_Read_UINT16 ( s, * type <vul-start> 2 ) > Stream_GetRemainingLength ( s ) ) return FALSE ; Stream_Read_UINT16 ( s, * channel_id ) ; * channel_id = 0 ; * length = 8 ; return TRUE ; } if ( Stream_GetRemainingLength ( s ) < * length - 2 <vul-end> ) > Stream_GetRemainingLength <vul-start> ( s ) ||! Stream_GetRemainingLength ( s ) <vul-start> &= 0x0F ; * channel_id = 0 ; * length = 8 ; return TRUE ; } <vul-end>      \n"
  },
  {
    "id": 103,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 node * PyParser_ParseStringObject ( const char * s , PyObject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( * flags & PyPARSE_IGNORE_COOKIE ) tok = PyTokenizer_FromUTF8 ( s , exec_input ) ; else tok = PyTokenizer_FromString ( s , exec_input ) ; if ( tok == NULL ) { err_ret -> error = PyErr_Occurred ( ) ? E_DECODE : E_NOMEM ; return NULL ; } <vul-start> # ifndef PGEN <vul-end> Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( * flags & PyPARSE_ASYNC_ALWAYS ) { tok -> async_always = 1 ; }\n"
  },
  {
    "id": 104,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <vul-end> int mi_row , int mi_col , int segment_id ) { <vul-start> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <vul-end> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; int x , y ; assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ; <vul-start> for ( y = 0 ; y < ymis ; y ++ ) <vul-end> <vul-start> for ( x = 0 ; x < xmis ; x ++ ) <vul-end> <vul-start> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cm , int mi_offset , int x_mis , int y_mis <vul-end> , int segment_id <vul-start> segment_id ) { <vul-end> int x , <vul-start> ; y < y_mis <vul-end> ; y ++ <vul-start> ; x < x_mis <vul-end> ; x ++ <vul-start> ) cm -> current_frame_seg_map <vul-end> [ mi_offset +\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> set_segment_id ( V9_COMMON <vul-start> * cm, const <vul-start> segment_id ) { int mi_offset = ( mi_row << cm -> mi_cols ) + ( mi_col << cm -> mi_rows ) ; <vul-start> MAX_SEGMENTS ) ; mi_offset += cm -> mi_rows ; <vul-start> y ++ ) { <vul-start> x ++ ) { <vul-start> = segment_id ; } } return 0\n"
  },
  {
    "id": 105,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; int srcoffset , dstoffset ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; int linestocopy ; linestocopy = ( source -> y_height >> 4 ) / PARTIAL_FRAME_FRACTION ; linestocopy = linestocopy ? linestocopy << 4 : 16 ; srcoffset = source -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; dstoffset = dest -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; src += srcoffset ; dst += dstoffset ; for ( i = 0 ; i < linestocopy ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <vul-start> Total += vp8_mse16x16 ( src + j , source -> y_stride , <vul-end> dst + j , dest -> y_stride , & sse ) ; } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
  },
  {
    "id": 106,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int flush_completed_IO ( struct inode * inode ) { <vul-start> ext4_io_end_t * io ; <vul-end> int ret = 0 ; int ret2 = 0 ; <vul-start> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) <vul-end> return ret ; dump_completed_IO ( inode ) ; <vul-start> while ( ! list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <vul-end> <vul-start> io = list_entry ( EXT4_I ( inode ) -> i_completed_io_list . next , <vul-end> ext4_io_end_t , list ) ; <vul-start> ret = ext4_end_io_nolock ( io ) ; <vul-end> if ( ret < 0 ) ret2 = ret ; else list_del_init ( & io -> list ) ; } <vul-start> return ( ret2 < 0 ) ? ret2 : 0 ; <vul-end> }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ext4_io_end_t * io ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <vul-start> list_empty ( & ei <vul-end> -> i_completed_io_list ) <vul-start> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <vul-start> list_empty ( & ei <vul-end> -> i_completed_io_list ) <vul-start> = list_entry ( ei <vul-end> -> i_completed_io_list . <vul-start> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <vul-start> ext4_end_io_nolock ( io ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <vul-start> ) ; } spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> inode ) { ext4_io_t * io, * tmp <vul-end> ; int ret <vul-start> = 0 ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags2 ; spin_lock_irqsave ( & ei -> i_completed_io_lock, flags ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock, flags ) ; <vul-start> list_empty ( & ei <vul-end> -> i_completed_io_list ) <vul-start> ) ) { tmp <vul-end> = list_entry ( <vul-start> ; ret = ext4_end_io_cancel ( tmp, flags, inode <vul-end> ) ; if <vul-start> ) ; } spin_lock_irqsave ( & ei -> i_completed_io_lock, flags ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock, flags ) ;\n"
  },
  {
    "id": 107,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int __usb_get_extra_descriptor ( char * buffer , unsigned size , <vul-start> unsigned char type , void * * ptr ) <vul-end> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <vul-start> if ( header -> bLength < 2 ) { <vul-end> printk ( KERN_ERR \"%s: bogus descriptor, type %d length %d\\\\n\" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <vul-start> if ( header -> bDescriptorType == type ) { <vul-end> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> * * ptr , size_t minsize <vul-start> bLength < 2 || header -> bLength > size <vul-start> bDescriptorType == type && header -> bLength >= minsize\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> unsigned size, <vul-end> char type, <vul-start> ; if ( size < header -> bLength ) { printk ( KERN_ERR \"%s: invalid descriptor buffer length\\\\n\", usbcore_name ) ; return - EINVAL ; } if ( <vul-start> type ) { if ( ptr )\n"
  },
  {
    "id": 108,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <vul-start> if ( j >= length ) return - 1 ; <vul-end> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> u8 label_len ; <vul-end> GET8 ( label_len <vul-start> - 1 ; if ( j + label_len > length ) return - 1 ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u8 label_len ; int label_len_copy ; <vul-start> - 1 ; label_len_copy = label_len ; <vul-start> + j, label_len_copy <vul-end> ) ; cp\n"
  },
  {
    "id": 109,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <vul-start> unsigned long flags ; <vul-end> int ret ; <vul-start> spin_lock_irqsave ( & dev -> lock , flags ) ; <vul-end> buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , \"error setting GPIO values: %d\\\\n\" , ret ) ; <vul-start> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <vul-end> }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; buf <vul-start> ret ) ; mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; buf <vul-start> ret ) ; mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; }\n"
  },
  {
    "id": 110,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ; x += 4 <vul-end> ) { index\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; x += 4 <vul-end> ) { index\n"
  },
  {
    "id": 111,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; } <vul-start> # endif <vul-end> ++ x -> ymode_count [ m ] ; ++ x -> uv_mode_count [ uvm ] ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; } # else ( void ) cpi ; #\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; } # else ( void ) cpi ; ( void ) uvm ; #\n"
  },
  {
    "id": 112,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; } <vul-start> smb_flush_file ( sr , sr -> fid_ofile ) ; <vul-end> } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ; <vul-start> smb_flush_file ( sr , file ) ; <vul-end> mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ) ; } smb_ofile_flush <vul-end> ( sr , <vul-start> f_mutex ) ; smb_ofile_flush <vul-end> ( sr ,\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) ; } smb_try_flush_file <vul-end> ( sr, <vul-start> f_mutex ) ; smb_try_flush_file <vul-end> ( sr,\n"
  },
  {
    "id": 113,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int mwifiex_pcie_alloc_cmdrsp_buf ( struct mwifiex_adapter * adapter ) { struct pcie_service_card * card = adapter -> card ; struct sk_buff * skb ; skb = dev_alloc_skb ( MWIFIEX_UPLD_SIZE ) ; if ( ! skb ) { mwifiex_dbg ( adapter , ERROR , \"Unable to allocate skb for command response data.\\\\n\" ) ; return - ENOMEM ; } skb_put ( skb , MWIFIEX_UPLD_SIZE ) ; if ( mwifiex_map_pci_memory ( adapter , skb , MWIFIEX_UPLD_SIZE , <vul-start> PCI_DMA_FROMDEVICE ) ) <vul-end> <vul-start> return - 1 ; <vul-end> card -> cmdrsp_buf = skb ; return 0 ; }",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ; <vul-start> - 1 ; }\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> PCI_DMA_FROMDEVICE ) ) { dev_kfree_skb ( skb ) ; kfree ( card -> cmdrsp_buf ) ; <vul-start> - 1 ; }\n"
  },
  {
    "id": 114,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 void pci_lintr_request ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int bestpin , bestcount , pin ; bi = pci_businfo [ dev -> bus ] ; <vul-start> assert ( bi != NULL ) ; <vul-end> si = & bi -> slotinfo [ dev -> slot ] ; bestpin = 0 ; bestcount = si -> si_intpins [ 0 ] . ii_count ; for ( pin = 1 ; pin < 4 ; pin ++ ) { if ( si -> si_intpins [ pin ] . ii_count < bestcount ) { bestpin = pin ; bestcount = si -> si_intpins [ pin ] . ii_count ; } } si -> si_intpins [ bestpin ] . ii_count ++ ; dev -> lintr . pin = bestpin + 1 ; pci_set_cfgdata8 ( dev , PCIR_INTPIN , bestpin + 1 ) ; }",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> bus ] ; if ( bi == NULL ) { pr_err ( \"%s: pci [%s] has wrong bus %d info!\\\\n\" , __func__ , dev -> name , dev -> bus ) ; return ; } <vul-end> si = &\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> bus ] ; if ( bi == NULL ) { pr_err ( \"%s: pci [%s] has wrong bus %d info!\\\\n\", __func__, dev -> name, dev -> bus ) ; return ; } <vul-end> si = &\n"
  },
  {
    "id": 115,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , \"%s/dev/console\" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( \"console path too long\" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( \"rootfs specified but no console found at \\'%s\\'\" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( \"no console\" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( \"failed to stat \\'%s\\'\" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( \"failed to set mode \\'0%o\\' to \\'%s\\'\" , s . st_mode , console -> name ) ; return - 1 ; } <vul-start> if ( mount ( console -> name , path , \"none\" , MS_BIND , 0 ) ) { <vul-end> ERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , console -> name , path ) ; return - 1 ; } INFO ( \"console has been setup\" ) ; return 0 ; }",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount ( console -> name , path , \"none\" , MS_BIND , 0 , rootfs -> mount <vul-end> ) ) {\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount <vul-end> ( console ->\n"
  },
  {
    "id": 116,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <vul-start> if ( wp -> listening_socket != STDIN_FILENO ) { <vul-end> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , \"failed to init child stdio: dup2()\" ) ; return - 1 ; } } return 0 ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> return 0 ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> return 0 ;\n"
  },
  {
    "id": 117,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <vul-end> { u16 * op ; int size ; unicode_t u ; op = pwcs ; <vul-start> while ( * s && len > 0 ) { <vul-end> if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; <vul-start> if ( u >= PLANE_SIZE ) { <vul-end> <vul-start> u -= PLANE_SIZE ; <vul-end> <vul-start> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <vul-end> <vul-start> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <vul-end> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | <vul-start> ( u & SURROGATE_BITS ) ) ; <vul-end> } else { <vul-start> * op ++ = ( wchar_t ) u ; <vul-end> } s += size ; len -= size ; } else { <vul-start> * op ++ = * s ++ ; <vul-end> len -- ; } } return op - pwcs ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int len , enum utf16_endian endian , <vul-start> wchar_t * pwcs , int maxlen <vul-start> ; while ( <vul-end> len > 0 <vul-start> len > 0 && maxlen > 0 && * s <vul-start> - EINVAL ; s += size ; len -= size ; <vul-start> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <vul-start> -= PLANE_SIZE ; put_utf16 ( op ++ , <vul-end> SURROGATE_PAIR | ( <vul-start> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <vul-end> SURROGATE_PAIR | SURROGATE_LOW <vul-start> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <vul-end> ; } else <vul-start> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <vul-end> } else { <vul-start> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <vul-end> -- ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> wchar_t * pwcs, int op_len <vul-start> len > 0 && op_len <vul-start> >= PLANE_SIZE ) <vul-end> u -= PLANE_SIZE <vul-start> u -= PLANE_SIZE ; if ( op_len < size ) return - EINVAL <vul-start> wchar_t ) ( SURROGATE_PAIR | ( <vul-end> ( u >> <vul-start> & SURROGATE_BITS ) ) ) ; else * op ++ = ( wchar_t ) ( u <vul-start> } else { if ( op_len < size ) return - EINVAL ; <vul-start> op ++ = <vul-end> * s ++\n"
  },
  {
    "id": 118,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int write_superframe_index ( vpx_codec_alg_priv_t * ctx ) { uint8_t marker = 0xc0 ; unsigned int mask ; int mag , index_sz ; assert ( ctx -> pending_frame_count ) ; assert ( ctx -> pending_frame_count <= 8 ) ; marker |= ctx -> pending_frame_count - 1 ; for ( mag = 0 , mask = 0xff ; mag < 4 ; mag ++ ) { if ( ctx -> pending_frame_magnitude < mask ) break ; mask <<= 8 ; mask |= 0xff ; } marker |= mag << 3 ; index_sz = 2 + ( mag + 1 ) * ctx -> pending_frame_count ; if ( ctx -> pending_cx_data_sz + index_sz < ctx -> cx_data_sz ) { uint8_t * x = ctx -> pending_cx_data + ctx -> pending_cx_data_sz ; <vul-start> int i , j ; <vul-end> * x ++ = marker ; for ( i = 0 ; i < ctx -> pending_frame_count ; i ++ ) { unsigned int this_sz = ( unsigned int ) ctx -> pending_frame_sizes [ i ] ; for ( j = 0 ; j <= mag ; j ++ ) { * x ++ = this_sz & 0xff ; this_sz >>= 8 ; } } * x ++ = marker ; ctx -> pending_cx_data_sz += index_sz ; <vul-start> } <vul-end> return index_sz ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( \"Added supplemental superframe data\\\\n\" ) ; # endif <vul-start> += index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i, j ; if ( index_sz > 0 ) { assert ( ctx -> pending_cx_data_sz < ctx -> cx_data_sz ) <vul-start> index_sz ; } }\n"
  },
  {
    "id": 119,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <vul-start> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <vul-end> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <vul-start> if ( ! i_ext || ! i_ext -> len ) <vul-end> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <vul-start> return false ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <vul-end> ) ; if <vul-start> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <vul-end> ) ; return <vul-start> ) ; return ret <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( inode ) ; bool ret = false <vul-start> i_ext -> len ||! et -> node_cnt <vul-start> lock ) ; if (! et ) { ret = true ; goto out_unlock ; }\n"
  },
  {
    "id": 120,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) { <vul-start> int i , y ; <vul-end> for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { <vul-start> fwrite ( buf , 1 , w , file ) ; <vul-end> buf += stride ; } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <vul-start> ( buf , bytes_per_sample <vul-end> , w ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i, y ; const int bytespp = img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH <vul-start> y ) { if ( bytespp!= ( 1 << ( i + 3 ) ) ) { fprintf ( stderr, \"Image\\'s actual size does not match the expected one\\\\n\" ) ; return ; } <vul-start>, file ) ; if ( bytespp!= ( 1 << ( i + 3 ) ) ) { fprintf ( stderr, \"Image\\'s actual size does not match the expected one\\\\n\" ) ; return ; } fprintf ( stderr, \"Image\\'s actual size does not match the expected one\\\\n\"\n"
  },
  {
    "id": 121,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <vul-start> ut8 * directory_base ; <vul-end> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , \"mdmp_directory.offset\" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , \"mdmp_directory.format\" , \"[4]E? \" \"(mdmp_stream_type)StreamType \" \"(mdmp_location_descriptor)Location\" , 0 ) ; <vul-start> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <vul-end> <vul-start> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <vul-end> <vul-start> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <vul-end> } return true ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> int i ; struct minidump_directory entry <vul-end> ; sdb_num_set ( <vul-start> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <vul-start> ++ ) { ut32 delta = <vul-end> i * sizeof <vul-start> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <vul-start> ) ) ; if ( r ) { <vul-start> ( obj , & <vul-start> entry ) ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ut8 * directory_base <vul-end> = obj -> <vul-start> 0 ) ; struct minidump_directory * entry ; <vul-start> ++ ) { <vul-end> r_bin_mdmp_init_directory_entry ( obj <vul-start> obj, entry, 0\n"
  },
  {
    "id": 122,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ; <vul-start> struct kvm_lapic * apic = vcpu -> arch . apic ; <vul-end> void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; <vul-start> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <vul-end> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> arch . apic <vul-end> ; apic_sync_pv_eoi_to_guest ( <vul-start> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & <vul-end> vcpu -> arch <vul-start> . apic -> vapic_cache , & data , sizeof ( u32 ) <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> arch. apic <vul-end> ; apic_sync_pv_eoi_to_guest ( <vul-start> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm, & <vul-end> vcpu -> arch <vul-start>. apic -> vapic_cache, & data, sizeof ( u32 ) <vul-end> ) ; }\n"
  },
  {
    "id": 123,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void box_blur_line ( gint box_width , gint even_offset , guchar * src , guchar * dest , gint len , gint bpp ) { gint i ; gint lead ; gint output ; gint trail ; <vul-start> gint * ac ; <vul-end> ac = g_new0 ( gint , bpp ) ; lead = 0 ; if ( box_width % 2 != 0 ) { output = lead - ( box_width - 1 ) / 2 ; trail = lead - box_width ; } else { if ( even_offset == 1 ) { output = lead + 1 - box_width / 2 ; trail = lead - box_width ; } else if ( even_offset == - 1 ) { output = lead - box_width / 2 ; trail = lead - box_width ; } else { g_assert_not_reached ( ) ; } } for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] = 0 ; while ( output < len ) { guint coverage = ( lead < len ? lead : len - 1 ) - ( trail >= 0 ? trail : - 1 ) ; # ifdef READABLE_BOXBLUR_CODE for ( i = 0 ; i < bpp ; i ++ ) { if ( lead < len ) ac [ i ] += src [ bpp * lead + i ] ; if ( trail >= 0 ) ac [ i ] -= src [ bpp * trail + i ] ; if ( output >= 0 ) dest [ bpp * output + i",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> gint * ac ; g_assert ( box_width > 0 )\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> gint * ac ; if ( box_width < 0 || box_width > len ) box_width = len\n"
  },
  {
    "id": 124,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; <vul-start> default : <vul-end> errno = EINVAL ; return - 1 ; } }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_SHNUM_MIN : * ( size_t * ) val = ms -> elf_shnum_min ; return 0 ;\n"
  },
  {
    "id": 125,
    "question": "CWE-326 Code Input Vulnerable Code Is: CWE-326 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <vul-start> static u32 ip_idents_hashrnd __read_mostly ; <vul-end> u32 hash , id ; <vul-start> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <vul-end> <vul-start> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <vul-end> ( __force u32 ) iph -> saddr , <vul-start> iph -> protocol ^ net_hash_mix ( net ) , <vul-end> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }",
    "golden_answers": [
      "CWE-326 Fixed Code Lines are: <vul-start> segs ) { <vul-end> u32 hash , <vul-start> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <vul-end> , sizeof ( <vul-start> , sizeof ( net -> ipv4 . ip_id_key <vul-end> ) ) ; <vul-start> ; hash = siphash_3u32 <vul-end> ( ( __force <vul-start> iph -> protocol , & net -> ipv4 . ip_id_key <vul-end> ) ; id\n"
    ],
    "generated_answer": "CWE-326 Fixed Code Lines are: <vul-start> segs ) { u32 hash, id <vul-end> ; net_get_random_once ( <vul-start> sizeof ( ip_idents_hashrnd <vul-end> ) ) ; <vul-start> = jhash_3words ( <vul-end> iph -> daddr <vul-start> iph -> protocol <vul-end> ^ net_hash_mix (\n"
  },
  {
    "id": 126,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <vul-start> int isopen ; <vul-end> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid input syntax for type polygon: \\\\\"%s\\\\\"\" , str ) ) ) ; <vul-start> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <vul-end> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid input syntax for type polygon: \\\\\"%s\\\\\"\" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> size ; int base_size ; int <vul-start> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <vul-start> ] ) + base_size ; if ( base_size / npts != <vul-start> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( \"too many points requested\" ) ) ) <vul-end> ; poly =\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; int isopen ; int base_size <vul-start> ) ) ; base_size = sizeof ( POLYGON -> p [ 0 ] ) + base_size ; <vul-start> 0 ] ) * base_size\n"
  },
  {
    "id": 127,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) <vul-start> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <vul-end> up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key , 0 <vul-end> ) ; up_write\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_positive ( key, 0 <vul-end> ) ; up_write\n"
  },
  {
    "id": 128,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , \"%s,%s,%s,%s,%s\" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( \"chfn\" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; <vul-start> if ( setpwnam ( ctl -> pw ) < 0 ) { <vul-end> warn ( \"setpwnam failed\" ) ; # endif printf ( _ ( \"Finger information *NOT* changed. Try again later.\\\\n\" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( \"Finger information changed.\\\\n\" ) ) ; return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ctl -> pw , \".chfn\"\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( setpwuid ( ctl -> pw, 0, ctl -> pw -> pw_uid ) < 0 ) { warn ( \"setpwuid failed\" ) ; # endif printf ( _ ( \"Finger information *NOT* changed. Try again later.\\\\n\" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( \"Finger information changed.\\\\n\" ) ) ; return 0 ; } # endif printf ( _ ( \"Finger information changed.\\\\n\" ) ) ; <vul-end> free ( gecos\n"
  },
  {
    "id": 129,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <vul-start> } <vul-end> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> NULL ; } dst_state -> speculative = src -> speculative ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> = NULL ; dst_state -> frame [ i ] = NULL ;\n"
  },
  {
    "id": 130,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <vul-start> _iov -> iov_len = min ( ( u64 ) len , size ) ; <vul-end> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> u64 ) len - s\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> guest_phys_addr ; if ( unlikely ( size > iov_size ) ) { ret = - EINVAL ; break ; }\n"
  },
  {
    "id": 131,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <vul-start> struct desc_struct * desc ; <vul-end> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <vul-start> desc = get_desc ( sel ) ; <vul-end> <vul-start> if ( ! desc ) <vul-end> return 0 ; <vul-start> limit = get_desc_limit ( desc ) ; <vul-end> <vul-start> if ( desc -> g ) <vul-end> limit = ( limit << 12 ) + 0xfff ; return limit ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; unsigned <vul-start> return 0 ; <vul-end> if ( ! <vul-start> if ( ! get_desc ( & desc , sel ) <vul-end> ) return 0 <vul-start> = get_desc_limit ( & <vul-start> if ( desc . <vul-end> g ) limit\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; unsigned <vul-start> return 0 ; <vul-end> if (! <vul-start> if (! get_desc ( & desc, sel ) <vul-end> ) return 0 <vul-start> = get_desc_limit ( & <vul-start> ; if ( desc. <vul-end> g ) limit\n"
  },
  {
    "id": 132,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_codec_set_frame_buffer_functions ( vpx_codec_ctx_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { vpx_codec_err_t res ; if ( ! ctx || ! cb_get || ! cb_release ) { res = VPX_CODEC_INVALID_PARAM ; } else if ( ! ctx -> iface || ! ctx -> priv || ! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else { <vul-start> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <vul-end> cb_priv ) ; } return SAVE_STATUS ( ctx , res ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> . set_fb_fn ( get_alg_priv ( ctx ) <vul-end> , cb_get ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. set_fb_fn ( get_alg_priv ( ctx ) <vul-end>, cb_get,\n"
  },
  {
    "id": 133,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"rdd\" , & IM , & input , & output ) == FAILURE ) { return ; } <vul-start> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , \"Image\" , le_gd ) ; <vul-end> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Gamma values should be positive\" ) ; RETURN_FALSE ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> return ; } if ( input < 0 || output < 0 || input > 255 ) { return ; }\n"
  },
  {
    "id": 134,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = \"`\\\\\"\\\\\\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \\'\"\\' ; <vul-start> dlen -= 2 ; <vul-end> for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \\'\"\\' ; * pt = '\\\\0' ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; dlen -= 3 <vul-end> ; for (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = \\'\"\\' ; if ( dlen < 2 ) return ;\n"
  },
  {
    "id": 135,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void fdct8 ( const int16_t * input , int16_t * output ) { <vul-end> <vul-start> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <vul-end> <vul-start> int t0 , t1 , t2 , t3 ; <vul-end> int x0 , x1 , x2 , x3 ; s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ; t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ; <vul-start> output [ 0 ] = fdct_round_shift ( t0 ) ; <vul-end> <vul-start> output [ 2 ] = fdct_round_shift ( t2 ) ; <vul-end> <vul-start> output [ 4 ] = fdct_round_shift ( t1 ) ; <vul-end> <vul-start> output [ 6 ] = fdct_round_shift ( t3 ) ; <vul-end> t0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> fdct8 ( const tran_low_t * input , tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0 , s1 <vul-start> , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <vul-end> x0 , x1 <vul-start> 0 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> ; t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <vul-end> fdct_round_shift ( t1 <vul-start> 1 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> fdct8 ( const tran_low_t <vul-end> * input, <vul-start> * input, tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0, s1 <vul-start>, s7 ; tran_high_t <vul-end> t0, t1 <vul-start> 0 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> ; t2 = ( tran_low_t ) <vul-start> ; t3 = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> ; t2 = ( tran_low_t ) <vul-start> ; t3 = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
  },
  {
    "id": 136,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( \"Failed to open statistics store\" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( \"Failed to open statistics store\" ) ; } <vul-start> stream -> config . cfg . g_pass = global -> passes == 2 <vul-end> ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; <vul-start> if ( pass ) <vul-end> stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; <vul-start> stream -> cx_time = 0 ; <vul-end> stream -> nbytes = 0 ; stream -> frames_out = 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) ; } # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( \"Failed to open mb statistics store\" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( \"Failed to open mb statistics store\" ) ; } # endif <vul-start> ( pass ) { <vul-start> stats ) ; # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } if ( pass ) { <vul-start> : VPX_RC_ONE_PASS ; <vul-end> stream -> config <vul-start> stats ) ; }\n"
  },
  {
    "id": 137,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct user_desc infobuf [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; <vul-start> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <vul-end> ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ; if ( kbuf ) info = kbuf ; else if ( __copy_from_user ( infobuf , ubuf , count ) ) return - EFAULT ; else info = infobuf ; <vul-start> set_tls_desc ( target , <vul-end> GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ; return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> * info ; int i ; <vul-start> = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if ( count < GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || ( count <vul-end> % sizeof ( <vul-start> = infobuf ; if (! tls_desc_okay ( info ) ) return - EINVAL ;\n"
  },
  {
    "id": 138,
    "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <vul-start> int strindex = 0 ; <vul-end> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , \"%%%02X\" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }",
    "golden_answers": [
      "CWE-89 Fixed Code Lines are: <vul-start> = alloc ; size_t <vul-end> strindex = 0\n"
    ],
    "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start> = alloc ; size_t <vul-end> strindex = 0\n"
  },
  {
    "id": 139,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <vul-end> <vul-start> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <vul-end> <vul-start> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <vul-end> if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ; <vul-start> vp9_initialize_dec ( ) ; <vul-end> vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; <vul-start> cm -> current_video_frame = 0 ; <vul-end> <vul-start> pbi -> oxcf = * oxcf ; <vul-end> pbi -> ready_for_new_data = 1 ; <vul-start> pbi -> decoded_key_frame = 0 ; <vul-end> <vul-start> vp9_init_dequantizer ( cm ) ; <vul-end> vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * vp9_decoder_create ( BufferPool * const pool <vul-end> ) { VP9Decoder <vul-start> { VP9Decoder * volatile <vul-start> ; VP9_COMMON * volatile <vul-start> = 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <vul-end> ( & cm <vul-start> ) ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <vul-start> ; pbi -> <vul-end> ready_for_new_data = 1 <vul-start> ; pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <vul-end> = 0 ; <vul-start> = 0 ; vpx_get_worker_interface ( ) -> init <vul-end> ( & pbi\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_decoder_create ( const VP9_COMMON * const cm, <vul-end> const VP9_CONFIG * <vul-start> const pbi = NULL ; if (! cm ) return NULL ; vp9_initialize_dec ( ) ; vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map, - 1, sizeof ( cm -> ref_frame_map ) ) ; pbi -> oxcf = * oxcf ; pbi -> ready_for_new_data = 1 ; pbi -> decoded_key_frame = 0 ; vp9_init_dequantizer ( cm ) ; vp9_loop_filter_init ( cm ) ; pbi -> lf_worker. init ( & pbi -> lf_worker ) ; if ( cm -> init_error. setjmp ) { cm -> error. setjmp = 0 ; cm -> remove ( pbi ) ; return NULL ; } pbi -> common. setjmp = 1 ; vp9_initialize_dec ( ) ; vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map, - 1, sizeof ( cm -> ref_frame_map ) ) ; cm -> current_video_frame = 0 ; pbi -> oxcf = * oxcf ; pbi -> ready_for_new_data = 1 ; pbi -> decoded_key_frame = 0 ; vp9_init_dequantizer ( cm ) ; vp9_loop_filter_init ( cm ) ; if ( cm -> init_error. setjmp ) { cm -> error. setjmp = 0 ; cm -> remove ( pbi ) ; return NULL ; } cm -> error. setjmp = 1 ; vp9_initialize_dec ( ) ; vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map, - 1, sizeof ( cm -> ref_frame_map ) ) ; cm -> ref_frame_map, - 1, sizeof ( cm -> ref_frame_map ) ) ; pbi -> current_video_frame = 0 ; pbi -> oxcf = * oxcf ; pbi -> ready_for_new_data = 1 ; pbi -> decoded_key_frame = 0 ; vp9_init_dequantizer ( cm ) ;"
  },
  {
    "id": 140,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , \"%s(%d): \" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <vul-start> \"Pushing input %d : %.30s\\\\n\" , ctxt -> inputNr + 1 , input -> cur ) ; <vul-end> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> ( xmlGenericErrorContext, \"Pushing input %d : %.30s\\\\n\" <vul-end>, ctxt -> <vul-start> input -> cur, xmlParserGetToken ( input )\n"
  },
  {
    "id": 141,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <vul-start> size_t <vul-end> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <vul-start> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <vul-end> <vul-start> value |= buffer [ 1 ] << 16 ; <vul-end> <vul-start> value |= buffer [ 2 ] << 8 ; <vul-end> <vul-start> value |= buffer [ 3 ] ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> 4 ] ; unsigned int <vul-end> value ; if <vul-start> value = ( unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 <vul-end> ; value |= <vul-start> ; value |= ( unsigned int ) <vul-start> ; value |= ( unsigned int ) <vul-start> ; value |= ( unsigned int ) <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 4 ] ; ssize_t <vul-end> value ; if <vul-start> c ; } value = <vul-end> ( buffer [ <vul-start> ] << 24 ) ; value |= ( size_t ) <vul-end> buffer [ 1 <vul-start> ] << 16 ; value |= ( size_t ) <vul-end> buffer [ 2 <vul-start> ] << 8 ; value |= ( size_t ) <vul-end> buffer [ 3 <vul-start>. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
  },
  {
    "id": 142,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( \"GsmXSMPClient: Setting up new connection\" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <vul-start> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <vul-end> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( \"GsmXSMPClient: New client \\'%s\\'\" , client -> priv -> description ) ; }",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> channel ) ; <vul-end> set_description ( client\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> = g_timeout_add_seconds ( 1 <vul-end>, ( GSourceFunc\n"
  },
  {
    "id": 143,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <vul-start> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <vul-end> return 1 ; <vul-start> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <vul-end> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <vul-start> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <vul-end> return 1 ; return 0 ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <vul-start> ; if ( <vul-end> inode -> i_flock <vul-start> F_RDLCK ) ) <vul-end> return 1 ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( nfs_page_flock_is_read_only ( page, inode ) ) return 0 ; if ( <vul-start>, inode ) ) return 1 ; if ( <vul-end> ( inode -> <vul-start>!= F_RDLCK ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_fd_owner ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode ) ) return 1 ; if ( nfs_link_is_dir ( inode )\n"
  },
  {
    "id": 144,
    "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <vul-start> for ( i = 0 ; i < name_len ; i ++ ) <vul-end> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <vul-start> int name_len ; <vul-end> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }",
    "golden_answers": [
      "CWE-834 Fixed Code Lines are: <vul-start> pb ) ; avio_skip ( pb , name_len <vul-end> ) ; for <vul-start> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA\n"
    ],
    "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> int64_t pres_time ; pres_time -= ( asf -> hdr. preroll * 10000 ) ; avio_rl64 ( pb ) ; pres_time -= ( asf -> hdr. preroll * 10000 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb, name_len * 2, name, sizeof ( name ) ) ) < name_len ) avio_skip ( pb, name_len - ret ) ; avpriv_new_chapter ( s, i, ( AVRational ) { 1, 10000000 }, pres_time, AV_NOPTS_VALUE, name ) ; } <vul-end> for ( i\n"
  },
  {
    "id": 145,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <vul-start> struct ext4_ext_path * path ) <vul-end> { <vul-start> struct ext4_extent * ex ; <vul-end> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <vul-start> ext_debug ( \"ext4_convert_unwritten_extents_endio: inode %lu, logical\" <vul-end> \"block %llu, max_blocks %u\\\\n\" , inode -> i_ino , <vul-start> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <vul-end> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> inode , struct ext4_map_blocks * map , struct <vul-start> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <vul-start> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <vul-start> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <vul-end> err = ext4_ext_get_access\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ext4_ext_path * path, struct ext4_area_struct * area <vul-start> ext4_extent * ex ; unsigned long long ee_block <vul-start>. p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; err = ext4_ext_get_access ( handle, inode, path + depth ) ; if ( err ) goto out ; err = ext4_ext_try_to_merge ( handle, inode, path, ex ) ; if ( err ) goto out ; <vul-start> -> i_ino, <vul-end> ee_block, ext4_ext_get_actual_len\n"
  },
  {
    "id": 146,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 <vul-start> int xmkstemp ( char * * tmpname , char * dir ) <vul-end> { char * localtmp ; <vul-start> char * tmpenv ; <vul-end> mode_t old_mode ; int fd , rc ; <vul-start> if ( dir != NULL ) <vul-end> <vul-start> tmpenv = dir ; <vul-end> else tmpenv = getenv ( \"TMPDIR\" ) ; <vul-start> if ( tmpenv ) <vul-end> rc = asprintf ( & localtmp , \"%s/%s.XXXXXX\" , tmpenv , <vul-start> program_invocation_short_name ) ; <vul-end> else rc = asprintf ( & localtmp , \"%s/%s.XXXXXX\" , _PATH_TMP , program_invocation_short_name ) ; if ( rc < 0 ) return - 1 ; old_mode = umask ( 077 ) ; fd = mkostemp ( localtmp , O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC ) ; umask ( old_mode ) ; if ( fd == - 1 ) { free ( localtmp ) ; localtmp = NULL ; } * tmpname = localtmp ; return fd ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> * tmpname , const <vul-start> char * dir , const char * prefix <vul-start> * localtmp ; const <vul-start> , rc ; <vul-end> tmpenv = dir <vul-start> tmpenv = dir ? dir : <vul-end> getenv ( \"TMPDIR\" <vul-start> ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <vul-end> rc = asprintf <vul-start> , tmpenv , prefix <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * tmpname, const <vul-start> * localtmp ; <vul-end> mode_t old_mode ; <vul-start>, rc ; <vul-end> tmpenv = getenv <vul-start> \"TMPDIR\" ) ; rc = safe_asprintf <vul-end> ( & localtmp <vul-start>, tmpenv, \"%s/.XXXXXX\", _PATH_TMP, program_invocation_short_name ) ; free ( localtmp <vul-end> ) ; if\n"
  },
  {
    "id": 147,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = hcd ; ci -> data_direction = IO_IN ;\n"
  },
  {
    "id": 148,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) { <vul-start> CLEANUP_FREE char * * lines = NULL ; <vul-end> int64_t size ; char * ret ; size = guestfs_filesize ( g , filename ) ; if ( size == - 1 ) return NULL ; if ( size > MAX_SMALL_FILE_SIZE ) { error ( g , _ ( \"size of %s is unreasonably large (%\" PRIi64 \" bytes)\" ) , filename , size ) ; return NULL ; } lines = guestfs_head_n ( g , 1 , filename ) ; if ( lines == NULL ) return NULL ; if ( lines [ 0 ] == NULL ) { guestfs___free_string_list ( lines ) ; return safe_strdup ( g , \"\" ) ; } ret = lines [ 0 ] ; <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> filename ) { <vul-end> char * * <vul-start> 0 ] ; free ( lines ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> filename ) { char * ret ; int64_t size ; char * * lines = NULL ; int i <vul-end> ; size = <vul-start> 0 ] ; for ( i = 0 ; i < lines [ 0 ] ; i ++ ) { if ( ret == NULL ) break ; }\n"
  },
  {
    "id": 149,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) && <vul-start> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <vul-end> return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> tp_event ) && perf_paranoid_tracepoint_raw <vul-end> ( ) &&\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( CAP_SYS_ADMIN ) ) return - EPERM ; if ( p_event -> attr. sample_type & PERF_SAMPLE_RAW\n"
  },
  {
    "id": 150,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <vul-start> case 'c' : return getnum ( L , fmt , 1 ) ; <vul-end> case 'i' : case 'I' : { <vul-start> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <vul-end> if ( sz > MAXINTSIZE ) luaL_error ( L , \"integral size %d is larger than limit of %d\" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> return getnum ( <vul-end> fmt , 1 <vul-start> = getnum ( <vul-end> fmt , sizeof\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> return getnum ( L, <vul-end> fmt, 1 <vul-start> = getnum ( L, <vul-end> fmt, sizeof\n"
  },
  {
    "id": 151,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <vul-start> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <vul-end> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NFC_ATTR_DEVICE_INDEX ] ) { kfree_skb ( skb ) ; return - EINVAL ; } <vul-end> device_idx = nla_get_u32\n"
  },
  {
    "id": 152,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { <vul-start> struct net * net = sock_net ( asoc -> base . sk ) ; <vul-end> int error = 0 ; <vul-start> bh_lock_sock ( asoc -> base . sk ) ; <vul-end> <vul-start> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <vul-end> pr_debug ( \"%s: sock is busy: timer %d\\\\n\" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) <vul-start> asoc -> base . sk -> sk_err = - error ; <vul-end> out_unlock : <vul-start> bh_unlock_sock ( asoc -> base . sk ) ; <vul-end> sctp_association_put ( asoc ) ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) { struct sock * sk = asoc -> base . sk ; struct <vul-start> = sock_net ( <vul-end> sk ) ; <vul-start> ; bh_lock_sock ( <vul-end> sk ) ; <vul-start> ( sock_owned_by_user ( <vul-end> sk ) ) <vul-start> ( error ) <vul-end> sk -> sk_err <vul-start> : bh_unlock_sock ( <vul-end> sk ) ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> -> base. sock -> <vul-start> -> base. sock -> <vul-start> -> base. sock -> <vul-start> -> base. sock -> <vul-start> -> base. sock ->\n"
  },
  {
    "id": 153,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_keyword ( PyObject * obj , keyword_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty value ; <vul-start> if ( exists_not_none ( obj , & PyId_arg ) ) { <vul-end> int res ; <vul-start> tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; <vul-end> if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_identifier ( tmp , & arg , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> arg = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from keyword\" ) ; return 1 ; } * out = keyword ( arg , value , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else <vul-end> { int res <vul-start> int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from keyword\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value <vul-end> , arena ) <vul-start> ) ; } <vul-end> * out =\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value ; arg = NULL ; <vul-start>, & PyId_arg, & tmp ) ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"arg\\\\\" missing from keyword\" ) ; return 1 ; } else <vul-end> { int res <vul-start> int res ; res = obj2ast_identifier ( tmp, & arg, arena ) ; if ( res!= 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( tmp == NULL ) { Py_CLEAR ( obj ) ; arg = NULL ; } else { int res ; <vul-start> tmp, & <vul-end> arg, arena <vul-start> ) ; } <vul-end> * out =\n"
  },
  {
    "id": 154,
    "question": "CWE-191 Code Input Vulnerable Code Is: CWE-191 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = \"`\\\\\"\\\\\\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \\'\"\\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <vul-start> dlen -= 2 ; <vul-end> if ( dlen == 0 ) break ; * pt ++ = '\\\\\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \\'\"\\' ; * pt = '\\\\0' ; }",
    "golden_answers": [
      "CWE-191 Fixed Code Lines are: <vul-start> ) ) { if ( dlen < 2 ) break ; <vul-start> dlen -= 2 <vul-end> ; * pt\n"
    ],
    "generated_answer": "CWE-191 Fixed Code Lines are: <vul-start> ) ) { if ( dlen < 2 ) break ;\n"
  },
  {
    "id": 155,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , \"Unable to create %snotify fifo %s\" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <vul-start> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <vul-end> log_message ( LOG_INFO , \"Unable to open %snotify fifo %s - errno %d\" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> -> fd = TEMP_FAILURE_RETRY ( <vul-start> | O_CLOEXEC | O_NOFOLLOW ) <vul-end> ) ) ==\n"
  },
  {
    "id": 156,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <vul-start> offset = tbl -> indent ; <vul-end> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <vul-start> } <vul-end> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <vul-start> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> INDENT_INCR ; } if ( mode -> indent_level == 0 && ( mode -> indent_level >= MAX_INDENT_LEVEL ) ) { mode -> indent_level = 0 ; offset = INDENT_INCR ; } <vul-start> -= INDENT_INCR ; if ( offset < 0 ) { check_minimum0 ( tbl, 0 ) ; addcontentssize ( tbl, offset ) ; }\n"
  },
  {
    "id": 157,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <vul-start> default : <vul-end> errno = EINVAL ; return - 1 ; } }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_NO_COMPLIANT : ms -> elf_no_comp = * ( const size_t * ) val ; return 0 ;\n"
  },
  {
    "id": 158,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void nodeConstruct ( struct SaveNode * node , tr_variant const * v , bool sort_dicts ) { node -> isVisited = false ; node -> childIndex = 0 ; if ( sort_dicts && tr_variantIsDict ( v ) ) { size_t const n = v -> val . l . count ; struct KeyIndex * tmp = tr_new ( struct KeyIndex , n ) ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp [ i ] . val = v -> val . l . vals + i ; tmp [ i ] . keystr = tr_quark_get_string ( tmp [ i ] . val -> key , NULL ) ; } qsort ( tmp , n , sizeof ( struct KeyIndex ) , compareKeyIndex ) ; <vul-start> tr_variantInitDict ( & node -> sorted , n ) ; <vul-end> for ( size_t i = 0 ; i < n ; ++ i ) { <vul-start> node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ; <vul-end> } <vul-start> node -> sorted . val . l . count = n ; <vul-end> tr_free ( tmp ) ; <vul-start> node -> v = & node -> sorted ; <vul-end> } else { <vul-start> node -> v = v ; <vul-end> } }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> compareKeyIndex ) ; node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict ( <vul-end> node -> sorted <vul-start> node -> sorted -> <vul-end> val . l <vul-start> node -> sorted -> <vul-end> val . l <vul-start> tmp ) ; v = <vul-end> node -> sorted <vul-start> { node -> sorted = NULL ; } node -> v = v ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> compareKeyIndex ) ; if ( node -> sorted!= NULL ) { <vul-start> n ) ; } <vul-start> i ) { tmp [ i ]. val = * tmp [ i ]. val ; } <vul-start> node -> sorted = & node -> sorted ; } else { node -> v = v ; } } else { node -> v = v ; } if ( node -> sorted!= NULL ) { <vul-start> val ; } <vul-end> tr_free ( tmp <vul-start> node -> sorted = NULL <vul-end> ; } else <vul-start> } else { <vul-end> } }  \n"
  },
  {
    "id": 159,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <vul-start> init_thread : <vul-end> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , \"f2fs_flush-%u:%u\" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> = fcc ; SM_I ( sbi ) -> fcc_cache = kzalloc ( sizeof ( struct f2fs_cache ), GFP_KERNEL ) ; if (! fcc -> fcc_cache ) return - ENOMEM ;\n"
  },
  {
    "id": 160,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <vul-start> bool valid_handle ; <vul-end> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <vul-start> valid_handle = ion_handle_validate ( client , handle ) ; <vul-end> if ( ! valid_handle ) { WARN ( 1 , \"%s: invalid handle passed to free.\\\\n\" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <vul-start> return ; <vul-end> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> handle ) { <vul-end> BUG_ON ( client <vul-start> lock ) ; ion_free_nolock <vul-end> ( client , <vul-start> client , handle <vul-end> ) ; mutex_unlock <vul-start> lock ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> handle ) { <vul-end> BUG_ON ( client <vul-start> lock ) ; ion_free_nolock ( client, handle <vul-end> ) ; mutex_unlock <vul-start> ) ; return <vul-end> ; } mutex_unlock\n"
  },
  {
    "id": 161,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ; <vul-start> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <vul-end> r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <vul-end> object -> list\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>. length!= 1U << 20 <vul-end> ||! object <vul-start> 0 ] ||! <vul-start>. length!= 2U << 20 <vul-end> ) { r_asn1_free_object\n"
  },
  {
    "id": 162,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> return NULL ; <vul-end> i = 0 <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD\n"
  },
  {
    "id": 163,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <vul-start> else umount_tree ( mnt , 0 ) ; <vul-end> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ( mnt , UMOUNT_CONNECTED <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> } } else { struct mount * p, * tmp ; list_for_each_entry_safe ( p, tmp, & mnt -> mnt_umount. s_list, mnt_child ) { hlist_add_head ( & p -> mnt_umount. s_list, & unmounted ) ; umount_mnt ( p ) ; } } <vul-end> } unlock_mount_hash (\n"
  },
  {
    "id": 164,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , \"IAC IAC\" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , \"%s %s\" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , \"%s %#x\" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p +",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ++ ; } ND_TCHECK ( * p ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( p >= sp ||\n"
  },
  {
    "id": 165,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , \"%d\" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"12345\" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , \"DEADBEEF\" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , \"%d\" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"12345\" ) == 0 ) ; ASSERT ( length == 5 ) ; <vul-start> if ( size < 6 ) <vul-end> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & \"DEADBEEF\" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( size < 5 + 1 <vul-end> ) ASSERT ( <vul-start> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , \"DEADBEEF\" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , \"%2.0f\" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208\" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & \"DEADBEEF\" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> < 6 ) { <vul-start> ; } } }\n"
  },
  {
    "id": 166,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , \"entering CDROM_SELECT_DISC\\\\n\" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <vul-start> if ( ( int ) arg >= cdi -> capacity ) <vul-end> return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , \"Using generic cdrom_select_disc()\\\\n\" ) ; return cdrom_select_disc ( cdi , arg ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> { if ( <vul-end> arg >= cdi\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> { if ( arg < cdi -> capacity || <vul-start> int ) arg > <vul-end> cdi -> capacity\n"
  },
  {
    "id": 167,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static PyTypeObject * make_type ( char * type , PyTypeObject * base , char * * fields , int num_fields ) <vul-start> { <vul-end> PyObject * fnames , * result ; int i ; fnames = PyTuple_New ( num_fields ) ; if ( ! fnames ) return NULL ; for ( i = 0 ; i < num_fields ; i ++ ) { PyObject * field = PyUnicode_FromString ( fields [ i ] ) ; if ( ! field ) { Py_DECREF ( fnames ) ; return NULL ; } PyTuple_SET_ITEM ( fnames , i , field ) ; } <vul-start> result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , \"s(O){sOss}\" , <vul-end> <vul-start> type , base , \"_fields\" , fnames , \"__module__\" , \"_ast3\" ) ; <vul-end> Py_DECREF ( fnames ) ; return ( PyTypeObject * ) result ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> num_fields ) { _Py_IDENTIFIER ( __module__ ) ; _Py_IDENTIFIER ( _ast3 ) ; <vul-start> & PyType_Type , \"s(O){OOOO}\" <vul-end> , type , <vul-start> , base , _PyUnicode_FromId ( & PyId__fields ) <vul-end> , fnames , <vul-start> , fnames , _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 ) <vul-end> ) ; Py_DECREF\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> num_fields ) { PyObject * result ; <vul-start> ) ; } # ifdef Py_DEBUG <vul-start> \"_ast3\" ) ; # endif\n"
  },
  {
    "id": 168,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; <vul-start> count = be32_to_cpu ( aclp -> acl_cnt ) ; <vul-end> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>, i ; if (! aclp -> acl_entry ) return ERR_PTR ( - EINVAL ) ;\n"
  },
  {
    "id": 169,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <vul-start> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <vul-end> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , len , UTF16_HOST_ENDIAN , <vul-start> * ) outname , FAT_LFN_LEN + 2\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * outlen = utf8s_to_utf32s <vul-end> ( name,\n"
  },
  {
    "id": 170,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <vul-start> else if ( rc == - ENODATA ) <vul-end> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <vul-start> return rc ; <vul-end> }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> == - ENODATA && inode -> i_op -> removexattr ) { <vul-end> rc = inode <vul-start> XATTR_NAME_EVM ) ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> - ENODATA ) { xattr_data. type = EVM_XATTR_NOEXEC ; <vul-start> XATTR_NAME_EVM ) ; }\n"
  },
  {
    "id": 171,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static inline int mount_entry_on_generic ( struct mntent * mntent , <vul-start> const char * path ) <vul-end> { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , \"optional\" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , <vul-start> mntflags , mntdata , optional ) ; <vul-end> free ( mntdata ) ; return ret ; }",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> char * path , const char * rootfs <vul-start> mntdata , optional , rootfs\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> char * path, uid_t * check_ruid <vul-start> mntdata, optional, check_ruid\n"
  },
  {
    "id": 172,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int tile_worker_hook ( void * arg1 , void * arg2 ) { <vul-end> <vul-start> TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ; <vul-end> <vul-start> const TileInfo * const tile = ( TileInfo * ) arg2 ; <vul-end> <vul-start> int mi_row , mi_col ; <vul-end> for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { <vul-start> decode_partition ( tile_data -> cm , & tile_data -> xd , tile , <vul-end> <vul-start> mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ; <vul-end> } } return ! tile_data -> xd . corrupted ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int tile_worker_hook ( <vul-end> TileWorkerData * const <vul-start> * const tile_data , <vul-end> const TileInfo * <vul-start> * const tile ) { <vul-end> int mi_row , <vul-start> mi_row , mi_col ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info <vul-start> ( tile_data -> pbi <vul-end> , & tile_data <vul-start> tile_data -> xd <vul-end> , mi_row , <vul-start> bit_reader , BLOCK_64X64 , 4\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int tile_worker_hook ( TileWorkerData * const tile_data, TileInfo * const tile, <vul-start> arg2 ) { TileWorkerData_t <vul-end> * const tile_data <vul-start> = ( TileWorkerData * ) tile_data ; TileInfo_t <vul-end> * const tile <vul-start> = ( TileInfo * ) tile <vul-end> ; int mi_row <vul-start> mi_row, mi_col ; decode_partition_init ( tile_data ) <vul-start> { decode_partition ( tile <vul-end>, & tile_data <vul-start> bit_reader, BLOCK_64X64, tile_data -> xd. left_context, tile_data -> xd. left_seg_context\n"
  },
  {
    "id": 173,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int nfs4_xdr_dec_getacl ( struct rpc_rqst * rqstp , struct xdr_stream * xdr , struct nfs_getaclres * res ) { struct compound_hdr hdr ; int status ; status = decode_compound_hdr ( xdr , & hdr ) ; if ( status ) goto out ; status = decode_sequence ( xdr , & res -> seq_res , rqstp ) ; if ( status ) goto out ; status = decode_putfh ( xdr ) ; if ( status ) goto out ; <vul-start> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <vul-end> out : return status ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> , rqstp , res <vul-end> ) ; out\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> goto out ; if ( <vul-end> decode_getacl ( xdr <vul-start> res -> acl_len, & res -> acl_len ) ) goto out ; status = decode_getacl ( xdr, rqstp, & res -> acl_len\n"
  },
  {
    "id": 174,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) <vul-start> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <vul-end> <vul-start> { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = x ; <vul-end> <vul-start> } ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header . ptr [ <vul-end> psf -> header <vul-start> psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> x ; } <vul-end>      \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header. ptr [ <vul-end> psf -> header <vul-start> psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> x ; } <vul-end>      \n"
  },
  {
    "id": 175,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <vul-end> <vul-start> double this_frame_mv_in_out ) { <vul-end> double frame_boost ; <vul-start> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <vul-end> <vul-start> frame_boost = ( IIFACTOR * this_frame -> intra_error / <vul-end> <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <vul-end> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <vul-start> return MIN ( frame_boost , GF_RMAX ) ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , const <vul-start> , double this_frame_mv_in_out , double max_boost <vul-start> double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <vul-end> frame_boost = ( <vul-start> frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) <vul-end> / DOUBLE_DIVIDE_CHECK ( <vul-start> -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <vul-end> ; if ( <vul-start> ( frame_boost , max_boost * boost_q_correction <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, VP9_COMP * cpi_o, <vul-start>, double this_frame_mv_in_out, double this_frame_boost_intra <vul-start> ; if ( this_frame_boost_intra <vul-end> > cpi -> <vul-start> twopass. gf_intra_err_min && cpi_o -> oxcf. gf_intra_err_max > cpi_o -> oxcf. gf_intra_err_min ) { <vul-end> frame_boost = ( <vul-start> ( IIFACTOR * cpi_o <vul-end> -> intra_error / <vul-start> -> coded_error ) ) ; } else { frame_boost = ( IIFACTOR * cpi_o -> twopass. gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; } <vul-end> if ( this_frame_mv_in_out <vul-start> ( frame_boost, GF_RMAX_NO_BOOST <vul-end> ) ; }\n"
  },
  {
    "id": 176,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ; <vul-start> else if ( i > pos && i + insn -> off + 1 < pos ) <vul-end> insn -> off -= delta ; } }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> i > pos + delta <vul-start> off + 1 <= pos + delta <vul-end> ) insn ->\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> if ( i >= <vul-end> pos && i <vul-start> insn -> off <vul-end> < pos )\n"
  },
  {
    "id": 177,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void nw_cache_free ( nw_cache * cache , void * obj ) { if ( cache -> free < cache -> free_total ) { cache -> free_arr [ cache -> free ++ ] = obj ; <vul-start> } else { <vul-end> uint32_t new_free_total = cache -> free_total * 2 ; void * new_arr = realloc ( cache -> free_arr , new_free_total * sizeof ( void * ) ) ; if ( new_arr ) { cache -> free_total = new_free_total ; cache -> free_arr = new_arr ; cache -> free_arr [ cache -> free ++ ] = obj ; } else { free ( obj ) ; } <vul-start> } <vul-end> }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; } else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <vul-start> ; } } else { free ( obj ) ; }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = obj ; return ; <vul-start> ) ; } return ;\n"
  },
  {
    "id": 178,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <vul-start> xen_netbk_idx_release ( netbk , pending_idx ) ; <vul-end> } }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> netbk , pending_idx , XEN_NETIF_RSP_OKAY\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> netbk, pending_idx, XEN_NETIF_RSP_OKAY\n"
  },
  {
    "id": 179,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <vul-end> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <vul-start> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <vul-end> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <vul-start> update_open_stateflags ( state , open_flags ) ; <vul-end> spin_unlock ( & state -> owner -> so_lock ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> * deleg_stateid , fmode_t fmode <vul-end> ) { write_seqlock <vul-start> , open_stateid , fmode <vul-end> ) ; write_sequnlock <vul-start> ( state , fmode <vul-end> ) ; spin_unlock\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * deleg_stateid, fmode_t fmode <vul-end> ) { write_seqlock <vul-start>, open_stateid, fmode <vul-end> ) ; write_sequnlock <vul-start> ( state, fmode <vul-end> ) ; spin_unlock\n"
  },
  {
    "id": 180,
    "question": "CWE-436 Code Input Vulnerable Code Is: CWE-436 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; <vul-start> g_clear_object ( & client -> proxy ) ; <vul-end> g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }",
    "golden_answers": [
      "CWE-436 Fixed Code Lines are: <vul-start> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE\n"
    ],
    "generated_answer": "CWE-436 Fixed Code Lines are: <vul-start> client ) ; g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; g_clear_object ( & client -> proxy ) ; <vul-start> client -> proxy <vul-end> ) ; free_side\n"
  },
  {
    "id": 181,
    "question": "CWE-755 Code Input Vulnerable Code Is: CWE-755 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <vul-start> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <vul-end> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <vul-start> ACPI_OPERAND_OBJECT * Next ; <vul-end> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <vul-start> } <vul-end> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , \"Namespace freed\\\\n\" ) ) ; return_VOID ; }",
    "golden_answers": [
      "CWE-755 Fixed Code Lines are: <vul-start> ACPI_STATUS Status ; <vul-end> ACPI_OPERAND_OBJECT * Prev <vul-start> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <vul-start> ) ; } <vul-end> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode\n"
    ],
    "generated_answer": "CWE-755 Fixed Code Lines are: <vul-start> ACPI_STATUS Status ; <vul-end> ACPI_OPERAND_OBJECT * Prev <vul-start> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <vul-start> ) ; } <vul-end> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode\n"
  },
  {
    "id": 182,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  },
  {
    "id": 183,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const char * <vul-start> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <vul-end> { const char * s ; <vul-start> if ( * len <= 0 || ! pptr || ! * pptr ) <vul-end> return NULL ; if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ; s = * pptr ; <vul-start> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <vul-end> ( * pptr ) ++ ; ( * len ) -- ; } ( * pptr ) ++ ; ( * len ) -- ; <vul-start> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <vul-end> return NULL ; return s ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> int * len , int * truncated <vul-start> * s ; <vul-end> s = * <vul-start> * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <vul-end> * * pptr <vul-start> * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\\\0' ) { break ; } <vul-end> ( * pptr <vul-start> ) -- ; <vul-end> return s ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int * len, int plen <vul-start> ; if ( plen <vul-end> <= 0 || <vul-start> ||! * pptr || plen == 0 || * pptr > plen <vul-end> ) return NULL <vul-start> * pptr <= plen <vul-end> && * len <vul-start> ; if ( plen <vul-end> < 0 ||\n"
  },
  {
    "id": 184,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void xenvif_disconnect ( struct xenvif * vif ) { <vul-start> struct net_device * dev = vif -> dev ; <vul-end> <vul-start> if ( netif_carrier_ok ( dev ) ) { <vul-end> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <vul-start> xenvif_down ( vif ) ; <vul-end> <vul-start> rtnl_unlock ( ) ; <vul-end> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> vif ) { <vul-end> if ( netif_carrier_ok <vul-start> ( netif_carrier_ok ( vif -> <vul-end> dev ) ) <vul-start> dev ) ) xenvif_carrier_off <vul-end> ( vif ) <vul-start> vif ) ; <vul-end> atomic_dec ( &\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> vif ) { rtnl_lock ( ) ; if (! netif_carrier_ok ( vif -> dev ) ) goto out ; <vul-start> ; if ( <vul-end> netif_running ( dev <vul-start> dev ) ) { <vul-start> vif ) ; } else { rtnl_unlock ( ) ; xenvif_put ( vif ) ; } out : <vul-end> rtnl_unlock ( )\n"
  },
  {
    "id": 185,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( \"[FD %i] Mandril validating URL\" , cs -> socket ) ; <vul-start> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <vul-end> PLUGIN_TRACE ( \"[FD %i] Close connection, blocked URL\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( \"[FD %d] Mandril validating hotlinking\" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , \"Referer\" , strlen ( \"Referer\" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( \"[FD %i] Close connection, deny hotlinking.\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ( sr -> uri_processed <vul-end> ) < 0\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( sr -> host, sr ->\n"
  },
  {
    "id": 186,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) { <vul-start> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <vul-end> if ( ret < 0 ) { ERROR ( \"ack failed (%s)\" , strerror ( errno ) ) ; if ( errno == EINTR ) { <vul-start> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <vul-end> if ( ret < 0 ) { ERROR ( \"ack failed (%s)\" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> length , MSG_NOSIGNAL ) <vul-start> { ret = TEMP_FAILURE_RETRY ( <vul-start> length , MSG_NOSIGNAL )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> length, MSG_NOSIGNAL ) <vul-start> { ret = TEMP_FAILURE_RETRY ( <vul-start> length, MSG_NOSIGNAL )\n"
  },
  {
    "id": 187,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , \"Failed to create ICMP6 socket.\" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , \"Failed to setsockopt IPV6_RECVPKTINFO.\" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <vul-start> err ( ndp , \"Failed to setsockopt IPV6_MULTICAST_HOPS.\" ) ; <vul-end> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ndp , \"Failed to setsockopt IPV6_MULTICAST_HOPS.\" ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\"\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ( ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS\" <vul-end> ) ; err\n"
  },
  {
    "id": 188,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void BezierOval ( double w , double h , char * action ) <vul-start> { <vul-end> outpos += sprintf ( outpos , \" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\\\n\" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\\\n\" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\\\n\" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\\\n\" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> action ) { char * outpos = outputbuffer ; <vul-start> action ) ; sendClean ( outputbuffer ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> action ) { char * outpos = outputbuffer ; <vul-start> action ) ; sendClean ( outputbuffer ) ;\n"
  },
  {
    "id": 189,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <vul-start> int i ; <vul-end> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , \"max_devices=\" , 12 ) == 0 ) sscanf ( argv [ i ] , \"max_devices=%u\" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , \"manual\" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , \"debug\" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , \"nouserok\" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , \"openasuser\" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , \"alwaysok\" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , \"interactive\" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , \"cue\" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , \"nodetect\" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , \"authfile=\" , 9 ) == 0 )",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <vul-start> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <vul-end> , & st <vul-start> == 0 ) && <vul-end> S_ISREG ( st <vul-start> { file = fdopen ( fd <vul-end> , \"a\" ) <vul-start> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <vul-end> } } } <vul-start> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> cfg ) { <vul-end> FILE * file <vul-start> * file ; char * filename_copy ; <vul-start> ) ) { filename_copy = strdup ( argv [ i ] ) ; <vul-start> = file ; if ( filename_copy == NULL ) { fprintf ( stderr, \"Unable to allocate memory for file\\\\n\" ) ; exit ( 1 ) ; } free ( filename_copy ) ;\n"
  },
  {
    "id": 190,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t get altsetting\\\\n\" ) ; return - EIO ; } <vul-start> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <vul-end> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , \"Starting stream failed\\\\n\" ) ; else gspca_dbg ( gspca_dev , D_STREAM , \"Started streaming\\\\n\" ) ; return ( err < 0 ) ? err : 0 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> EIO ; } if ( alt -> desc. bNumEndpoints < 1 ) { sd -> sensor -> start ( sd ) ; return - ENODEV ; }\n"
  },
  {
    "id": 191,
    "question": "CWE-320 Code Input Vulnerable Code Is: CWE-320 int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <vul-start> int r ; <vul-end> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <vul-start> for ( ; ; ) { <vul-end> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }",
    "golden_answers": [
      "CWE-320 Fixed Code Lines are: <vul-start> ; int r , dontmax = 0 <vul-start> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;\n"
    ],
    "generated_answer": "CWE-320 Fixed Code Lines are: <vul-start> ; int r ; int i <vul-start> return SSH_ERR_INVALID_FORMAT ; i = 0 ; <vul-start> ; ) { if ( i == MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; }\n"
  },
  {
    "id": 192,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <vul-start> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <vul-end> remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> -> it_overrun += <vul-end> kc -> timer_forward\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> sig_none ) ) { if (! sig_none ) <vul-start> now ) ; }\n"
  },
  {
    "id": 193,
    "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <vul-start> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <vul-end> { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <vul-start> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <vul-end> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }",
    "golden_answers": [
      "CWE-254 Fixed Code Lines are: <vul-start> ; while ( ( <vul-start> u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <vul-start> ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )\n"
    ],
    "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> ; while ( ( <vul-start> u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) <vul-start> ; while ( ( <vul-start> )!= START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )\n"
  },
  {
    "id": 194,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void copy_to_user_state ( struct xfrm_state * x , struct xfrm_usersa_info * p ) { <vul-start> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <vul-end> memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & x -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & x -> curlft , sizeof ( p -> curlft ) ) ; memcpy ( & p -> stats , & x -> stats , sizeof ( p -> stats ) ) ; memcpy ( & p -> saddr , & x -> props . saddr , sizeof ( p -> saddr ) ) ; p -> mode = x -> props . mode ; p -> replay_window = x -> props . replay_window ; p -> reqid = x -> props . reqid ; p -> family = x -> props . family ; p -> flags = x -> props . flags ; p -> seq = x -> km . seq ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> p ) { memset ( p , 0 , sizeof ( * p ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> p ) { memset ( p, 0, sizeof ( * p ) ) ;\n"
  },
  {
    "id": 195,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <vul-end> <vul-start> FRAME_CONTEXT * const fc = & cm -> fc ; <vul-end> int i ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_inter_prob [ i ] ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) { vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 0 ] ) ; vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 1 ] ) ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_ref_prob [ i ] ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cm , vpx_reader <vul-end> * r ) <vul-start> const fc = <vul-end> cm -> fc\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cm, vpx_reader <vul-end> * r ) <vul-start> cm -> fc ; FRAME_CONTEXT * const fc2 = cm -> fc ; int i ; if ( fc2 -> num_temporal_layers > MAX_REF_LAYOUTS ) return\n"
  },
  {
    "id": 196,
    "question": "CWE-347 Code Input Vulnerable Code Is: CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return \"2\" \"exponentiation failed; too many octets\" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( \"verify_sh decrypted SIG1:\" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( \"pad_len calculated: %d hash_len: %d\" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return \"3\" \"SIG padding does not check out\" ; } <vul-start> s += padlen + 3 ; <vul-end> <vul-start> ( * psig ) = s ; <vul-end> return NULL ; }",
    "golden_answers": [
      "CWE-347 Fixed Code Lines are: <vul-start> \"SIG padding does not check out\" ; } ( * psig ) = s + <vul-end> padlen + 3 <vul-start> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return \"4\" \"invalid Padding String\" ; } <vul-end> return NULL ;\n"
    ],
    "generated_answer": "CWE-347 Fixed Code Lines are: <vul-start> \"SIG padding does not check out\" ; } if ( s + padlen + 3 < s_max_octets ) { return \"3\" \"SIG padding too many octets\" ; } <vul-start> + 3 ; * psig = s ;\n"
  },
  {
    "id": 197,
    "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 static void start_auth_request ( PgSocket * client , const char * username ) { int res ; PktBuf * buf ; <vul-start> client -> auth_user = client -> db -> auth_user ; <vul-end> client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ; if ( ! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client , \"Doing auth_conn query\" ) ; client -> wait_for_user_conn = false ; client -> wait_for_user = true ; if ( ! sbuf_pause ( & client -> sbuf ) ) { release_server ( client -> link ) ; disconnect_client ( client , true , \"pause failed\" ) ; return ; } client -> link -> ready = 0 ; res = 0 ; buf = pktbuf_dynamic ( 512 ) ; if ( buf ) { pktbuf_write_ExtQuery ( buf , cf_auth_query , 1 , username ) ; res = pktbuf_send_immediate ( buf , client -> link ) ; pktbuf_free ( buf ) ; } if ( ! res ) disconnect_server ( client -> link , false , \"unable to send login query\" ) ; }",
    "golden_answers": [
      "CWE-287 Fixed Code Lines are: <vul-start> ; client -> <vul-end> pool = get_pool\n"
    ],
    "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> * buf ; if ( client -> auth_user == NULL ) { slog_noise ( client, \"No user to login\" ) ; disconnect_client ( client, true, \"no user to login\" ) ; return ; }\n"
  },
  {
    "id": 198,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static inline signed int ReadPropertySignedLong ( const EndianType endian , const unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned int value ; if ( endian == LSBEndian ) { <vul-start> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <vul-end> <vul-start> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; } <vul-start> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <vul-end> <vul-start> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> unsigned int ) <vul-end> buffer [ 3 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 0 <vul-start> [ 0 ] <vul-end> ; quantum . <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return ( <vul-start> unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 3 <vul-start> [ 3 ] <vul-end> ; quantum . <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> unsigned int ) <vul-end> buffer [ 3 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 0 <vul-start> [ 0 ] <vul-end> ; quantum. <vul-start>. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return ( <vul-start> unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 3 <vul-start> [ 3 ] <vul-end> ; quantum. <vul-start>. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
  },
  {
    "id": 199,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <vul-start> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <vul-end> if ( ! tmp ) <vul-start> return ; <vul-end> while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpAcc ( TIFF <vul-start> cc ) ; if <vul-end> ( cc % <vul-start> * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpAcc\" , \"%s\" , \"cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if ( ! <vul-start> tmp ) return 0 <vul-start> tmp ) ; return 1 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpAcc ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"fpAcc\", \"%s\", \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if (! <vul-start> tmp ) return 0 <vul-start> tmp ) ; return 1 ;\n"
  },
  {
    "id": 200,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_frame ( vpx_codec_ctx_t * codec , <vul-end> vpx_image_t * img , int frame_index , <vul-start> VpxVideoWriter * writer ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , \"Failed to encode frame\" ) ; <vul-start> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <vul-end> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , \"Failed to write compressed frame\" ) ; } printf ( keyframe ? \"K\" : \".\" ) ; fflush ( stdout ) ; } } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
  },
  {
    "id": 201,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <vul-start> char fstr [ MAXDATELEN + 1 ] ; <vul-end> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , \"000000\" ) ; * ( fstr + 6 ) = '\\\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\\\0' ? * cp ++ : '0' ; fstr [ i ] <vul-end> = '\\\\0' ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char fstr [ 7 ] ; cp ++ ; fstr [ 6 ] = * cp!= '\\\\0'? * cp ++ : '0' ; fstr [ 7 ] = * cp!= '\\\\0'? * cp ++ : '0' ; fstr [ 6 ] = * cp!= '\\\\0'? * cp ++ : '0' ; fstr [ 6 ] <vul-end> = '\\\\0' ;\n"
  },
  {
    "id": 202,
    "question": "CWE-88 Code Input Vulnerable Code Is: CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , \"submodule\" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , \"disallowed submodule name: %s\" , name ) ; if ( ! strcmp ( key , \"url\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , \"disallowed submodule url: %s\" , value ) ; <vul-start> free ( name ) ; <vul-end> return 0 ; }",
    "golden_answers": [
      "CWE-88 Fixed Code Lines are: <vul-start> value ) ; if ( ! strcmp ( key , \"path\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , \"disallowed submodule path: %s\" , value ) ;\n"
    ],
    "generated_answer": "CWE-88 Fixed Code Lines are: <vul-start> value ) ; if (! strcmp ( key, \"url_whitelist\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options, data -> obj, FSCK_MSG_GITMODULES_URL, \"disallowed submodule url: %s\", value ) ;\n"
  },
  {
    "id": 203,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct ucma_multicast * ucma_alloc_multicast ( struct ucma_context * ctx ) { struct ucma_multicast * mc ; mc = kzalloc ( sizeof ( * mc ) , GFP_KERNEL ) ; if ( ! mc ) return NULL ; mutex_lock ( & mut ) ; <vul-start> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <vul-end> mutex_unlock ( & mut ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list , & ctx -> mc_list ) ; return mc ; error : kfree ( mc ) ; return NULL ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> & multicast_idr , NULL <vul-end> , 0 ,\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> id = idr_alloc0 ( & multicast_idr, mc, 0, 0, GFP_KERNEL ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list, & ctx -> mc_list ) ; mc -> id =\n"
  },
  {
    "id": 204,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <vul-start> WLog_VRB ( AUTODETECT_TAG , \"received Bandwidth Measure Results PDU\" ) ; <vul-end> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , \"received Bandwidth Measure Results PDU\" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, \"received Bandwidth Measure Results PDU\" ) ; if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE\n"
  },
  {
    "id": 205,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <vul-start> if ( calldata -> arg . open_flags == 0 ) <vul-end> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> == 0 )\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> : if (! calldata -> arg. open_flags ) break ; if (\n"
  },
  {
    "id": 206,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp , <vul-end> const unsigned int ct [ 2 ] ) { <vul-start> const vp9_prob upd = DIFF_UPDATE_PROB ; <vul-end> <vul-start> vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ; <vul-end> const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ; assert ( newp >= 1 ) ; if ( savings > 0 ) { <vul-start> vp9_write ( w , 1 , upd ) ; <vul-end> vp9_write_prob_diff_update ( w , newp , * oldp ) ; * oldp = newp ; } else { <vul-start> vp9_write ( w , 0 , upd ) ; <vul-end> } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> void vp9_cond_prob_diff_update ( vpx_writer <vul-end> * w , <vul-start> * w , vpx_prob <vul-end> * oldp , <vul-start> ) { const vpx_prob <vul-end> upd = DIFF_UPDATE_PROB <vul-start> = DIFF_UPDATE_PROB ; vpx_prob <vul-end> newp = get_binary_prob <vul-start> 0 ) { vpx_write <vul-end> ( w , <vul-start> } else { vpx_write <vul-end> ( w ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void vp9_cond_prob_diff_update ( vpx_writer <vul-end> * w, <vul-start> * w, vpx_prob <vul-end> * oldp, <vul-start> ) { const vpx_prob <vul-end> upd = DIFF_UPDATE_PROB <vul-start> = DIFF_UPDATE_PROB ; vpx_prob <vul-end> newp = get_binary_prob <vul-start> 0 ) { vpx_write <vul-end> ( w, <vul-start> } else { vpx_write <vul-end> ( w,\n"
  },
  {
    "id": 207,
    "question": "CWE-326 Code Input Vulnerable Code Is: CWE-326 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <vul-start> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <vul-end> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <vul-start> net_get_random_once ( & ip6_proxy_idents_hashrnd , <vul-end> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <vul-start> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <vul-end> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }",
    "golden_answers": [
      "CWE-326 Fixed Code Lines are: <vul-start> skb ) { <vul-end> struct in6_addr buf <vul-start> return 0 ; <vul-end> id = __ipv6_select_ident <vul-start> ( net , <vul-end> & addrs [\n"
    ],
    "generated_answer": "CWE-326 Fixed Code Lines are: <vul-start> skb ) { u32 id <vul-end> ; struct in6_addr <vul-start> return 0 ; spin_get_random ( & ip6_proxy_idents_hashrnd_epoch <vul-end>, sizeof ( <vul-start> __ipv6_select_ident ( net <vul-end>, & addrs\n"
  },
  {
    "id": 208,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <vul-start> # undef _ <vul-end> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = \"<unknown variable>\" ; break ; } break ; } return str ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NPPVformValue ) ; _ ( NPPVpluginNoArg ) ;\n"
  },
  {
    "id": 209,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; <vul-start> # line 496 \"ext/standard/var_unserializer.c\" <vul-end> { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; # line 501 <vul-end> \"ext/standard/var_unserializer.c\" { YYCTYPE <vul-start> : # line 875 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 563 <vul-end> \"ext/standard/var_unserializer.c\" yy4 : <vul-start> ; # line 869 <vul-end> \"ext/standard/var_unserializer.re\" { php_error_docref <vul-start> } # line 612 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 717 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <vul-start> } # line 795 <vul-end> \"ext/standard/var_unserializer.c\" yy25 : <vul-start> ; # line 704 \"ext/standard/var_unserializer.re\" { long elements ; <vul-end> if ( ! <vul-start> rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <vul-start> ( UNSERIALIZE_PASSTHRU , elements <vul-end> ) ; } <vul-start> } # line 833 <vul-end> \"ext/standard/var_unserializer.c\" yy32 : <vul-start> ; # line 683 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 875 <vul-end> \"ext/standard/var_unserializer.c\" yy39 : <vul-start> ; # line 648 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 931 <vul-end> \"ext/standard/var_unserializer.c\" yy46 : <vul-start> ; # line 615 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 985 <vul-end> \"ext/standard/var_unserializer.c\" yy53 : <vul-start> ; # line 605 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 1083 <vul-end> \"ext/standard/var_unserializer.c\" yy65 : <vul-start> ; # line 590 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1157 <vul-end> \"ext/standard/var_unserializer.c\" yy76 : <vul-start> ; # line 563 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 1211 <vul-end> \"ext/standard/var_unserializer.c\" yy83 : <vul-start> ; # line 556 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1226 <vul-end> \"ext/standard/var_unserializer.c\" yy87 : <vul-start> ; # line 549 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1236 <vul-end> \"ext/standard/var_unserializer.c\" yy89 : <vul-start> ; # line 526 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 1282 <vul-end> \"ext/standard/var_unserializer.c\" yy95 : <vul-start> ; # line 505 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 1326 <vul-end> \"ext/standard/var_unserializer.c\" } # <vul-start> } # line 877 <vul-end> \"ext/standard/var_unserializer.re\" return 0\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; # line 496 <vul-end> \"ext/standard/var_unserializer.c\" { YYCTYPE <vul-start> ; # line 896 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 558 <vul-end> \"ext/standard/var_unserializer.c\" yy4 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { php_error_docref <vul-start> } # line 561 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 558 <vul-end> \"ext/standard/var_unserializer.c\" yy17 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 861 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 861 <vul-end> \"ext/standard/var_unserializer.c\" yy17 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 861 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 859 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy17 : <vul-start> ; # line 859 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 608 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 859 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 609 <vul-end> \"ext/standard/var_unserializer.c\" yy17 : <vul-start> ; # line 859 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 859 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : "
  },
  {
    "id": 210,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t httpCheckCharset ( const char_t * s , size_t length , uint_t charset ) { error_t error ; size_t i ; uint8_t c ; uint_t m ; error = NO_ERROR ; for ( i = 0 ; i < length ; i ++ ) { c = ( uint8_t ) s [ i ] ; m = HTTP_CHARSET_OCTET ; if ( iscntrl ( c ) ) m |= HTTP_CHARSET_CTL ; if ( isprint ( c ) && c <= 126 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR ; if ( c == ' ' || c == '\\\\t' ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS ; if ( isalpha ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA ; if ( osIsdigit ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT ; if ( isxdigit ( c ) ) m |= HTTP_CHARSET_HEX ; if ( c >= 128 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT ; <vul-start> if ( strchr ( \"!#$%&\\'*+-.^_`|~\" , c ) ) <vul-end> m |= HTTP_CHARSET_TCHAR ; if ( ( m & charset ) == 0 ) error = ERROR_INVALID_SYNTAX ; } return error ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" ,\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start>, c )!= NULL ) m |= HTTP_CHARSET_TCHAR ; if ( osStrchr ( \"!#$%&\\'*+-.^_`|~\", c )!= NULL <vul-end> ) m |=\n"
  },
  {
    "id": 211,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <vul-start> bh -> b_size = map . m_len << inode -> i_blkbits ; <vul-end> } return err ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> -> b_size = ( u64 )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>. m_flags ; if ( map. m_len ) { bh -> b_size = ( sector_t ) <vul-end> map. m_len <vul-start> -> i_blkbits ; } else { bh -> b_size = 0 ; }\n"
  },
  {
    "id": 212,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <vul-start> gint64 offset ; <vul-end> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <vul-start> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <vul-end> if ( pkt_len == - 1 ) return FALSE ; <vul-start> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <vul-end> <vul-start> wth -> frame_buffer , err , err_info ) ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { gint64 offset <vul-end> ; char line <vul-start> = offset ; return parse_cosine_packet <vul-end> ( wth -> <vul-start> -> phdr , <vul-end> wth -> frame_buffer <vul-start> wth -> frame_buffer , line\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { gint64 offset <vul-end> ; char line <vul-start> = offset ; <vul-end> return parse_cosine_hex_dump ( <vul-start> return parse_cosine_hex_dump ( <vul-end> & wth -> <vul-start> wth -> frame_buffer, line\n"
  },
  {
    "id": 213,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_calc_ss_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; for ( i = 0 ; i < source -> y_height ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <vul-start> Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ; <vul-end> } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
  },
  {
    "id": 214,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <vul-start> } else if ( event -> type == et_char ) { <vul-end> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( \"scripting.html\" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> type == et_char && event -> u. chr. keysym!= GK_KEY_ESCAPE\n"
  },
  {
    "id": 215,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <vul-start> if ( sbinfo -> max_blocks >= 0 ) { <vul-end> <vul-start> buf -> f_blocks = sbinfo -> max_blocks ; <vul-end> <vul-start> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <vul-end> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <vul-end> buf -> f_blocks <vul-start> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <vul-end> ; buf -> <vul-start> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <vul-end> ; buf ->\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( sbinfo -> max_inodes <vul-end> >= 0 ) <vul-start> 0 ) { struct hugepage_subpool * spool = subpool_inode ( dentry -> d_inode ) ; <vul-start> -> f_blocks = spool -> max_blocks ; buf -> f_bavail = buf -> f_bfree = spool -> free_blocks ; buf -> f_files = spool -> max_inodes ; buf -> f_ffree = spool -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; <vul-end> return 0 ;\n"
  },
  {
    "id": 216,
    "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; <vul-start> args -> count = ntohl ( * p ++ ) ; <vul-end> len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <vul-start> return xdr_argsize_check ( rqstp , p ) ; <vul-end> }",
    "golden_answers": [
      "CWE-404 Fixed Code Lines are: <vul-start> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <vul-start> v ; return 1 <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> offset ) ; if (! xdr_argsize_check ( rqstp, p ) ) return 0 ; <vul-start> v ; return 1 <vul-end> ; }  \n"
  },
  {
    "id": 217,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_swevent_overflow ( struct perf_event * event , u64 overflow , <vul-start> int nmi , struct perf_sample_data * data , <vul-end> struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ; int throttle = 0 ; data -> period = event -> hw . last_period ; if ( ! overflow ) overflow = perf_swevent_set_period ( event ) ; if ( hwc -> interrupts == MAX_INTERRUPTS ) return ; for ( ; overflow ; overflow -- ) { <vul-start> if ( __perf_event_overflow ( event , nmi , throttle , <vul-end> data , regs ) ) { break ; } throttle = 1 ; } }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> u64 overflow , <vul-end> struct perf_sample_data * <vul-start> ( event , <vul-end> throttle , data\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> u64 overflow, <vul-end> struct perf_sample_data * <vul-start> ( event, <vul-end> throttle, data\n"
  },
  {
    "id": 218,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <vul-end> const __m128i kOne = _mm_set1_epi16 ( 1 ) ; __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ; __m128i out01 = _mm_add_epi16 ( in01 , kOne ) ; __m128i out23 = _mm_add_epi16 ( in23 , kOne ) ; out01 = _mm_srai_epi16 ( out01 , 2 ) ; out23 = _mm_srai_epi16 ( out23 , 2 ) ; <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_4x4 ( tran_low_t <vul-end> * output , <vul-start> 2 ) ; store_output ( & out01 , <vul-end> ( output + <vul-start> * 8 ) ) ; store_output ( & out23 , <vul-end> ( output + <vul-start> * 8 ) <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_4x4 ( tran_low_t <vul-end> * output, <vul-start> 2 ) ; _mm_store_si128 <vul-end> ( ( __m128i <vul-start> out01 ) ; _mm_store_si128 <vul-end> ( ( __m128i\n"
  },
  {
    "id": 219,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void color_cmyk_to_rgb ( opj_image_t * image ) { float C , M , Y , K ; float sC , sM , sY , sK ; unsigned int w , h , max , i ; w = image -> comps [ 0 ] . w ; h = image -> comps [ 0 ] . h ; <vul-start> if ( image -> numcomps < 4 ) return ; <vul-end> max = w * h ; sC = 1.0F / ( float ) ( ( 1 << image -> comps [ 0 ] . prec ) - 1 ) ; sM = 1.0F / ( float ) ( ( 1 << image -> comps [ 1 ] . prec ) - 1 ) ; sY = 1.0F / ( float ) ( ( 1 << image -> comps [ 2 ] . prec ) - 1 ) ; sK = 1.0F / ( float ) ( ( 1 << image -> comps [ 3 ] . prec ) - 1 ) ; for ( i = 0 ; i < max ; ++ i ) { C = ( float ) ( image -> comps [ 0 ] . data [ i ] ) * sC ; M = ( float ) ( image -> comps [ 1 ] . data [ i ] ) * sM ; Y = ( float ) ( image -> comps [ 2 ] . data [ i ] ) * sY ; K = ( float ) ( image -> comps [ 3 ] . data [ i",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ( <vul-start> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , \"%s:%d:color_cmyk_to_rgb\\\\n\\\\tCAN NOT CONVERT\\\\n\" , __FILE__ , __LINE__ ) ; return ; } <vul-end> max = w\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 4 ) return ; if ( w == 0 || h == 0 ) return\n"
  },
  {
    "id": 220,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ; <vul-start> if ( ! * passwd || ! * user -> passwd ) <vul-end> return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> if ( ! user ) { slog_error ( client , \"Password packet before auth packet?\" ) ; return false ; } if ( !\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> user -> passwd || strlen ( user -> name ) == 0\n"
  },
  {
    "id": 221,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <vul-start> if ( roishift == 0 && bgshift == 0 ) { <vul-end> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <vul-start> mask = ( 1 << numbps ) - 1 ; <vul-end> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( \"warning: possibly corrupt code stream\\\\n\" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> if ( roishift < 0 ) { jas_eprintf ( \"warning: forcing negative ROI shift to zero \" \"(bitstream is probably corrupt)\\\\n\" ) ; roishift = 0 ; } if ( roishift <vul-start> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << numbps )\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> uint_fast32_t mask ; jas_matind_t num_rows ; jas_matind_t num_cols ; <vul-start> bgshift == 0 && num_rows == 0 && num_cols == 0 <vul-start> <<= bgshift ; num_rows = jas_matrix_numrows ( x ) ; num_cols = jas_matrix_numcols ( x ) ; <vul-start> ( 1 << num_rows <vul-end> ) - 1\n"
  },
  {
    "id": 222,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int f2fs_set_data_page_dirty ( struct page * page ) { <vul-start> struct address_space * mapping = page -> mapping ; <vul-end> <vul-start> struct inode * inode = mapping -> host ; <vul-end> trace_f2fs_set_page_dirty ( page , DATA ) ; if ( ! PageUptodate ( page ) ) <vul-start> SetPageUptodate ( page ) ; <vul-end> if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) { if ( ! IS_ATOMIC_WRITTEN_PAGE ( page ) ) { f2fs_register_inmem_page ( inode , page ) ; return 1 ; } return 0 ; } if ( ! PageDirty ( page ) ) { __set_page_dirty_nobuffers ( page ) ; f2fs_update_dirty_page ( inode , page ) ; return 1 ; } return 0 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ) { struct <vul-end> inode * inode <vul-start> * inode = page_file_mapping ( page ) <vul-end> -> host ; <vul-start> ) ) SetPageUptodate ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) { struct f2fs_inode_info * ei = F2FS_I ( page ) ; struct <vul-start> * inode = ei -> i_mapping <vul-end> -> host ; <vul-start> SetPageUptodate ( page ) ; if (! PageSwapCache ( page ) ) set_page_dirty ( page, 0\n"
  },
  {
    "id": 223,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <vul-start> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <vul-end> if ( ! tmp ) <vul-start> return ; <vul-end> _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpDiff ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpDiff\" , \"%s\" , \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if ( ! <vul-start> tmp ) return 0 <vul-start> cp -- ) return 1 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpDiff ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"fpDiff\", \"%s\", \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if (! <vul-start> tmp ) return 0 <vul-start> cp -- ) return 0 ;\n"
  },
  {
    "id": 224,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <vul-end> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <vul-start> vpx_fixed_buf_t * stats ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to get frame stats.\" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <vul-start> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <vul-end> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> get_frame_stats ( vpx_codec_ctx_t <vul-start> stats ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> get_frame_stats ( vpx_codec_ctx_t <vul-start> vpx_fixed_buf_t * stats, vpx_uint8_t * const buf <vul-start> NULL ) { switch <vul-end> ( pkt -> <vul-start> pkt -> kind ) { case VPX_CODEC_STATS_PKT : <vul-end> stats -> buf <vul-start> ; } } return 0 ;\n"
  },
  {
    "id": 225,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <vul-start> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <vul-end> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> if ( count > <vul-end> DJREPORT_SHORT_LENGTH - 2\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ( unsigned char ) count < DJREPORT_SHORT_LENGTH ) count = DJREPORT_SHORT_LENGTH ; if (\n"
  },
  {
    "id": 226,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , \"//\" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , \"./\" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , \"/./\" ) ) != ( char * ) 0 ) <vul-start> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <vul-end> for ( ; ; ) { while ( strncmp ( file , \"../\" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , \"/../\" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , \"/..\"",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , strlen ( cp <vul-end> ) - 1\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) 0 ) { <vul-start> 1 ) ; }\n"
  },
  {
    "id": 227,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; <vul-start> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <vul-end> if ( ret != size ) { dev_err ( & urb -> dev -> dev , \"recv xbuf, %d\\\\n\" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; <vul-start> } else { <vul-end> usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> return 0 ; if ( size > urb -> transfer_buffer_length ) { <vul-end> if ( ud <vul-start> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <vul-start> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , \"recv xbuf, %d\\\\n\" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return 0 ; if (! ( ud -> transfer_buffer ) ) { dev_err ( & urb -> dev -> dev, \"empty transfer buffer\\\\n\" ) ; return - EPIPE ; } <vul-start> SDEV_EVENT_ERROR_TCP ) ; ret = 0 ; <vul-start> ; } } if (! ( ud -> transfer_buffer ) ) { dev_err ( & urb -> dev -> dev, \"invalid transfer buffer\\\\n\" ) ; return - EPIPE ; }\n"
  },
  {
    "id": 228,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <vul-start> { <vul-end> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> s ) { MpegEncContextPrivate * priv = s -> priv ; if (! priv -> avctx ) { return ; }\n"
  },
  {
    "id": 229,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <vul-start> if ( perf_event_overflow ( event , 0 , data , regs ) ) <vul-end> mipspmu -> disable_event ( idx ) ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ( event , <vul-end> data , regs\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( event, <vul-end> data, regs\n"
  },
  {
    "id": 230,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Input variables exceeded %\" PRIu64 \". \" \"To increase the limit change max_input_vars in php.ini.\" , max_vars ) ; return FAILURE ; } } <vul-start> if ( ! eof ) { <vul-end> memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ( ! eof && vars -> str . c != vars -> ptr\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> (! eof && vars -> end - vars -> ptr > 0\n"
  },
  {
    "id": 231,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ; <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <vul-end> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( TIF_32BIT ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , 0\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, 0\n"
  },
  {
    "id": 232,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 <vul-start> static struct desc_struct * get_desc ( unsigned short sel ) <vul-end> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <vul-start> struct desc_struct * desc = NULL ; <vul-end> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <vul-start> if ( ldt && sel < ldt -> nr_entries ) <vul-end> <vul-start> desc = & ldt -> entries [ sel ] ; <vul-end> mutex_unlock ( & current -> active_mm -> context . lock ) ; <vul-start> return desc ; <vul-end> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <vul-start> return NULL ; <vul-end> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start>     static bool get_desc ( <vul-start> struct desc_struct * out , <vul-end> unsigned short sel <vul-start> SEGMENT_LDT ) { bool success = false <vul-end> ; struct ldt_struct <vul-start> -> nr_entries ) { * out = <vul-end> ldt -> entries <vul-start> sel ] ; success = true ; } <vul-start> ) ; return success <vul-end> ; } # <vul-start> size ) return false ; * out = * <vul-end> ( struct desc_struct <vul-start> desc_base ) ; return true ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ( unsigned short num, struct desc_struct * * desc, struct ldt_struct * ldt ) { struct desc_struct * desc = NULL ; struct desc_struct * ldt_desc = NULL ; unsigned long desc_base <vul-end> ; # ifdef <vul-start> SEGMENT_LDT ) { <vul-end> sel >>= 3 <vul-start> -> nr_entries ) { desc = & ldt -> entries [ sel ] ; if ( desc ) * desc = * desc ; } else if ( ldt ) { desc = ldt -> entries [ sel ] ; } else { desc = NULL ; } <vul-end> mutex_unlock ( & <vul-start> lock ) ; * desc = desc_base <vul-end> ; } # <vul-start>. size ) { desc = NULL ; goto out ; } * desc = <vul-end> ( struct desc_struct <vul-start> desc_base ) ; out : return NULL ;\n"
  },
  {
    "id": 233,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int indenterror ( struct tok_state * tok ) <vul-start> { <vul-end> if ( tok -> alterror ) { tok -> done = E_TABSPACE ; tok -> cur = tok -> inp ; <vul-start> return 1 ; <vul-end> } if ( tok -> altwarning ) { # ifdef PGEN PySys_WriteStderr ( \"inconsistent use of tabs and spaces \" \"in indentation\\\\n\" ) ; # else PySys_FormatStderr ( \"%U: inconsistent use of tabs and spaces \" \"in indentation\\\\n\" , tok -> filename ) ; # endif tok -> altwarning = 0 ; } return 0 ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> * tok ) <vul-end> { tok -> <vul-start> inp ; return ERRORTOKEN <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> tok ) { const char * type_comment ; <vul-start> -> inp ; type_comment = get_type_comment ( tok -> inp ) ; if ( type_comment!= NULL ) { PyObject_SetString ( tok -> inp, type_comment, strlen ( type_comment ) + 1 ) ; }\n"
  },
  {
    "id": 234,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <vul-start> int event_id = event -> attr . config ; <vul-end> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> event ) { u64 <vul-end> event_id = event\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> attr. config ; if ( event_id < 0 ) return - EINVAL\n"
  },
  {
    "id": 235,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( \"sock %p sk %p\" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <vul-start> release_sock ( sk ) ; <vul-end> return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> -> id ; haddr -> hci_channel = 0 ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> -> id ; haddr -> hci_next_dev = NULL ;\n"
  },
  {
    "id": 236,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_dequant_idct_add_uv_block_mmx ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstu , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <vul-start> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <vul-end> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstu + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ; <vul-start> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <vul-end> } q += 32 ; dstu += 4 * stride ; eobs += 2 ; } for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstv , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( q , <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q , <vul-start> stride ) ; memset <vul-end> ( q +\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( q, <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q +\n"
  },
  {
    "id": 237,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <vul-start> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <vul-end> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> tf = ( <vul-end> luaY_parser ) (\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> ] )? luaU_parser_func : luaY_parser_func <vul-end> ) ( L\n"
  },
  {
    "id": 238,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <vul-start> { <vul-end> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> pos ) { check_stack_depth ( ) ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> pos ) { check_stack_depth ( ) ;\n"
  },
  {
    "id": 239,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <vul-start> kfree_skb ( skb ) ; <vul-end> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ; rx_drop : <vul-end> rcv_stats -> rx_dropped\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; rx_drop : if (! pskb_may_pull ( skb, ETH_HLEN ) ) goto tx_drop ;\n"
  },
  {
    "id": 240,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <vul-start> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <vul-end> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> { rq = tags -> rqs [ <vul-end> off + bit <vul-start> off + bit ] <vul-end> ; fn (\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> { rq = <vul-end> tags, off <vul-start> off + bit <vul-end> ; fn (\n"
  },
  {
    "id": 241,
    "question": "CWE-255 Code Input Vulnerable Code Is: CWE-255 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <vul-start> assert ( name ) ; <vul-end> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , \"Failed to %s UTF-8 kbdmode on %s: %m\" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? \"\\\\033%G\" : \"\\\\033%@\" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , \"Failed to %s UTF-8 term processing on %s: %m\" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , \"Failed to %s iutf8 flag on %s: %m\" , enable_disable ( utf8 ) , name ) ; log_debug ( \"UTF-8 kbdmode %sd on %s\" , enable_disable ( utf8 ) , name ) ; return 0 ; }",
    "golden_answers": [
      "CWE-255 Fixed Code Lines are: <vul-start> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , \"Failed to verify kbdmode on %s: %m\" ,\n"
    ],
    "generated_answer": "CWE-255 Fixed Code Lines are: <vul-start> { } ; if (! utf8 ) return log_warning_errno <vul-end> ( errno,\n"
  },
  {
    "id": 242,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <vul-start> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <vul-end> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <vul-start> LINE_OP (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> inverse_db_table [ y & 255 <vul-start> inverse_db_table [ y & 255\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x1 ) { LINE_OP_EX <vul-end> ( output [ <vul-start> += base ; LINE_OP_EX <vul-end> ( output [\n"
  },
  {
    "id": 243,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 1 ] == EOF ) <vul-end> return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 2 ] == EOF ) <vul-end> return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 3 ] == EOF ) <vul-end> return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ] == EOF || text [ 1 ] == 0 <vul-start> ; if ( ! isxdigit ( <vul-start> [ 2 ] ) <vul-end> ) return 0 <vul-start> ; if ( ! isxdigit ( <vul-start> [ 3 ] ) <vul-end> ) return 0\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( ( <vul-start> ] == EOF ) || ( text [ 1 ] == EOF ) <vul-start> ; if ( ( <vul-start> ] == EOF ) || ( text [ 2 ] == EOF ) <vul-start> ; if ( ( <vul-start> ] == EOF ) || ( text [ 3 ] == EOF )\n"
  },
  {
    "id": 244,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ; <vul-start> if ( istreq ( str , \"all\" ) ) { <vul-end> * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , \"none\" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ; if ( ! str ) return false ; if (\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( xkb_strcasestr <vul-end> ( str,\n"
  },
  {
    "id": 245,
    "question": "CWE-770 Code Input Vulnerable Code Is: CWE-770 WORD32 ihevcd_create ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { <vul-start> ihevcd_cxa_create_op_t * ps_create_op ; <vul-end> WORD32 ret ; codec_t * ps_codec ; <vul-start> ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ; <vul-end> ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; <vul-start> ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ; <vul-end> <vul-start> if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) ) <vul-end> { <vul-start> ihevcd_free_static_bufs ( ps_codec_obj ) ; <vul-end> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 1 << IVD_FATALERROR ; return IV_FAIL ; } ps_codec = ( codec_t * ) ps_codec_obj -> pv_codec_handle ; ret = ihevcd_init ( ps_codec ) ; TRACE_INIT ( NULL ) ; STATS_INIT ( ) ; return ret ; }",
    "golden_answers": [
      "CWE-770 Fixed Code Lines are: <vul-start> pv_api_op ) { ihevcd_cxa_create_ip_t * ps_create_ip ; <vul-start> * ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ; <vul-start> = 0 ; ps_codec_obj = NULL ; <vul-start> ) ; if <vul-end> ( IV_FAIL == <vul-start> == ret ) { if <vul-end> ( NULL != <vul-start> != ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle <vul-start> ps_codec_obj ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } }\n"
    ],
    "generated_answer": "CWE-770 Fixed Code Lines are: <vul-start> pv_api_op ) { <vul-end> WORD32 ret ; <vul-start> * ps_codec ; <vul-end> ps_create_op = ( <vul-start> = 0 ; ps_create_op -> s_ivd_create_op_t. u4_error_code = IVD_MEM_ALLOC_FAILED ; <vul-start> pv_api_op ) ; ihevcd_free_static_bufs ( ps_codec_obj ) ; <vul-start> ) ) { <vul-end> ps_create_op -> s_ivd_create_op_t\n"
  },
  {
    "id": 246,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <vul-start> int pkt_len ; <vul-end> <vul-start> char line [ NETSCREEN_LINE_LENGTH ] ; <vul-end> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <vul-start> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <vul-end> cap_dst , err , err_info ) ; <vul-start> if ( pkt_len == - 1 ) <vul-end> return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> line [ NETSCREEN_LINE_LENGTH <vul-end> ] ; if <vul-start> FALSE ; } return parse_netscreen_packet ( wth -> random_fh , phdr , buf <vul-end> , line , <vul-start> , line , <vul-end> err , err_info <vul-start> err_info ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> line [ NETSCREEN_LINE_LENGTH <vul-end> ] ; if <vul-start> FALSE ; } <vul-end> parse_netscreen_rec_hdr ( phdr <vul-start> ; if ( * <vul-end> err == 0\n"
  },
  {
    "id": 247,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <vul-start> Jpeg2000Prec * prec = band -> prec + precno ; <vul-end> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <vul-start> av_freep ( & band -> prec ) ; <vul-end> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ++ ) { if ( band -> prec ) { <vul-start> ) ; } }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> prec + precno ; av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) <vul-start> ) ; } <vul-end> } av_freep (\n"
  },
  {
    "id": 248,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( \"lockd: unlock failed (err = %d)\\\\n\" , - task -> tk_status ) ; <vul-start> goto retry_rebind ; <vul-end> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING \"lockd: unexpected unlock status: %d\\\\n\" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <vul-start> goto retry_rebind ; }\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; goto retry_rebind ; } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task, NLMCLNT_GRACE_WAIT ) ; goto retry_unlock\n"
  },
  {
    "id": 249,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( \"Wrong FIT format: not a flattened device tree (err=%d)\\\\n\" , ret ) ; return - ENOEXEC ; } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; <vul-start> if ( ret ) { <vul-end> log_debug ( \"FIT check error %d\\\\n\" , ret ) ; <vul-start> return - EINVAL ; <vul-end> } } if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { log_debug ( \"Wrong FIT format: no description\\\\n\" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( \"Wrong FIT format: no timestamp\\\\n\" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( \"Wrong FIT format: no images parent node\\\\n\" ) ; return - ENOENT ; } return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ( ret ) ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <vul-start> ) ; return ret ; } } if ( ret ) { log_debug ( \"FIT check error %d\\\\n\" , ret ) ; return ret <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> if ( ret < 0 <vul-start> return - EINVAL <vul-end> ; } }\n"
  },
  {
    "id": 250,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <vul-start> float * w = get_window ( f , n ) ; <vul-end> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , n ) ; if ( w == NULL ) return 0\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> previous_length ; double <vul-end> * w =\n"
  },
  {
    "id": 251,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , \"Compression type incompatible with image type\" ) ; <vul-start> } <vul-end> if ( rctx -> topdown ) { <vul-start> iw_set_error ( rctx -> ctx , \"Compression not allowed with top-down images\" ) ; <vul-end> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> \"Compression type incompatible with image type\" ) ; goto done ; <vul-start> , \"Compression not allowed with top-down images\" ) ; goto done\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> \"Compression type incompatible with image type\" ) ; goto done ; <vul-start> \"Compression not allowed with top-down images\" ) ; goto done\n"
  },
  {
    "id": 252,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static inline struct enamemem * <vul-end> lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) { <vul-start> struct enamemem * tp ; <vul-end> register u_int i , j , k ; if ( nlen >= 6 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = ( bs [ 4 ] << 8 ) | bs [ 5 ] ; } else if ( nlen >= 4 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = 0 ; } else i = j = k = 0 ; tp = & bytestringtable [ ( i ^ j ) & ( HASHNAMESIZE - 1 ) ] ; <vul-start> while ( tp -> e_nxt ) <vul-end> if ( tp -> e_addr0 == i && <vul-start> tp -> e_addr1 == j && <vul-end> <vul-start> tp -> e_addr2 == k && <vul-end> <vul-start> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) <vul-end> return tp ; else <vul-start> tp = tp -> e_nxt ; <vul-end> tp -> e_addr0 = i ; tp -> e_addr1 = j ; tp -> e_addr2 = k ; tp -> e_bs = ( u_char * )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> static inline struct bsnamemem <vul-end> * lookup_bytestring ( <vul-start> ) { struct bsnamemem <vul-end> * tp ; <vul-start> ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <vul-end> && tp -> <vul-start> && tp -> bs_addr0 == i <vul-end> && tp -> <vul-start> && tp -> bs_addr1 == j && tp -> bs_addr2 <vul-end> == k && <vul-start> ( tp -> bs_bytes <vul-end> ) , nlen <vul-start> = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <vul-end> = ( u_char <vul-start> ( tp -> bs_bytes <vul-end> == NULL ) <vul-start> ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <vul-end> = ( struct <vul-start> = ( struct bsnamemem <vul-end> * ) calloc <vul-start> ( tp -> bs_nxt <vul-end> == NULL )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static inline bs_t <vul-end> * lookup_bytestring ( <vul-start> nlen ) { bs_t <vul-end> * tp ; <vul-start> ) ] ; if ( tp -> e_bs == NULL ) { <vul-end> if ( tp <vul-start> == i && bs [ tp -> e_addr1 ] == j && bs [ tp -> e_addr2 ] == k && memcmp ( bs, ( const char * ) ( tp -> e_bs ), nlen ) == 0 ) return tp ; } else if ( tp -> e_nxt ) { <vul-start> -> e_addr2 == k && memcmp ( bs, ( const char * ) ( tp -> e_bs ), nlen ) == 0 ) return tp ; } else { <vul-end> tp = tp <vul-start> -> e_nxt ; } <vul-start> bs, nlen, 0\n"
  },
  {
    "id": 253,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) { char * buffer = NULL ; int n = 0 ; FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , NULL ) ; <vul-start> if ( length > 0 ) { <vul-end> <vul-start> buffer = malloc ( ( uint64_t ) length + 1 ) ; <vul-end> if ( buffer != NULL ) { if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessFileTransferReadBuffer: read\" ) ; rfbCloseClient ( cl ) ; if ( buffer != NULL ) free ( buffer ) ; return NULL ; } buffer [ length ] = 0 ; } } return buffer ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> if ( length == SIZE_MAX ) { rfbErr ( \"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <vul-start> malloc ( ( size_t <vul-end> ) length +\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> length > 0 && length < 1024 <vul-start> = malloc ( <vul-end> length + 1\n"
  },
  {
    "id": 254,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ; <vul-start> if ( io_data -> read && ret > 0 ) { <vul-end> use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && <vul-start> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <vul-end> eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ; <vul-start> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <vul-end> io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> -> actual ; bool kiocb_has_eventfd = <vul-end> io_data -> kiocb <vul-start> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <vul-end> ) eventfd_signal ( <vul-start> -> req ) <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> actual ; struct usb_request * req = io_data -> req ; struct usb_ep_context * ctx ; int ret ; ctx = io_data -> ffs -> ffs_ctx ; <vul-start> -> ffs_eventfd && ( ctx -> flags & IOCB_EVENTFD ) ) { ret = eventfd_signal_or_free ( ctx -> eventfd, 1 ) ; if ( ret ) ret = - EFAULT ; } else if (! io_data -> read && <vul-start> IOCB_EVENTFD ) ) { <vul-start> 1 ) ; }\n"
  },
  {
    "id": 255,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ; <vul-start> unlock_mount_hash ( ) ; <vul-end> if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> mnt_instance ) ; mnt -> mnt_flags &= ~ MNT_DOOMED ;\n"
  },
  {
    "id": 256,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * upayload , * zap ; size_t datalen = prep -> datalen ; int ret ; ret = - EINVAL ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) goto error ; ret = - ENOMEM ; upayload = kmalloc ( sizeof ( * upayload ) + datalen , GFP_KERNEL ) ; if ( ! upayload ) goto error ; upayload -> datalen = datalen ; memcpy ( upayload -> data , prep -> data , datalen ) ; zap = upayload ; ret = key_payload_reserve ( key , datalen ) ; if ( ret == 0 ) { <vul-start> zap = key -> payload . data [ 0 ] ; <vul-end> <vul-start> rcu_assign_keypointer ( key , upayload ) ; <vul-end> key -> expiry = 0 ; } if ( zap ) kfree_rcu ( zap , rcu ) ; error : return ret ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <vul-start> 0 ] ; else zap = NULL ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> 0 ) { if ( upayload -> payload. data ) { <vul-start> 0 ] ; }\n"
  },
  {
    "id": 257,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) <vul-start> return - EINVAL ; <vul-end> if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> return - EINVAL <vul-end> ; err =\n"
  },
  {
    "id": 258,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <vul-start> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <vul-end> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> && str [ j <vul-end> ] ; i\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> [ i ] && str [ j ]\n"
  },
  {
    "id": 259,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static PHP_NAMED_FUNCTION ( zif_zip_entry_read ) { zval * zip_entry ; zend_long len = 0 ; zip_read_rsrc * zr_rsrc ; zend_string * buffer ; int n = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , \"r|l\" , & zip_entry , & len ) == FAILURE ) { return ; } if ( ( zr_rsrc = ( zip_read_rsrc * ) zend_fetch_resource ( Z_RES_P ( zip_entry ) , le_zip_entry_name , le_zip_entry ) ) == NULL ) { RETURN_FALSE ; } if ( len <= 0 ) { len = 1024 ; } if ( zr_rsrc -> zf ) { <vul-start> buffer = zend_string_alloc ( len , 0 ) ; <vul-end> n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n > 0 ) { ZSTR_VAL ( buffer ) [ n ] = '\\\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; } else { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) } } else { RETURN_FALSE ; } }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> { buffer = zend_string_safe_alloc ( 1 , len , 0 <vul-end> , 0 )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> zf ) { if ( len > 1024 ) { RETURN_FALSE ; }\n"
  },
  {
    "id": 260,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct l2tp_packet_t * l2tp_packet_alloc ( int ver , int msg_type , const struct sockaddr_in * addr , int H , const char * secret , size_t secret_len ) { struct l2tp_packet_t * pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) return NULL ; memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; <vul-start> pack -> hdr . ver = ver ; <vul-end> pack -> hdr . T = 1 ; pack -> hdr . L = 1 ; pack -> hdr . S = 1 ; memcpy ( & pack -> addr , addr , sizeof ( * addr ) ) ; pack -> hide_avps = H ; pack -> secret = secret ; pack -> secret_len = secret_len ; if ( msg_type ) { if ( l2tp_packet_add_int16 ( pack , Message_Type , msg_type , 1 ) ) { mempool_free ( pack ) ; return NULL ; } } return pack ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> hdr . flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK ) <vul-end> ; memcpy (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> attrs ) ; memset ( pack, 0, sizeof ( * pack ) ) ;\n"
  },
  {
    "id": 261,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ; <vul-start> if ( COMPAT_USE_64BIT_TIME ) <vul-end> return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; <vul-start> if ( get_compat_timespec ( & ktspec , timeout ) ) <vul-end> return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; <vul-start> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <vul-end> datagrams = - EFAULT ; return datagrams ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( <vul-end> timeout == NULL <vul-start> ; if ( compat_get_timespec <vul-end> ( & ktspec <vul-start> > 0 && compat_put_timespec <vul-end> ( & ktspec\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( timeout == NULL ) return - EFAULT ; if ( <vul-start> ; if (! access_ok ( VERIFY_WRITE, mmsg, vlen ) ) return - EFAULT ; if ( <vul-start> > 0 &&! access_ok ( VERIFY_WRITE, mmsg, vlen ) ) datagrams = - EFAULT ; if ( datagrams == 0 &&\n"
  },
  {
    "id": 262,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ; <vul-start> bpm -> family = AF_BRIDGE ; <vul-end> bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> nlmsg_data ( nlh ) ; memset ( bpm, 0, sizeof ( * bpm )\n"
  },
  {
    "id": 263,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 asmlinkage void do_ade ( struct pt_regs * regs ) { unsigned int __user * pc ; mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <vul-start> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <vul-end> if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ; pc = ( unsigned int __user * ) exception_epc ( regs ) ; if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) goto sigbus ; if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) goto sigbus ; else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) show_registers ( regs ) ; seg = get_fs ( ) ; if ( ! user_mode ( regs ) ) set_fs ( KERNEL_DS ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; set_fs ( seg ) ; return ; sigbus : die_if_kernel ( \"Kernel unaligned instruction access\" , regs ) ; force_sig ( SIGBUS , current ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <vul-end> , regs ,\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, regs\n"
  },
  {
    "id": 264,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) { VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; if ( ! pbi ) return NULL ; <vul-start> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <vul-end> if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; remove_decompressor ( pbi ) ; return 0 ; } pbi -> common . error . setjmp = 1 ; vp8_create_common ( & pbi -> common ) ; pbi -> common . current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; vp8cx_init_de_quantizer ( pbi ) ; vp8_loop_filter_init ( & pbi -> common ) ; pbi -> common . error . setjmp = 0 ; # if CONFIG_ERROR_CONCEALMENT pbi -> ec_enabled = oxcf -> error_concealment ; pbi -> overlaps = NULL ; # else <vul-start> pbi -> ec_enabled = 0 ; <vul-end> # endif pbi -> ec_active = 0 ; pbi -> decoded_key_frame = 0 ; pbi -> independent_partitions = 0 ; vp8_setup_block_dptrs ( & pbi -> mb ) ; return pbi ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> return NULL ; memset <vul-end> ( pbi , <vul-start> ; # else ( void ) oxcf ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return NULL ; memset <vul-end> ( pbi, <vul-start> pbi -> ec_enabled = 0 ; pbi -> ready_for_new_data\n"
  },
  {
    "id": 265,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , <vul-start> [ DISCE_PROBE ] = sas_probe_devices , <vul-end> [ DISCE_SUSPEND ] = sas_suspend_devices , <vul-start> [ DISCE_RESUME ] = sas_resume_devices , <vul-end> [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> sas_revalidate_domain , [ <vul-end> DISCE_SUSPEND ] = <vul-start> ] = sas_resume_devices <vul-end> , } ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> sas_revalidate_domain, [ DISCE_DESTRUCT ] = sas_destruct_devices, [ <vul-start> ] = sas_probe_devices <vul-end>, } ;\n"
  },
  {
    "id": 266,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , \"localhost\" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <vul-start> return res ; <vul-end> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; } } cleanup : <vul-end> return res ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; } } if ( fm_mgr_config_mgr_add_file ( hdl, \"/proc/self/conf\", NULL ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; }\n"
  },
  {
    "id": 267,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; } <vul-start> s_cmd -> command += ec -> cmd_offset ; <vul-end> ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ; <vul-start> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <vul-end> ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <vul-start> s_cmd ) + s_cmd -> <vul-end> insize ) )\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> exit ; } if ( ec -> cmd_offset + sizeof ( * s_cmd ) + u_cmd. outsize > ec -> cmd_max_size ) { ret = - EINVAL ; goto exit ; } <vul-start>. insize ) ) ret = - EFAULT ; exit : if ( s_cmd -> command > ec -> cmd_max - sizeof ( * s_cmd ) ) ret = - EINVAL ; else ret = 0 <vul-end> ; }  \n"
  },
  {
    "id": 268,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ; <vul-start> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <vul-end> return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if (! ns_capable ( user_ns, CAP_SYS_ADMIN ) ) return - EPERM ; if (\n"
  },
  {
    "id": 269,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <vul-start> for ( i = 0 ; i < len ; i ++ ) { <vul-end> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <vul-start> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <vul-end> j ++ ; szLine [ i ] &= 0xbf ; } <vul-start> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <vul-end> <vul-start> szLineConv [ j ] = szLine [ i ] ; <vul-end> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <vul-start> szLineConv [ j ] = szLine [ i ] ; <vul-end> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( (",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <vul-end> ++ ) { <vul-start> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <vul-start> ; } else break ; } else <vul-start> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else if <vul-start> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else if <vul-start> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else { <vul-start> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <vul-end> szLineConv [ j\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> szLine ) ; if ( len > ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0x80 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xbf ; } } <vul-start> 0xc0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xe0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xe0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xf0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xf0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0x80 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> ; } } } if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;\n"
  },
  {
    "id": 270,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; <vul-start> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <vul-end> return - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ) != ulen || replay_esn -> bmp_len != up -> bmp_len\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( ulen < up -> replay_window ||\n"
  },
  {
    "id": 271,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <vul-start> int contentlen = 0 ; <vul-end> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != ' ' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != ' ' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , ' ' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ;",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> printparam pp ; unsigned <vul-end> contentlen = 0 <vul-start> sb ++ ; sscanf ( sb , \"%u\" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <vul-end> ; } else <vul-start> & pp , \"<form method=\\\\\"POST\\\\\" action=\\\\\"/U\\\\\" enctype=\\\\\"application/x-www-form-urlencoded\\\\\"><textarea cols=\\\\\"80\\\\\" rows=\\\\\"30\\\\\" name=\\\\\"conffile\\\\\">\" <vul-end> ) ; while <vul-start> 'U' : { unsigned <vul-end> l = 0 <vul-start> ! writable || ! contentlen || <vul-start> } while ( l < contentlen && <vul-start> ) buf , ( contentlen - l ) > <vul-start> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <vul-start> l ) ; if ( ! l ) { if ( i < 9 || <vul-end> strncasecmp ( buf <vul-start> error ) { buf [ i ] = 0 ; <vul-start> l += i <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; int contentlen = 0 ; int length <vul-start> sb ++ ; length = atoi ( sb ) ; if ( length < 0 ) { RETURN ( 701 ) ; } <vul-start> ; contentlen = length <vul-end> ; } else\n"
  },
  {
    "id": 272,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <vul-start> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <vul-end> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ; if ( dumpable != SUID_DUMP_USER && <vul-end> ! ptrace_has_cap (\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>! ptrace_has_cap ( task -> mm -> user_ns, mode ) ) { rcu_read_unlock ( ) ; return - EPERM ; } if (! ptrace_has_cap ( <vul-start>, mode ) ||! ptrace_may_see_task_stack ( task ) ) { rcu_read_unlock ( ) ; return - EPERM ; } if (! ptrace_may_see_task_stack ( task )\n"
  },
  {
    "id": 273,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } <vul-start> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <vul-end> int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> [ p ] && in -> linesize [ p ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> in -> data [ p ] && in -> linesize\n"
  },
  {
    "id": 274,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <vul-end> { struct file * filp ; int ret ; <vul-start> if ( nd -> intent . open . flags & FMODE_EXEC ) { <vul-end> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <vul-start> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <vul-end> return ret ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> nfs4_state * state , fmode_t fmode <vul-start> ; if ( fmode <vul-end> & FMODE_EXEC ) <vul-start> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> path * path, fmode_t fmode <vul-start> ; if ( fmode <vul-end> ) { ret <vul-start>, state, fmode <vul-end> ) ; return\n"
  },
  {
    "id": 275,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> |= MSG_TRUNC ; <vul-end> lock_sock ( sk\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> |= MSG_TRUNC ; <vul-end> lock_sock ( sk\n"
  },
  {
    "id": 276,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <vul-start> } <vul-end> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ret ; } if ( pid == INT_MIN ) return - ESRCH ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ret ; } if (! info -> si_addr ) { ret = - EPERM ; goto out ; }\n"
  },
  {
    "id": 277,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } <vul-start> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <vul-end> sk_dst_reset ( sk ) ; return opt ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> = xchg ( ( __force struct ipv6_txoptions * * )\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> } opt = rcu_dereference_protected ( <vul-start> ) -> opt, 1, sock_owned_by_user ( sk ) ) <vul-end> ; sk_dst_reset (\n"
  },
  {
    "id": 278,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int atusb_get_and_show_build ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <vul-start> char build [ ATUSB_BUILD_SIZE + 1 ] ; <vul-end> <vul-start> int ret ; <vul-end> ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ; if ( ret >= 0 ) { build [ ret ] = 0 ; dev_info ( & usb_dev -> dev , \"Firmware: build %s\\\\n\" , build ) ; } <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> usb_dev ; char * build <vul-end> ; int ret <vul-start> ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <vul-start> ) ; } kfree ( build ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> usb_dev ; struct usb_control message ; int ret ; size_t size ; size = <vul-end> ATUSB_BUILD_SIZE + 1 <vul-start> 1 ] ; if ( size < 0 ) return - EINVAL <vul-end> ; ret = <vul-start> ) ; } else { build_size = size ; } kfree ( build ) ;\n"
  },
  {
    "id": 279,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <vul-start> markold ( g , g -> survival , g -> reallyold ) ; <vul-end> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , g -> allgc <vul-end> , g ->\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> GCSpropagate ) ; markold_gc <vul-end> ( g,\n"
  },
  {
    "id": 280,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( \"result of FW_CONFIG in identify state %d\\\\n\" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else <vul-start> return - EIO ; <vul-end> deb_info ( \"Identify state cold = %d\\\\n\" , * cold ) ; err : kfree ( buf ) ; return ret ; }",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> 0 ; else ret = <vul-end> - EIO ; <vul-start> - EIO ; if ( ! ret )\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> 0 ; else { kfree ( buf ) ; <vul-start> - EIO ; }\n"
  },
  {
    "id": 281,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <vul-start> if ( sec_attr == NULL ) { <vul-end> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> sec_attr == NULL || sec_attr_len\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> SC_ERROR_INVALID_ARGUMENTS ; } file -> sec_attr_len = sec_attr_len ; <vul-start> NULL ) { <vul-end> free ( file\n"
  },
  {
    "id": 282,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 NOEXPORT char * pgsql_server ( CLI * c , SERVICE_OPTIONS * opt , const PHASE phase ) { uint8_t buffer [ 8 ] , ssl_ok [ 1 ] = { 'S' } ; <vul-start> ( void ) opt ; <vul-end> if ( phase != PROTOCOL_EARLY ) <vul-start> return NULL ; <vul-end> memset ( buffer , 0 , sizeof buffer ) ; s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ; <vul-start> if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { <vul-end> <vul-start> s_log ( LOG_ERR , \"PostgreSQL client did not request TLS, rejecting\" ) ; <vul-end> throw_exception ( c , 1 ) ; } <vul-start> s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; <vul-end> return NULL ; }",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start> 'S' } ; static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , ' ' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , ' ' , 'b' , 'u' , 't' , ' ' , 'n' , 'o' , 't' , ' ' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , ' ' , 'b' , 'y' , ' ' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <vul-start> ) return NULL ; s_log ( LOG_DEBUG , \"Started server-side psql protcol negotiation\" ) <vul-start> ; if ( ! <vul-start> ( buffer , gss_request , sizeof gss_request <vul-end> ) ) { <vul-start> { s_log ( LOG_INFO , \"GSSAPI encryption requested, rejecting gracefully\" ) ; <vul-end> s_write ( c <vul-start> . fd , gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , \"PostgreSQL client did not request TLS, rejecting\" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , \"SSLRequest received\" ) ; s_write ( c , c -> local_wfd . fd ,\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> 'S' } ; int ret = 0 ; <vul-start> PROTOCOL_EARLY ) return NULL ; if ( c -> remote_rfd. fd >= MAX_CONNECTIONS ) throw_exception ( c, 1 ) ; ret = set_peer_cert ( c, opt, phase, NULL, 0 ) ; if ( ret < 0 ) return NULL ; ret = set_peer_cert ( c, opt, phase, NULL, 0 <vul-start> ; if ( ret < 0 || <vul-start> ssl_request ) ) return NULL ; if (! ret && <vul-start> ( LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\" <vul-end> ) ; throw_exception <vul-start> ) ; } if (! ret && <vul-start>, sizeof ssl_ok ) ) return NULL ; if (! opt -> verify_peer ) throw_exception ( c, 1\n"
  },
  {
    "id": 283,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; <vul-start> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <vul-end> DPRINTF ( ( \"Chain:\" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( \" %d\" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Counting chain loop limit\" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <vul-start> if ( sid > maxsector ) { <vul-end> DPRINTF ( ( \"Sector %d > %d\\\\n\" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( \" none, sid: %d\\\\n\" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( \"\\\\n\" ) ) ; return i ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( cdf_secid_t ) ( <vul-start> * size ) / sizeof ( maxsector ) ) <vul-start> if ( sid >= maxsector ) { DPRINTF ( ( \"Sector %d >= %d\\\\n\" <vul-end> , sid ,\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, j ; size_t maxsector = <vul-end> ( sat -> <vul-start> sat_len * size <vul-end> ; DPRINTF ( <vul-start> if ( sid >= <vul-end> maxsector ) {\n"
  },
  {
    "id": 284,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , <vul-start> bool compat ) <vul-end> { ssize_t ret ; * nr_segs = * len ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( rw , ( struct compat_iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; else # endif ret = rw_copy_check_uvector ( rw , ( struct iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; if ( ret < 0 ) return ret ; * len = ret ; <vul-start> return 0 ; <vul-end> }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> , bool compat , struct iov_iter * iter <vul-start> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, bool compat, struct iov_iter * iter, bool compat_copy <vul-start> = ret ; if (! compat_copy &&! compat_copy ) ret = rw_verify_area ( rw, iovec, * nr_segs, * len ) ; else\n"
  },
  {
    "id": 285,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <vul-start> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <vul-end> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( kvm_set_msr <vul-end> ( vcpu ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( kvm_set_msr <vul-end> ( vcpu,\n"
  },
  {
    "id": 286,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( \"print starting\" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( \"setup changed\" , ( SIGNAL_FUNC ) read_settings ) ; <vul-start> signal_remove ( \"message quit\" , ( SIGNAL_FUNC ) msg_quit ) ; <vul-end> signal_remove ( \"message join\" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( \"message irc mode\" , ( SIGNAL_FUNC ) msg_mode ) ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; signal_remove ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ( SIGNAL_FUNC ) sig_settings <vul-end> ) ; signal_remove\n"
  },
  {
    "id": 287,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 <vul-start> static int may_create_in_sticky ( struct dentry * const dir , <vul-end> struct inode * const inode ) { if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) || <vul-start> likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) || <vul-end> <vul-start> uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) || <vul-end> uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ; <vul-start> if ( likely ( dir -> d_inode -> i_mode & 0002 ) || <vul-end> <vul-start> ( dir -> d_inode -> i_mode & 0020 && <vul-end> ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) { const char * operation = S_ISFIFO ( inode -> i_mode ) ? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT , operation ) ; return - EACCES ; } return 0 ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid <vul-end> , struct inode <vul-start> ( ! ( dir_mode <vul-end> & S_ISVTX ) <vul-start> -> i_uid , dir_uid <vul-end> ) || uid_eq <vul-start> ( likely ( dir_mode <vul-end> & 0002 ) <vul-start> ) || ( dir_mode <vul-end> & 0020 &&\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> int may_create_sticky ( struct file * dir, uid_t * uid, gid_t * gid, <vul-start>! ( dir -> d_inode -> i_mode & S_ISVTX ) ) || uid_eq ( inode -> i_uid, dir -> d_inode -> i_uid ) || uid_eq ( current_fsuid ( ), inode -> i_uid ) || gid_eq ( current_gid ( ), inode -> i_gid ) ) return 0 ; if ( likely ( dir -> d_inode -> i_mode & 0020 ) ) { const char * operation = S_ISFIFO ( inode -> i_mode )? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT, operation ) ; return - EACCES ; } if ( likely ( dir -> d_inode -> i_mode & 0020 ) ) { const char * operation = S_ISFIFO ( inode -> i_mode )? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT, operation ) ; return - EACCES ; } if ( likely ( dir -> d_inode -> i_mode & 0444 ) || ( dir -> d_inode -> i_mode & 0444 ) ) { const char * operation = S_ISFIFO ( inode -> i_mode )? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT, operation ) ; return - EACCES ; } if ( likely ( dir -> d_inode -> i_mode & 0444 ) ) { const char * operation = S_ISREG ( inode -> i_mode )? \"sticky_create_regular\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT, operation ) ; return - EACCES ; } return 0 ; <vul-end> }    \n"
  },
  {
    "id": 288,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_fw_download ( unsigned long arg ) <vul-end> { struct mpt_fw_xfer __user * ufwdl = ( void __user * ) arg ; struct mpt_fw_xfer kfwdl ; if ( copy_from_user ( & kfwdl , ufwdl , sizeof ( struct mpt_fw_xfer ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \" \"Unable to copy mpt_fw_xfer struct @ %p\\\\n\" , __FILE__ , __LINE__ , ufwdl ) ; return - EFAULT ; } <vul-start> return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ; <vul-end> }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_fw_download ( MPT_ADAPTER * iocp , <vul-start> return mptctl_do_fw_download ( iocp <vul-end> , kfwdl .\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_fw_download ( MPT_FIRMWARE_INFO * ioc, <vul-start> EFAULT ; } if ( kfwdl. iocnum >= MPT_CNT_FIRMWARE ) return - EINVAL ;\n"
  },
  {
    "id": 289,
    "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } <vul-start> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <vul-end> dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }",
    "golden_answers": [
      "CWE-358 Fixed Code Lines are: <vul-start> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->\n"
    ],
    "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> AF_INET6 ; } if ( dt -> vlan_id ) memcpy ( dt -> vlan_id, p -> vlan_id, sizeof ( uint16_t ) * 2 ) ;\n"
  },
  {
    "id": 290,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int bta_co_rfc_data_outgoing ( void * user_data , uint8_t * buf , uint16_t size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <vul-start> int received = recv ( slot -> fd , buf , size , 0 ) ; <vul-end> if ( received == size ) { ret = true ; } else { LOG_ERROR ( \"%s error receiving RFCOMM data from app: %s\" , __func__ , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> int received = TEMP_FAILURE_RETRY ( <vul-start> size , 0 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int received = TEMP_FAILURE_RETRY ( <vul-start> size, 0 )\n"
  },
  {
    "id": 291,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ; <vul-start> struct scatterlist sg [ 1 ] ; <vul-end> if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ; <vul-start> sg_init_one ( sg , buf , count ) ; <vul-end> <vul-start> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <vul-end> <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> [ 1 ] ; void * data ; int ret <vul-start> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <vul-start> ( sg , data <vul-end> , count ) <vul-start> count ) ; ret = <vul-end> __send_to_port ( port <vul-start> , count , data <vul-end> , false ) <vul-start> false ) ; kfree ( data ) ; return ret ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * port ; int ret ; struct scatterlist * sg ; struct scatterlist * next ; int i <vul-end> ; port = <vul-start> - EPIPE ; for ( i = 0 ; i < count ; i ++ ) { sg = & next [ i ] ; if (! sg_one_sg ( sg, next, 0, 0, NULL, 0 ) ) return - EINVAL ; } for ( i = 0 ; i < count ; i ++ ) { if (! sg_one_sg ( sg, next, i, 0, NULL, 0 ) ) return - EINVAL ; } for ( i = 0 ; i < count ; i ++ ) { if (! sg_one_sg ( sg, next, i, NULL, 0 ) ) return - EINVAL ; } <vul-start> ( port, & next, <vul-end> 1, count <vul-start> false ) ; kfree ( sg ) ; return ret ;\n"
  },
  {
    "id": 292,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; <vul-start> struct free_nid * i ; <vul-end> struct nat_entry * ne ; <vul-start> int err ; <vul-end> if ( unlikely ( nid == 0 ) ) return false ; <vul-start> if ( build ) { <vul-end> ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) <vul-start> return false ; <vul-end> } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> free_nid * i , * e <vul-start> ; int err = - EINVAL ; bool ret = false <vul-start> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <vul-start> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct f2fs_free_node * ni ; struct <vul-start> ; int err ; struct f2fs_node_info * ni_info <vul-start> return false ; ni_info = f2fs_get_node_info ( sbi, nid ) ; if ( ni_info && ni_info -> valid_nid == nid ) return true ; <vul-start> NULL_ADDR ) ) { f2fs_put_node_info ( ni_info ) ; return false ; } <vul-end> } i =\n"
  },
  {
    "id": 293,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <vul-start> record_and_restart ( event , val , regs , nmi ) ; <vul-end> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> val , regs <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> val, regs <vul-end> ) ; }\n"
  },
  {
    "id": 294,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 unsigned char * base64decode ( const char * buf , size_t * size ) { if ( ! buf || ! size ) return NULL ; size_t len = ( * size > 0 ) ? * size : strlen ( buf ) ; if ( len <= 0 ) return NULL ; unsigned char * outbuf = ( unsigned char * ) malloc ( ( len / 4 ) * 3 + 3 ) ; const char * ptr = buf ; int p = 0 ; <vul-start> size_t l = 0 ; <vul-end> do { <vul-start> ptr += strspn ( ptr , \"\\\\r\\\\n\\\\t \" ) ; <vul-end> if ( * ptr == '\\\\0' || ptr >= buf + len ) { break ; } <vul-start> l = strcspn ( ptr , \"\\\\r\\\\n\\\\t \" ) ; <vul-end> if ( l > 3 && ptr + l <= buf + len ) { p += base64decode_block ( outbuf + p , ptr , l ) ; ptr += l ; } else { break ; } } while ( 1 ) ; outbuf [ p ] = 0 ; * size = p ; return outbuf ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <vul-end> = 0 ; <vul-start> ; do { while ( ptr < buf + len && ( * ptr == ' ' || * ptr == '\\\\t' || * ptr == '\\\\n' || * ptr == '\\\\r' ) ) { ptr ++ ; } <vul-end> if ( * <vul-start> break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <vul-end> } } while\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; const char * p0 = buf ; <vul-start> { ptr += strn0 <vul-end> ( ptr, <vul-start> } l = strn0 <vul-end> ( ptr,\n"
  },
  {
    "id": 295,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( \"%s with no commands pending response\" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( \"%s hci layer timeout waiting for response to a command. opcode: 0x%x\" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( \"%s restarting the bluetooth process.\" , __func__ ) ; <vul-start> usleep ( 10000 ) ; <vul-end> kill ( getpid ( ) , SIGKILL ) ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> __func__ ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 10000 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> __func__ ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 10000 )\n"
  },
  {
    "id": 296,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , \" [invalid len %d]\" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \" [max resp delay=%d]\" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , \" [gaddr %s\" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , \" sflag\" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , \" robustness=%d\" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( ndo , \"%s\" , mldv2_tstr <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ndo, \"%s\", mldv_tstr <vul-end> ) ) ;\n"
  },
  {
    "id": 297,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <vul-start> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <vul-end> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , \" %s\" , tok2str ( sunrpc_str , \"ar_stat %d\" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> uint32_t ) ; ND_TCHECK <vul-end> ( dp [ <vul-start> [ 0 ] <vul-end> ) ; astat\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> uint32_t ) ; ND_TCHECK_32BITS ( dp <vul-end> ) ; astat\n"
  },
  {
    "id": 298,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <vul-end> TOKENEXTRA * * tp , int mi_row , int mi_col , <vul-start> int output_enabled , BLOCK_SIZE bsize ) { <vul-end> <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> <vul-start> if ( bsize < BLOCK_8X8 ) { <vul-end> if ( x -> ab_index > 0 ) return ; } <vul-start> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <vul-end> <vul-start> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <vul-end> output_enabled ) ; <vul-start> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <vul-end> if ( output_enabled ) { <vul-start> update_stats ( cpi ) ; <vul-end> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * const tile , ThreadData * td <vul-start> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <vul-start> x = & td <vul-end> -> mb ; <vul-start> -> mb ; <vul-end> set_offsets ( cpi <vul-start> cpi , tile , x <vul-start> ( cpi , td , ctx <vul-end> , mi_row , <vul-start> encode_superblock ( cpi , td <vul-start> mi_col , bsize , ctx <vul-start> { update_stats ( & cpi -> common , td <vul-end> ) ; (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void encode_b ( const MACROBLOCK * const x <vul-end>, const TileInfo <vul-start>, BLOCK_SIZE bsize, PC_TREE * pc_tree <vul-start> x = & x -> plane [ 0 ]. src <vul-end> ; if ( <vul-start> bsize < BLOCK_8X8 || bsize == BLOCK_8X8 ) { <vul-end> set_offsets ( cpi <vul-start> ( cpi, x, pc_tree <vul-end>, mi_row, <vul-start> ; update_state ( x <vul-end>, get_block_context ( <vul-start> ; encode_superblock ( x <vul-end>, tp, <vul-start> { update_stats ( x <vul-end> ) ; (\n"
  },
  {
    "id": 299,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { <vul-start> struct task_struct * task = current ; <vul-end> file_sb_list_del ( file ) ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> task = current <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> task = current <vul-end> ; if (\n"
  },
  {
    "id": 300,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_mpt_command ( unsigned long arg ) <vul-end> { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; <vul-start> struct mpt_ioctl_command karg ; <vul-end> MPT_ADAPTER * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \" \"Unable to read in mpt_ioctl_command struct @ %p\\\\n\" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <vul-start> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <vul-end> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } <vul-start> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <vul-end> return rc ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <vul-start> struct mpt_ioctl_command karg <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> rc = mptctl_do_mpt_command <vul-start> = mptctl_do_mpt_command ( ioc ,\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_mpt_command ( MPT_ADAPTER * ioc, <vul-start> struct mpt_ioctl_command karg <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> rc = mptctl_do_mpt_command <vul-start> = mptctl_do_mpt_command ( ioc,\n"
  },
  {
    "id": 301,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decompress_i ( AVCodecContext * avctx , uint32_t * dst , int linesize ) { SCPRContext * s = avctx -> priv_data ; GetByteContext * gb = & s -> gb ; int cx = 0 , cx1 = 0 , k = 0 , clr = 0 ; int run , r , g , b , off , y = 0 , x = 0 , z , ret ; unsigned backstep = linesize - avctx -> width ; const int cxshift = s -> cxshift ; unsigned lx , ly , ptype ; reinit_tables ( s ) ; bytestream2_skip ( gb , 2 ) ; init_rangecoder ( & s -> rc , gb ) ; while ( k < avctx -> width + 1 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; cx1",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;\n"
  },
  {
    "id": 302,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) { <vul-start> struct dentry * dentry = path -> dentry ; <vul-end> <vul-start> struct inode * inode = dentry -> d_inode ; <vul-end> file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ; <vul-start> } <vul-end> return do_dentry_open ( file , inode , NULL , cred ) ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ) { struct <vul-end> inode * inode <vul-start> * inode = vfs_select_inode ( path -> <vul-end> dentry , file <vul-start> inode ) ; file -> f_path = * path ; <vul-end> return do_dentry_open (\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> cred ) { file -> f_path = * path ; struct inode * inode ; <vul-start> -> dentry ; <vul-end> inode = dentry <vul-start> inode ) ; <vul-end> return do_dentry_open (\n"
  },
  {
    "id": 303,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; <vul-start> static gboolean <vul-end> accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( \"GsmXsmpServer: accept_ice_connection()\" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( \"GsmXsmpServer: IceAcceptConnection returned %d\" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ; <vul-start> ice_conn -> context = client ; <vul-end> gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <vul-end> ( ice_conn ) <vul-start> ice_conn ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> GsmIceConnectionData ; static gboolean <vul-end> accept_ice_connection ( GIOChannel <vul-start> context = client ; if ( client -> priv -> is_remote_client ) gsm_store_add ( server -> priv -> client_store, gsm_client_peek_id ( client ), G_OBJECT ( client ) )\n"
  },
  {
    "id": 304,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ; <vul-start> tp -> prr_delivered += newly_acked_sacked ; <vul-end> if ( delta < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> sacked_out ) ; if ( newly_acked_sacked < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend, tp -> prior_cwnd ) - tp -> prr_out ; } else { sndcnt = min ( delta, newly_acked_sacked ) ; } <vul-start> tp -> prr_delivered += <vul-end> newly_acked_sacked ; if\n"
  },
  {
    "id": 305,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <vul-start> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <vul-end> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * aVTrans ; sqlite3_int64 <vul-end> nBytes = sizeof <vul-start> ) * ( ( sqlite3_int64 )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * aVTrans ; sqlite3_int64 <vul-end> nBytes = sizeof\n"
  },
  {
    "id": 306,
    "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 <vul-start> static void follow_dotdot ( struct nameidata * nd ) <vul-end> { if ( ! nd -> root . mnt ) set_root ( nd ) ; while ( 1 ) { struct dentry * old = nd -> path . dentry ; if ( nd -> path . dentry == nd -> root . dentry && nd -> path . mnt == nd -> root . mnt ) { break ; } if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { nd -> path . dentry = dget_parent ( nd -> path . dentry ) ; dput ( old ) ; <vul-start> break ; <vul-end> } if ( ! follow_up ( & nd -> path ) ) break ; } follow_mount ( & nd -> path ) ; nd -> inode = nd -> path . dentry -> d_inode ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-254 Fixed Code Lines are: <vul-start>     static int <vul-end> follow_dotdot ( struct <vul-start> old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <vul-start> -> d_inode ; return 0 ;\n"
    ],
    "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start>     static int <vul-end> follow_dotdot ( struct <vul-start> old ) ; return 0 <vul-end> ; } follow_mount <vul-start> -> d_inode ; return 1 ;\n"
  },
  {
    "id": 307,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <vul-start> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <vul-end> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> b. <vul-end> sf -> fv\n"
  },
  {
    "id": 308,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <vul-start> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <vul-end> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; } } if ( ! <vul-end> xdr_opaque ( xdrs <vul-start> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\\\0' ) return FALSE ; if ( memchr ( * objp , '\\\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } return ( xdr_opaque_fd ( xdrs, * objp, size ) ) ; case XDR_ENCODE : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_CLEANUP : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_CLEANUP : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_CLEANUP : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_CLEANUP : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_ENCODE : if ( size!= 0 ) return ( xdr_opaque ( xdrs, * objp, size ) ) ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ( * objp, size ) ; * objp = NULL ; return TRUE ; case XDR_FREE : if ( * objp!= NULL ) mem_free ("
  },
  {
    "id": 309,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <vul-start> in_uint16_le ( s , length ) ; <vul-end> in_uint16_le ( s , flags ) ; <vul-start> in_uint8 ( s , type ) ; <vul-end> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , \"process_secondary_order(), unhandled secondary order %d\" , type ) ; } s -> p = next_order ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * next_order ; struct stream packet = * s ; <vul-start> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( \"process_secondary_order(), next order pointer would overrun stream\" , & packet ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * next_order ; if ( length > RDP_ORDER_MAX_SIZE ) { rdp_protocol_error ( \"process_secondary_order(), stream is too large\", s ) ; } else { <vul-start> type ) ; }\n"
  },
  {
    "id": 310,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <vul-start> FreeStmt ( ( ParseCommon * ) & append ) ; <vul-end> return expr ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ParseCommon * ) <vul-end> append ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> syms ) ; if ( append -> type == ExprType_List ) append -> keysym_list. type_list = NULL ;\n"
  },
  {
    "id": 311,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <vul-start> struct va_format vaf ; <vul-end> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( \"[%s]:[%s:%d]:%d: %pV\" , dev_name ( & qedi -> pdev -> dev ) , <vul-start> nfunc , line , qedi -> host_no , & vaf ) ; <vul-end> else <vul-start> pr_warn ( \"[0000:00:00.0]:[%s:%d]: %pV\" , nfunc , line , & vaf ) ; <vul-end> ret : va_end ( va ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> struct va_format vaf <vul-end> ; va_start ( <vul-start> dev ) , func <vul-end> , line , <vul-start> ( \"[0000:00:00.0]:[%s:%d]: %pV\" , func <vul-end> , line ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> struct va_format vaf <vul-end> ; va_start ( <vul-start> dev ), func <vul-end>, line, <vul-start> ( \"[0000:00:00.0]:[%s:%d]: %pV\", func <vul-end>, line,\n"
  },
  {
    "id": 312,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd ) { if ( thread_handle < 0 || thread_handle >= MAX_THREAD ) { APPL_TRACE_ERROR ( \"%s invalid thread handle: %d\" , __func__ , thread_handle ) ; return false ; } if ( fd == - 1 ) { APPL_TRACE_ERROR ( \"%s invalid file descriptor.\" , __func__ ) ; return false ; } sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <vul-start> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <vul-end> }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start> , 0 ) )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start>, 0 ) )\n"
  },
  {
    "id": 313,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , <vul-start> vp9_reader * r ) { <vul-end> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = <vul-start> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <vul-end> <vul-start> if ( ! cm -> frame_parallel_decoding_mode ) <vul-end> ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * xd , vpx_reader <vul-end> * r ) <vul-start> ( REFERENCE_MODE ) vpx_read <vul-end> ( r , <vul-start> cm -> fc -> <vul-end> comp_inter_prob [ ctx <vul-start> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <vul-end> comp_inter [ ctx\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * xd, vpx_reader <vul-end> * r ) <vul-start> ( REFERENCE_MODE ) vpx_read <vul-end> ( r, <vul-start> cm -> fc -> <vul-end> comp_inter_prob [ ctx\n"
  },
  {
    "id": 314,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , \"vCont;c;s\" ) ; } if ( ! ( action = strtok ( g -> data , \";\" ) ) ) { return send_msg ( g , \"E01\" ) ; } while ( action = strtok ( NULL , \";\" ) ) { eprintf ( \"action: %s\\\\n\" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , \"ds\" , NULL , 0 ) < 0 ) { send_msg ( g , \"E01\" ) ; return - 1 ; } return send_msg ( g , \"OK\" ) ; case 'c' : if ( cmd_cb ( core_ptr , \"dc\" , NULL , 0 ) < 0 ) { send_msg ( g , \"E01\" ) ; return - 1 ; } return send_msg ( g , \"OK\" ) ; default : return send_msg ( g , \"E01\" ) ; } } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ; } } return - 1 ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; } } return 0 ;\n"
  },
  {
    "id": 315,
    "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 <vul-start> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <vul-end> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\\\\\' ; slash = ( isunix ) ? '\\\\\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <vul-start> if ( utf8 ) x *= 3 ; <vul-end> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <vul-start> fprintf ( stderr , \"out of memory!\\\\n\" ) ; <vul-end> return NULL ; } * name = '\\\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , \"/\" ) ; } <vul-start> while ( * fname == sep ) fname ++ ; <vul-end> <vul-start> p = & name [ strlen ( ( char * ) name ) ] ; <vul-end> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <vul-start> if ( fname >= fe ) { <vul-end> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if (",
    "golden_answers": [
      "CWE-22 Fixed Code Lines are: <vul-start>       <vul-end> char * create_output_name <vul-start> * create_output_name ( <vul-end> char * fname <vul-start> char * fname ) { char * out , * p <vul-end> ; if ( <vul-start> ; if ( ( out = malloc ( strlen ( fname ) + 1 <vul-end> ) ) ) <vul-start> ) ) { <vul-end> while ( * <vul-start> * fname == '/' || * fname == '\\\\\\\\' <vul-end> ) fname ++ <vul-start> fname ++ ; strcpy ( out , ( * fname ) ? fname : \"x\" ) ; for ( p = out ; * p ; p ++ ) <vul-end> { if ( <vul-start> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\\\\\' <vul-end> ) ) { <vul-start> ) ) { p [ 0 ] = p [ 1 ] = 'x' <vul-end> ; } } <vul-start> ; } } } return out <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> char * fname, size_t fname_size <vul-start> fname ) ; assert ( fname_size <= 4 ) ; <vul-start> ( stderr, \"out of memory!\\\\n\" ) ; free ( name <vul-end> ) ; return <vul-start> == sep ) { fname_size -- ; } <vul-end> p = & <vul-start> ) ] ; if ( fname_size < 4 ) { free ( name ) ; free ( name ) ; return NULL ; } <vul-start> { if ( fname_size <vul-end> >= fe ) <vul-start> ) ; } free ( name ) ;\n"
  },
  {
    "id": 316,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int sd_isoc_init ( struct gspca_dev * gspca_dev ) <vul-start> { <vul-end> struct usb_host_interface * alt ; int max_packet_size ; switch ( gspca_dev -> pixfmt . width ) { case 160 : max_packet_size = 450 ; break ; case 176 : max_packet_size = 600 ; break ; default : max_packet_size = 1022 ; break ; } <vul-start> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <vul-end> alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ; return 0 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> gspca_dev ) { struct usb_interface_cache * intfc ; <vul-start> break ; } intfc = <vul-end> gspca_dev -> dev <vul-start> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <vul-start> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> gspca_dev ) { struct usb_interface_cache * intfc ; <vul-start> break ; } intfc = <vul-end> gspca_dev -> dev <vul-start> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <vul-start> [ 1 ] ; if ( alt -> desc. bNumEndpoints < 1 ) return - ENODEV\n"
  },
  {
    "id": 317,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void copy_xauthority ( void ) { char * src = RUN_XAUTHORITY_FILE ; char * dest ; if ( asprintf ( & dest , \"%s/.Xauthority\" , cfg . homedir ) == - 1 ) errExit ( \"asprintf\" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , \"Error: %s is a symbolic link\\\\n\" , dest ) ; exit ( 1 ) ; } <vul-start> pid_t child = fork ( ) ; <vul-end> if ( child < 0 ) errExit ( \"fork\" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <vul-start> if ( rv ) <vul-end> fprintf ( stderr , \"Warning: cannot transfer .Xauthority in private home directory\\\\n\" ) ; else { <vul-start> fs_logger2 ( \"clone\" , dest ) ; <vul-end> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src , <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\" , dest <vul-end> ) ; unlink\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src, <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\", dest <vul-end> ) ; unlink\n"
  },
  {
    "id": 318,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static void <vul-end> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , \" [bad length %u]\" , length ) ) ; <vul-start> return ; <vul-end> } if ( ( length + 1 ) & 3 ) <vul-start> ND_PRINT ( ( ndo , \" [bad length %u]\" , length ) ) ; <vul-end> ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , \" [bad ptr %u]\" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { <vul-start> ND_PRINT ( ( ndo , \" %s\" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <vul-end> if ( ptr > len ) ND_PRINT ( ( ndo , \",\" ) ) ; <vul-start> } <vul-end> }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> ip_printroute ( netdissect_options <vul-start> ) ; return ( 0 ) <vul-start> , length ) ) ; ND_TCHECK ( cp [ 2 ] <vul-start> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <vul-start> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> ip_printroute ( netdissect_options <vul-start> ) ; return ( 0 ) <vul-start>, length ) ) ; ND_TCHECK ( cp [ 2 ] <vul-start> 4 ) { if ( ptr > len ) ND_TCHECK ( ( ndo, \",\" ) ) ; <vul-start> ) ) ; return ( 0 ) ; } return ( 1 ) ; <vul-end> }  \n"
  },
  {
    "id": 319,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <vul-start> facilities_len -= len + 1 ; <vul-end> p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <vul-start> facilities_len -= len + 1 ; <vul-end> p += len + 1 ; break ; default : printk ( KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\\\n\" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> 1 ) ; if ( len < 0 ) return 0 ; <vul-start> 1 ) ; if ( len < 0 ) return 0 ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 1 ) ; if ( len >= 0 ) <vul-start> 1 ) ; if ( len >= 0 )\n"
  },
  {
    "id": 320,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } <vul-start> m -> msg_name = address ; <vul-end> } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> err ; } if ( m -> msg_name )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err ; } memcpy ( m -> msg_name, address, sizeof ( * address ) ) ;\n"
  },
  {
    "id": 321,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <vul-start> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <vul-end> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horAcc16 ( TIFF <vul-start> / 2 ; if <vul-end> ( ( cc <vul-start> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horAcc16\" , \"%s\" , \"cc%(2*stride))!=0\" ) ; return 0 ; } <vul-end> if ( wc <vul-start> ) ; } return 1 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horAcc16 ( TIFF <vul-start> / 2 ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horAcc16\", \"%s\", \"(cc%(2*stride))!=0\" ) ; return 0 ; } <vul-end> if ( wc <vul-start> ) ; } return 1 ;\n"
  },
  {
    "id": 322,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) { const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { <vul-start> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <vul-end> free ( stream -> ebml . cue_list ) ; stream -> ebml . cue_list = NULL ; } # endif if ( ! stream -> config . write_webm ) { if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ; } fclose ( stream -> file ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> stream -> ebml ) <vul-end> ; } #\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> write_webm ) { if (! <vul-start> -> hash ) ) return\n"
  },
  {
    "id": 323,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <vul-start> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <vul-end> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; nla_strlcpy <vul-end> ( link_info . <vul-start> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; strncpy <vul-end> ( link_info. <vul-start> TIPC_NLA_LINK_NAME ] ), sizeof ( link_info. str ) - 1\n"
  },
  {
    "id": 324,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <vul-start> nfcf_poll -> sensf_res_len = * data ++ ; <vul-end> pr_debug ( \"bit_rate %d, sensf_res_len %d\\\\n\" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> sensf_res_len = min_t ( __u8 , <vul-start> * data ++ , NFC_SENSF_RES_MAXSIZE )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * data ++ ; if ( nfcf_poll -> sensf_res_len > NCI_MAX_Sensf_RES_LEN ) nfcf_poll -> sensf_res_len = NCI_MAX_SENSF_RES_LEN\n"
  },
  {
    "id": 325,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height ) <vul-end> { int i ; <vul-start> assert ( denoiser ) ; <vul-end> for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { denoiser -> yv12_running_avg [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_running_avg [ i ] ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } <vul-start> vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 , <vul-end> denoiser -> yv12_running_avg [ i ] . frame_size ) ; } denoiser -> yv12_mc_running_avg . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_mc_running_avg ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } <vul-start> vpx_memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 , <vul-end> denoiser -> yv12_mc_running_avg . frame_size ) ; <vul-start> return 0 ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , int height , int num_mb_rows , int num_mb_cols , int mode <vul-start> ( denoiser ) ; denoiser -> num_mb_cols = num_mb_cols <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> frame_size ) ; if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return <vul-end> 0 ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, int height, VP8_BUF_SIZE_T buffer_size <vul-start> assert ( denoiser ) ; memset ( denoiser -> denoise_state, 0, buffer_size <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> frame_size ) ; }\n"
  },
  {
    "id": 326,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ; <vul-start> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <vul-end> continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; <vul-start> else if ( temp_buffer < 0x120 ) <vul-end> VO ++ ; <vul-start> else if ( temp_buffer < 0x130 ) <vul-end> VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <vul-end> ) continue ; <vul-start> if ( temp_buffer >= 0x100 && temp_buffer <vul-start> else if ( temp_buffer >= 0x120 &&\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> & 0xffffff00 ) == <vul-end> 0x100 ) continue <vul-start> ( temp_buffer < 0x120U &&! ( temp_buffer & 0x130U ) <vul-end> ) VO ++ <vul-start> ( temp_buffer < 0x130U &&! ( temp_buffer & 0x1B7 ) &&! ( 0x1B9 <vul-end> < temp_buffer &&\n"
  },
  {
    "id": 327,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; <vul-start> if ( A > skb -> len - sizeof ( struct nlattr ) ) <vul-end> return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; <vul-start> if ( nla -> nla_len > A - skb -> len ) <vul-end> return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <vul-start> -> nla_len > <vul-end> skb -> len <vul-start> skb -> len - A\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> struct nlattr ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr ) <vul-start> > A - ( <vul-start> skb -> len - nla -> nla_len )\n"
  },
  {
    "id": 328,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <vul-start> unsigned short sel ; <vul-end> memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <vul-start> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <vul-end> if ( rc != X86EMUL_CONTINUE ) return rc ; <vul-start> ctxt -> _eip = 0 ; <vul-end> <vul-start> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <vul-end> <vul-start> return X86EMUL_CONTINUE ; <vul-end> }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <vul-start> ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> sel , VCPU_SREG_CS , cpl , false , & new_desc <vul-start> return rc ; rc = assign_eip_far ( ctxt <vul-end> , ctxt -> <vul-start> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <vul-end> ) ; return <vul-start> ) ; return rc ; } return rc <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> unsigned short sel ; unsigned long eip <vul-start> 2 ) ; eip = <vul-end> ctxt -> _eip <vul-start> ctxt -> _eip ; if ( eip > UINT_MAX - ctxt -> op_bytes ) return X86EMUL_CONTINUE ; memcpy ( & eip <vul-start>, sel, eip <vul-end> ) ; if <vul-start> return rc ; <vul-end> memcpy ( & <vul-start> memcpy ( & eip <vul-end>, ctxt -> <vul-start> ) ; return rc <vul-end> ; }  \n"
  },
  {
    "id": 329,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int xstateregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct fpu * fpu = & target -> thread . fpu ; struct xregs_state * xsave ; int ret ; if ( ! boot_cpu_has ( X86_FEATURE_XSAVE ) ) return - ENODEV ; if ( ( pos != 0 ) || ( count < fpu_user_xstate_size ) ) return - EFAULT ; xsave = & fpu -> state . xsave ; fpu__activate_fpstate_write ( fpu ) ; if ( boot_cpu_has ( X86_FEATURE_XSAVES ) ) { if ( kbuf ) ret = copy_kernel_to_xstate ( xsave , kbuf ) ; else ret = copy_user_to_xstate ( xsave , ubuf ) ; } else { ret = user_regset_copyin ( & pos , & count , & kbuf , & ubuf , xsave , 0 , - 1 ) ; <vul-start> } <vul-end> if ( ret ) fpstate_init ( & fpu -> state ) ; xsave -> i387 . mxcsr &= mxcsr_feature_mask ; xsave -> header . xfeatures &= xfeatures_mask ; memset ( & xsave -> header . reserved , 0 , 48 ) ; return ret ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> 1 ) ; if (! ret ) fpstate_fini ( & fpu -> state ) ;\n"
  },
  {
    "id": 330,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <vul-start> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <vul-end> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> -> cac_id , serial -> len <vul-end> ) ; SC_FUNC_RETURN\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> SC_MAX_SERIALNR ) ; if ( serial -> len > priv -> cac_id_len ) { serial -> len = priv -> cac_id_len ; }\n"
  },
  {
    "id": 331,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <vul-start> memmove ( s + j , s + qs , blen - qs ) ; <vul-end> <vul-start> j += blen - qs ; <vul-end> } buffer_string_set_length ( b , j ) ; return qs ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> 0 ) { const int qslen = blen - qs ; <vul-start> + qs , ( size_t ) qslen ) ; qs = j <vul-end> ; j += <vul-start> ; j += qslen <vul-end> ; } buffer_string_set_length\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>, s + i <vul-end>, blen - <vul-start>, blen - i <vul-end> ) ; j <vul-start> ; j += i <vul-end> ; } buffer_string_set_length\n"
  },
  {
    "id": 332,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <vul-start> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <vul-end> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) ) return - EINVAL ;\n"
  },
  {
    "id": 333,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , \"entering CDROM_DRIVE_STATUS\\\\n\" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <vul-start> if ( ( ( int ) arg >= cdi -> capacity ) ) <vul-end> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; if ( <vul-end> arg >= cdi <vul-start> cdi -> capacity <vul-end> ) return -\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> if ( ( <vul-end> arg >= cdi\n"
  },
  {
    "id": 334,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static unsigned long randomize_stack_top ( unsigned long stack_top ) { <vul-start> unsigned int random_variable = 0 ; <vul-end> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <vul-start> random_variable = get_random_int ( ) & STACK_RND_MASK ; <vul-end> random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ) { unsigned long <vul-end> random_variable = 0 <vul-start> { random_variable = ( unsigned long ) <vul-start> get_random_int ( ) ; random_variable &= <vul-end> STACK_RND_MASK ; random_variable\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> stack_top ) { long random_variable ; random_variable = get_random_long ( ) <vul-end> ; if ( <vul-start> { random_variable = random_variable_read ( ) <vul-end> ; random_variable <<=\n"
  },
  {
    "id": 335,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; <vul-start> SCSIDiskReq * r ; <vul-end> req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; <vul-start> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <vul-end> r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * req ; <vul-end> req = scsi_req_alloc <vul-start> hba_private ) ; <vul-end> return req ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * req ; <vul-end> req = scsi_req_alloc <vul-start> hba_private ) ; <vul-end> return req ;\n"
  },
  {
    "id": 336,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <vul-start> int64_t * time_stamp , int64_t * time_end_stamp , <vul-end> <vul-start> vp9_ppflags_t * flags ) { <vul-end> <vul-start> int ret = - 1 ; <vul-end> if ( pbi -> ready_for_new_data == 1 ) return ret ; <vul-start> if ( pbi -> common . show_frame == 0 ) <vul-end> return ret ; pbi -> ready_for_new_data = 1 ; <vul-start> * time_stamp = pbi -> last_time_stamp ; <vul-end> * time_end_stamp = 0 ; <vul-start> # if CONFIG_VP9_POSTPROC <vul-end> <vul-start> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <vul-end> # else <vul-start> * sd = * pbi -> common . frame_to_show ; <vul-end> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <vul-start> vp9_clear_system_state ( ) ; <vul-end> return ret ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * sd , <vul-end> vp9_ppflags_t * flags <vul-start> flags ) { VP9_COMMON * const cm = & pbi -> common ; <vul-start> - 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <vul-start> return ret ; pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <vul-end> ) return ret <vul-start> = 1 ; <vul-end> # if CONFIG_VP9_POSTPROC <vul-start> # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <vul-start> = vp9_post_proc_frame ( cm <vul-end> , sd , <vul-start> flags ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <vul-start> sd = * cm -> frame_to_show <vul-end> ; ret = <vul-start> ; # endif vpx_clear_system_state <vul-end> ( ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * sd, vpx_ppflags_t * flags, int frame_width, int frame_height, <vul-start> * time_end_stamp, vpx_ppflags_t <vul-end> * flags ) <vul-start> = - 1 ; VP9_COMMON * const cm = & pbi -> common <vul-start> ; if ( cm -> <vul-end> show_frame == 0 <vul-start> = 1 ; if (! pbi -> ready_for_new_data ) { pbi -> ready_for_new_data = 0 ; * time_stamp = 0 ; * time_end_stamp = 0 ; } else { <vul-start> = 0 ; } cm -> frame_width = pbi -> common. width ; cm -> y_height = pbi -> common. height ; sd -> uv_width = cm -> uv_width >> pbi -> common. subsampling_x ; sd -> uv_height = cm -> uv_height >> pbi -> common. subsampling_y ; <vul-start> = vp9_post_proc_frame ( cm <vul-end>, sd, <vul-start> ; # else ( void ) flags ; <vul-start> ; # endif clear_system_state ( cm <vul-end> ) ; return\n"
  },
  {
    "id": 337,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , \"%s/.asoundrc\" , cfg . homedir ) == - 1 ) errExit ( \"asprintf\" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , \"Error: %s is a symbolic link\\\\n\" , dest ) ; exit ( 1 ) ; } <vul-start> pid_t child = fork ( ) ; <vul-end> if ( child < 0 ) errExit ( \"fork\" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <vul-start> if ( rv ) <vul-end> fprintf ( stderr , \"Warning: cannot transfer .asoundrc in private home directory\\\\n\" ) ; else { <vul-start> fs_logger2 ( \"clone\" , dest ) ; <vul-end> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src , <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\" , dest <vul-end> ) ; unlink\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src, <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\", dest <vul-end> ) ; unlink\n"
  },
  {
    "id": 338,
    "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; <vul-start> oe_errno = 0 ; <vul-end> <vul-start> if ( ! sock ) <vul-end> OE_RAISE_ERRNO ( OE_EINVAL ) ; <vul-start> if ( addrlen ) <vul-end> <vul-start> addrlen_in = * addrlen ; <vul-end> if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , <vul-start> addrlen ) != OE_OK ) <vul-end> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <vul-start> done : <vul-end> return ret ; }",
    "golden_answers": [
      "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; oe_socklen_t addrlen_out = 0 ; <vul-start> ( ! sock || ! addr || ! addrlen <vul-start> OE_EINVAL ) ; <vul-end> addrlen_in = * <vul-start> = * addrlen ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <vul-start> , addrlen_in , & addrlen_out <vul-end> ) != OE_OK <vul-start> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ;\n"
    ],
    "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; oe_socklen_t addrlen_out = 0 ; <vul-start> (! sock ||! addr ||! addrlen <vul-start> OE_EINVAL ) ; <vul-end> addrlen_in = * <vul-start> = * addrlen ; if ( addrlen_in >= OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) <vul-start>, addrlen_in, & addrlen_out <vul-end> )!= OE_OK <vul-start> ) ; } if ( addrlen_out >= OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ;\n"
  },
  {
    "id": 339,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { <vul-start> return KRB5KDC_ERR_BADOPTION ; <vul-end> } if ( ! krb5_principal_compare ( kdc_context , server -> princ , <vul-start> server_princ ) ) { <vul-end> return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = \"EVIDENCE_TKT_NOT_FORWARDABLE\" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = \"NOT_ALLOWED_TO_DELEGATE\" ; return errcode ; } return 0 ; }",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> ) ) { * status = \"INVALID_S4U2PROXY_OPTIONS\" ; <vul-start> ) ) { * status = \"EVIDENCE_TICKET_MISMATCH\" ;\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ) ) { * status = \"NOT_SUPPORTED\" ; return KRB5_TKT_NOT_FORWARDABLE\" <vul-end> ; } if <vul-start> server_princ ) ) return KRB5KDC_ERR_SERVER_NOMATCH ; <vul-end> if (!\n"
  },
  {
    "id": 340,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <vul-start> ret = vfs_dedupe_file_range ( file , same ) ; <vul-end> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> out ; } same -> dest_count = count ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } ret = file_dedupe_file_range ( file, same, count <vul-end> ) ; if\n"
  },
  {
    "id": 341,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static ssize_t rpmsg_eptdev_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct rpmsg_eptdev * eptdev = filp -> private_data ; size_t len = iov_iter_count ( from ) ; void * kbuf ; int ret ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) <vul-start> return - EFAULT ; <vul-end> if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) { ret = - ERESTARTSYS ; goto free_kbuf ; } if ( ! eptdev -> ept ) { ret = - EPIPE ; goto unlock_eptdev ; } if ( filp -> f_flags & O_NONBLOCK ) ret = rpmsg_trysend ( eptdev -> ept , kbuf , len ) ; else ret = rpmsg_send ( eptdev -> ept , kbuf , len ) ; unlock_eptdev : mutex_unlock ( & eptdev -> ept_lock ) ; free_kbuf : kfree ( kbuf ) ; return ret < 0 ? ret : len ; }",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> from ) ) { ret = <vul-end> - EFAULT ; <vul-start> - EFAULT ; goto free_kbuf ; }\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> from ) ) { ret = <vul-end> - EFAULT ; <vul-start> - EFAULT ; goto free_kbuf ; }\n"
  },
  {
    "id": 342,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int imagetobmp ( opj_image_t * image , const char * outfile ) { int w , h ; int i , pad ; FILE * fdest = NULL ; int adjustR , adjustG , adjustB ; if ( image -> comps [ 0 ] . prec < 8 ) { fprintf ( stderr , \"Unsupported number of components: %d\\\\n\" , image -> comps [ 0 ] . prec ) ; return 1 ; } if ( image -> numcomps >= 3 && image -> comps [ 0 ] . dx == image -> comps [ 1 ] . dx && image -> comps [ 1 ] . dx == image -> comps [ 2 ] . dx && image -> comps [ 0 ] . dy == image -> comps [ 1 ] . dy && image -> comps [ 1 ] . dy == image -> comps [ 2 ] . dy && image -> comps [ 0 ] . prec == image -> comps [ 1 ] . prec && image -> comps [ 1 ] . prec == image -> comps [ 2 ] . prec ) { fdest = fopen ( outfile , \"wb\" ) ; if ( ! fdest ) { fprintf ( stderr , \"ERROR -> failed to open %s for writing\\\\n\" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , \"BM\" ) ; fprintf ( fdest ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> { for ( pad = ( <vul-end> w % 4\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { if ( w == 0 || h == 0 ) { fprintf ( stderr, \"ERROR -> failed to open %s for writing\\\\n\", outfile ) ; return 1 ; } <vul-start> ( fdest, \"%c%c%c%c\" <vul-end>, ( OPJ_UINT8 <vul-start> ( fdest, \"%c%c%c%c\" <vul-end>, ( OPJ_UINT8 <vul-start> ( fdest, \"%c%c%c%c\" <vul-end>, ( OPJ_UINT8\n"
  },
  {
    "id": 343,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , \"Incorrect TPDU length indicator.\" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , \"Failed to parse routing token or cookie.\" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , \"Incorrect negotiation request type %\" PRIu8 \"\" , type ) ; return FALSE ; } <vul-start> nego_process_negotiation_request ( nego , s ) ; <vul-end> } return tpkt_ensure_stream_consumed ( s , length ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> FALSE ; } if ( ! <vul-start> , s ) ) return FALSE\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> FALSE ; } if (! <vul-start>, s ) ) return FALSE\n"
  },
  {
    "id": 344,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <vul-start> DPRINTF ( \"Data ready tag=0x%x len=%zd\\\\n\" , r -> req . tag , r -> iov . iov_len ) ; <vul-end> <vul-start> n = r -> iov . iov_len / 512 ; <vul-end> r -> sector += n ; r -> sector_count -= n ; <vul-start> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <vul-end> }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , r -> qiov . size <vul-end> ) ; n <vul-start> = r -> qiov . size <vul-end> / 512 ; <vul-start> , r -> qiov . size <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, r -> iov. size <vul-end> ) ; n <vul-start> = r -> iov. size <vul-end> / 512 ; <vul-start>, r -> iov. size <vul-end> ) ; }\n"
  },
  {
    "id": 345,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 asmlinkage long sys_oabi_semtimedop ( int semid , struct oabi_sembuf __user * tsops , unsigned nsops , const struct timespec __user * timeout ) { struct sembuf * sops ; struct timespec local_timeout ; long err ; int i ; <vul-start> if ( nsops < 1 ) <vul-end> return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops ) return - ENOMEM ; err = 0 ; for ( i = 0 ; i < nsops ; i ++ ) { __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; tsops ++ ; } if ( timeout ) { err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; timeout = & local_timeout ; } if ( err ) { err = - EFAULT ; } else { mm_segment_t fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; err = sys_semtimedop ( semid , sops , nsops , timeout ) ; set_fs ( fs ) ; } kfree ( sops ) ; return err ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> nsops < 1 || nsops > SEMOPM\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> nsops < 1 ||! access_ok ( VERIFY_WRITE, tsops, nsops\n"
  },
  {
    "id": 346,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void http_splitheader ( struct http * hp , int req ) { char * p , * q , * * hh ; int n ; char buf [ 20 ] ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; if ( req ) { memset ( hp -> req , 0 , sizeof hp -> req ) ; hh = hp -> req ; } else { memset ( hp -> resp , 0 , sizeof hp -> resp ) ; hh = hp -> resp ; } n = 0 ; p = hp -> rxbuf ; while ( vct_islws ( * p ) ) p ++ ; hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <vul-start> assert ( ! vct_iscrlf ( * p ) ) ; <vul-end> * p ++ = '\\\\0' ; while ( vct_issp ( * p ) ) p ++ ; <vul-start> assert ( ! vct_iscrlf ( * p ) ) ; <vul-end> hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <vul-start> if ( vct_iscrlf ( * p ) ) { <vul-end> hh [ n ++ ] = NULL ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\\\0' ; } else { * p ++ = '\\\\0' ; while ( vct_issp ( * p ) ) p ++ ; hh [ n ++ ] = p ; <vul-start> while ( ! vct_iscrlf ( * p ) ) <vul-end>",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ( vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ( vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) )\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>! vct_iscrlf ( <vul-end> p ) ) <vul-start>! vct_iscrlf ( <vul-end> p ) ) <vul-start>! vct_iscrlf ( <vul-end> p ) ) <vul-start>! vct_iscrlf ( <vul-end> p ) )\n"
  },
  {
    "id": 347,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; <vul-start> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <vul-end> <vul-start> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <vul-end> readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; <vul-start> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <vul-end> if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <vul-start> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <vul-end> , 1 ) <vul-start> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <vul-end> mpu -> dev <vul-start> + JQS_wHead ) ; } out : <vul-end> spin_unlock_irqrestore ( &\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + MIDQ_DATA_BUFF ; u16 wTmp ; <vul-start> flags ) ; wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; if ( wTmp > <vul-end> mpu -> dev <vul-start> dev -> MIDQ <vul-end> ) ) snd_rawmidi_receive <vul-start> 1 ) ; <vul-end> } spin_unlock_irqrestore (\n"
  },
  {
    "id": 348,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <vul-start> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <vul-end> <vul-start> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <vul-end> <vul-start> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <vul-end> { } <vul-start> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <vul-end> usleep ( 5 ) ; <vul-start> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <vul-end> }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_EPAR <vul-end> , 0x40 | <vul-start> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <vul-end> ) ; while <vul-start> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <vul-end> ) != 0 <vul-start> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <vul-end> ) ; usleep <vul-start> ( dm9000ReadReg ( DM9000_EPDRH <vul-end> ) << 8 <vul-start> | dm9000ReadReg ( DM9000_EPDRL <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_EPAR <vul-end>, 0x40 | <vul-start> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <vul-end> ) ; while <vul-start> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <vul-end> )!= 0 <vul-start> } dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS <vul-end> ) ; usleep <vul-start> ( dm9000ReadReg ( DM9000_EPDRH <vul-end> ) << 8 <vul-start> | dm9000ReadReg ( DM9000_EPDRL ) << 8 ) | dm9000ReadReg ( DM9000_EPDRL <vul-end> ) ; }\n"
  },
  {
    "id": 349,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <vul-start> int pkt_len ; <vul-end> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <vul-start> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <vul-end> if ( pkt_len == - 1 ) return FALSE ; <vul-start> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <vul-end> err_info ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> FALSE ; } return parse_cosine_packet <vul-end> ( wth -> <vul-start> , phdr , buf , line <vul-end> , err ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> FALSE ; } if ( <vul-end> parse_cosine_hex_dump ( wth <vul-start>, buf, FALSE, err_info ) ) return FALSE <vul-end> ; }  \n"
  },
  {
    "id": 350,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ParseDateTime ( char * timestr , char * lowstr , char * * field , int * ftype , int * numfields , char * * endstr ) { int nf = 0 ; char * lp = lowstr ; * endstr = timestr ; while ( * ( * endstr ) != '\\\\0' ) { <vul-start> field [ nf ] = lp ; <vul-end> if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == ':' ) { ftype [ nf ] = DTK_TIME ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; * lp ++ = * ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <vul-start> nf ++ ; <vul-end> } * numfields\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> '\\\\0' ) { if ( nf >= MAXDATEFIELDS ) return - 1 ; <vul-start> nf ++ ; * lp ++ = '\\\\0' ;\n"
  },
  {
    "id": 351,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case ' ' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <vul-start> int a = getnum ( L , fmt , MAXALIGN ) ; <vul-end> if ( ! isp2 ( a ) ) luaL_error ( L , \"alignment %d is not a power of 2\" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , \"invalid format option \\'%c\\'\" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> = getnum ( <vul-end> fmt , MAXALIGN\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = getnum ( L,\n"
  },
  {
    "id": 352,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) { <vul-start> size_t maxlen = 3 * len ; <vul-end> struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL scheme: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL query: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL fragment: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 3 * len + 8\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_t maxlen = 5 <vul-end> * len ;\n"
  },
  {
    "id": 353,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; <vul-start> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <vul-end> u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ; <vul-start> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <vul-end> <vul-start> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <vul-end> writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; <vul-start> } <vul-end> inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <vul-end> = readw ( <vul-start> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <vul-end> readw ( chip <vul-start> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <vul-end> , chip -> <vul-start> ) ; } out :\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + DSPQ_DATA_BUFF ; u16 wTail = <vul-end> readw ( chip <vul-start> + JQS_wHead ) ; if ( wTail <vul-start> ; wTmp = wTail <vul-end> + 1 ; <vul-start> ( wTmp > wTail <vul-end> ) writew ( <vul-start> JQS_wHead ) ; wTail = wTmp ;\n"
  },
  {
    "id": 354,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ; <vul-start> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <vul-end> <vul-start> spin_lock_irq ( & child -> sighand -> siglock ) ; <vul-end> WARN_ON_ONCE ( task_is_stopped ( child ) ) ; <vul-start> if ( ignore_state || ( task_is_traced ( child ) && <vul-end> ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) <vul-start> ret = 0 ; <vul-end> spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ; <vul-start> if ( ! ret && ! ignore_state ) <vul-end> <vul-start> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <vul-end> return ret ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; if ( <vul-end> child -> ptrace <vul-start> child -> ptrace <vul-end> && child -> <vul-start> current ) { WARN_ON ( child -> state == __TASK_TRACED <vul-end> ) ; if <vul-start> ( ignore_state || ptrace_freeze_traced ( child <vul-end> ) ) ret <vul-start> ret = 0 <vul-end> ; } read_unlock <vul-start> ! ignore_state ) { if ( ! <vul-end> wait_task_inactive ( child <vul-start> ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <vul-end> - ESRCH ; <vul-start> - ESRCH ; } }\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> current ) { struct ptrace_time val ; int old_ret ; <vul-start> ) ) ; raw_read_lock ( & old_ret ) ; val. tv_sec = child -> last_rtime ; val. tv_nsec = child -> last_rtime ; <vul-start> ) ) ) { if (! ret &&! current_is_traced ( child ) && ( child -> jobctl & JOBCTL_LISTENING ) ) ret = 0 ; raw_read_unlock ( & old_ret ) ; } raw_read_unlock ( & old_ret <vul-end> ) ; } <vul-start>! ignore_state ) { if (! ret &&! current_is_traced ( child ) && ( child -> jobctl & JOBCTL_LISTENING ) ) ret = 0 ; spin_unlock_irq ( & child -> sighand -> siglock ) ; } <vul-end> ret = wait_task_inactive <vul-start>, TASK_TRACED ) ; raw_read_unlock ( & old_ret )\n"
  },
  {
    "id": 355,
    "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <vul-start> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <vul-end> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <vul-start> if ( error == 0 ) <vul-end> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , \"\" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }",
    "golden_answers": [
      "CWE-285 Fixed Code Lines are: <vul-start> { error = posix_acl_update_mode ( inode <vul-end> , & inode <vul-start> inode -> i_mode , & acl ) ; if ( error ) return error ; <vul-end> inode -> i_ctime <vul-start> inode ) ; <vul-end> } break ;\n"
    ],
    "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> { error = posix_acl_update_mode ( inode <vul-end>, & inode <vul-start> inode -> i_mode, & acl ) ; if ( error ) return error ; <vul-end> mark_inode_dirty ( inode <vul-start> inode ) ; <vul-end> } break ;\n"
  },
  {
    "id": 356,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <vul-start> int i ; <vul-end> int j ; jas_seqent_t * rowstart ; <vul-start> int rowstep ; <vul-end> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> n ) { jas_matind_t i ; jas_matind_t <vul-end> j ; jas_seqent_t <vul-start> * rowstart ; jas_matind_t <vul-end> rowstep ; jas_seqent_t\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> n ) { jas_matind_t i ; jas_matind_t <vul-end> j ; jas_seqent_t <vul-start> * rowstart ; jas_matind_t <vul-end> rowstep ; jas_seqent_t\n"
  },
  {
    "id": 357,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void copy_fields ( const FieldMatchContext * fm , AVFrame * dst , const AVFrame * src , int field ) { int plane ; <vul-start> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <vul-end> av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> src -> data [ plane ] && src -> linesize\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> src -> data [ plane ] && src -> linesize\n"
  },
  {
    "id": 358,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( \"Attempt to release TCP socket in state %d %p\\\\n\" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( \"Attempt to release alive inet socket %p\\\\n\" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ; <vul-start> kfree ( inet -> opt ) ; <vul-end> dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <vul-end> ) ; dst_release\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sk_forward_alloc ) ; RCU_INIT_POINTER ( sk -> sk_omem_alloc, 0 ) ;\n"
  },
  {
    "id": 359,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static identifier new_identifier ( const char * n , struct compiling * c ) { PyObject * id = PyUnicode_DecodeUTF8 ( n , strlen ( n ) , NULL ) ; if ( ! id ) return NULL ; assert ( PyUnicode_IS_READY ( id ) ) ; if ( ! PyUnicode_IS_ASCII ( id ) ) { PyObject * id2 ; <vul-start> if ( ! c -> c_normalize && ! init_normalization ( c ) ) { <vul-end> Py_DECREF ( id ) ; return NULL ; } <vul-start> PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , id ) ; <vul-end> <vul-start> id2 = PyObject_Call ( c -> c_normalize , c -> c_normalize_args , NULL ) ; <vul-end> Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; id = id2 ; } PyUnicode_InternInPlace ( & id ) ; if ( PyArena_AddPyObject ( c -> c_arena , id ) < 0 ) { Py_DECREF ( id ) ; return NULL ; } return id ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> * id2 ; PyObject * form ; PyObject * args [ 2 ] ; _Py_IDENTIFIER ( NFKC ) ; <vul-start> NULL ; } form = _PyUnicode_FromId ( & PyId_NFKC ) ; if ( form == NULL ) { Py_DECREF ( id ) ; return NULL ; } args [ 0 ] = form ; args [ 1 ] = id ; id2 = _PyObject_FastCall <vul-end> ( c -> <vul-start> -> c_normalize , args , 2 ) ; Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; if ( ! PyUnicode_Check ( id2 ) ) { PyErr_Format ( PyExc_TypeError , \"unicodedata.normalize() must return a string, not \" \"%.200s\" , Py_TYPE ( id2 ) -> tp_name ) ; Py_DECREF ( id2 ) ; return NULL ; } <vul-end> id = id2\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>! c -> c_method_body &&! PyObject_Call ( c -> c_method_body, c -> c_method_body, NULL ) ) { Py_DECREF ( id ) ; return NULL ; } if (! c -> <vul-start> init_normalization ( c, id ) ) { Py_DECREF ( id ) ; return NULL ; } PyTuple_SET_ITEM ( c -> c_normalize_args, 1, id ) ; id2 = PyObject_Call ( c -> c_normalize, c -> c_normalize_args, NULL ) ; Py_DECREF ( id ) ; if (! id2 ) return NULL ; id = id2 ; } PyUnicode_InternInPlace ( & id ) ; if ( PyArena_AddPyObject ( c -> c_arena, id ) < 0 ) { <vul-end> return NULL ; <vul-start> NULL ; } <vul-end> if (! <vul-start> c -> c_normalize ) { Py_DECREF ( id ) ; return NULL ; } if (! PyObject_Call ( c -> c_normalize, c -> c_normalize_args, NULL ) ; Py_DECREF ( id ) ; if (! id2 ) return NULL ; id = id2 ; } PyUnicode_InternInPlace ( & id ) ; if ( ( <vul-end> c -> c_normalize <vul-start> c -> c_normalize ) < 0 ) { <vul-end> return NULL ; <vul-start> -> c_normalize_args, <vul-end> NULL ) ;\n"
  },
  {
    "id": 360,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <vul-start> Huff_transmit ( & huff , ch , seq ) ; <vul-end> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ch , seq , size << 3\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i ] ; if (! <vul-start>, seq ) ) { return ; } <vul-end> Huff_addRef ( &\n"
  },
  {
    "id": 361,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <vul-start> if ( perf_event_overflow ( event , 0 , data , regs ) ) <vul-end> mipspmu -> disable_event ( idx ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ( event , <vul-end> data , regs\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ( event, <vul-end> data, regs\n"
  },
  {
    "id": 362,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int sctp_setsockopt_auto_asconf ( struct sock * sk , char __user * optval , unsigned int optlen ) { int val ; struct sctp_sock * sp = sctp_sk ( sk ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; if ( ! sctp_is_ep_boundall ( sk ) && val ) return - EINVAL ; if ( ( val && sp -> do_auto_asconf ) || ( ! val && ! sp -> do_auto_asconf ) ) return 0 ; <vul-start> if ( val == 0 && sp -> do_auto_asconf ) { <vul-end> list_del ( & sp -> auto_asconf_list ) ; sp -> do_auto_asconf = 0 ; } else if ( val && ! sp -> do_auto_asconf ) { list_add_tail ( & sp -> auto_asconf_list , & sock_net ( sk ) -> sctp . auto_asconf_splist ) ; sp -> do_auto_asconf = 1 ; } <vul-start> return 0 ; <vul-end> }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <vul-start> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> return 0 ; spin_lock ( & sock_net ( sk ) -> sctp. addr_wq_lock ) ; <vul-start> 1 ; } spin_unlock ( & sock_net ( sk ) -> sctp. addr_wq_lock ) ;\n"
  },
  {
    "id": 363,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , <vul-end> int tx_type ) { const transform_2d IHT_4 [ ] = { <vul-start> { idct4 , idct4 } , <vul-end> { iadst4 , idct4 } , { idct4 , iadst4 } , { iadst4 , iadst4 } } ; int i , j ; <vul-start> int16_t out [ 4 * 4 ] ; <vul-end> <vul-start> int16_t * outptr = out ; <vul-end> <vul-start> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <vul-end> for ( i = 0 ; i < 4 ; ++ i ) { IHT_4 [ tx_type ] . rows ( input , outptr ) ; input += 4 ; outptr += 4 ; } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j * 4 + i ] ; IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ; <vul-start> for ( j = 0 ; j < 4 ; ++ j ) <vul-end> <vul-start> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) <vul-end> <vul-start> + dest [ j * stride + i ] ) ; <vul-end> } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht4x4_16_add_c ( const tran_low_t <vul-end> * input , <vul-start> = { { idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c <vul-end> } } ; <vul-start> , j ; tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; } <vul-end> } }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_4x4_add_c ( const tran_low_t <vul-end> * input, <vul-start> = { { idct4, idct4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { idct4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { idct4, idct4 }, { iadst4, iadst4 }, { idct4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 }, { iadst4, iadst4 <vul-end> } } ; <vul-start>, j ; tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( ROUND_POWER_OF_TWO ( temp_out [ j ], 4 ) + <vul-start> ] ) ; }\n"
  },
  {
    "id": 364,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 stmt_ty <vul-start> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <vul-end> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , \"field value is required for Assign\" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <vul-start> p -> lineno = lineno ; <vul-end> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value , string type_comment , <vul-start> ; p -> v . Assign . type_comment = type_comment ; p ->\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value, string type_comment, <vul-start> ; p -> v. Assign. type_comment = type_comment ; p ->\n"
  },
  {
    "id": 365,
    "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( \"Compose path from cwd: %s, arg: %s\" , ctrl -> cwd , path ? : \"\" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , \"/\" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , \"//\" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( \"Server path from CWD: %s\" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( \"Resulting non-chroot path: %s\" , dir ) ; } if ( ! stat (",
    "golden_answers": [
      "CWE-22 Fixed Code Lines are: <vul-start> && strncmp ( rpath <vul-end> , home ,\n"
    ],
    "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start>! chrooted && (! home || <vul-start> home ) ) )\n"
  },
  {
    "id": 366,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <vul-start> u64 nr , int nmi , <vul-end> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <vul-start> perf_swevent_event ( event , nr , nmi , data , regs ) ; <vul-end> } end : rcu_read_unlock ( ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , u64 nr <vul-end> , struct perf_sample_data <vul-start> , nr , <vul-end> data , regs\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> u64 nr, <vul-end> struct perf_sample_data * <vul-start>, nr, <vul-end> data, regs\n"
  },
  {
    "id": 367,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , struct mount * source_mnt , struct hlist_head * tree_list ) { struct mount * m , * n ; int ret = 0 ; user_ns = current -> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; <vul-start> last_source = source_mnt ; <vul-end> mp = dest_mp ; list = tree_list ; dest_master = dest_mnt -> mnt_master ; for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { ret = propagate_one ( n ) ; if ( ret ) goto out ; } for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; m = next_group ( m , dest_mnt ) ) { n = m ; do { ret = propagate_one ( n ) ; if ( ret ) goto out ; n = next_peer ( n ) ; } while ( n != m ) ; } out : read_seqlock_excl ( & mount_lock ) ; hlist_for_each_entry ( n , tree_list , mnt_hash ) { m = n -> mnt_parent ; if ( m -> mnt_master != dest_mnt -> mnt_master ) CLEAR_MNT_MARK ( m -> mnt_master ) ; } read_sequnlock_excl ( & mount_lock ) ; return ret ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> = dest_mnt ; first_source = source_mnt ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> last_source = source_mnt ; last_mount = dest_mnt\n"
  },
  {
    "id": 368,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <vul-start> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <vul-end> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) break ; <vul-end> rinfo [ val\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) break ; memset <vul-end> ( & rinfo\n"
  },
  {
    "id": 369,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <vul-start> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <vul-end> <vul-start> flush_rq -> tag = first_rq -> tag ; <vul-end> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <vul-start> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> mq_ops ) { struct request_queue * q = first_rq -> mq_ctx -> q ; struct request_tag * tag = first_rq -> tag ; <vul-start> -> mq_ctx = q -> mq_ctx -> ctx ; tag -> start_io = flush_end_io ; <vul-start> -> tag = <vul-end> tag ; }\n"
  },
  {
    "id": 370,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( \"sock=%p sk=%p len=%zu flags=%d\\\\n\" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> return rc ; <vul-end> copied = skb\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> return rc ; <vul-end> copied = skb\n"
  },
  {
    "id": 371,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctr_id , va_list args ) { <vul-end> # if CONFIG_VP9_POSTPROC <vul-start> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <vul-end> ( void ) ctr_id ; if ( config != NULL ) { ctx -> preview_ppcfg = * config ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; <vul-start> ( void ) ctr_id ; <vul-end> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * ctx , <vul-end> va_list args ) <vul-start> vp8_postproc_cfg_t * ) <vul-end> ; if ( <vul-start> ( void ) <vul-end> args ; return\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx, <vul-end> va_list args ) <vul-start> vp8_postproc_cfg_t * ) <vul-end> ; if ( <vul-start> ( void ) <vul-end> args ; return\n"
  },
  {
    "id": 372,
    "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp ; <vul-end> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }",
    "golden_answers": [
      "CWE-665 Fixed Code Lines are: <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp = { }\n"
    ],
    "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp = { }\n"
  },
  {
    "id": 373,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; <vul-start> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <vul-end> if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> path, O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY, mode <vul-end> ) ; if\n"
  },
  {
    "id": 374,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <vul-start> u16 offset = sizeof ( struct ipv6hdr ) ; <vul-end> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <vul-start> switch ( * * nexthdr ) { <vul-end> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <vul-start> offset += ipv6_optlen ( exthdr ) ; <vul-end> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> nexthdr ) { unsigned int <vul-end> offset = sizeof <vul-start> * exthdr ; unsigned int len ; <vul-start> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <vul-end> ; * nexthdr\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ( struct ipv6hdr ) ; struct ipv6_opt_hdr * exthdr_end = NULL <vul-end> ; switch ( <vul-start> * exthdr ; if ( offset >= packet_len ) return - EINVAL ; <vul-start> offset ) ; if ( exthdr_end < offset ) return - EINVAL ;\n"
  },
  {
    "id": 375,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <vul-start> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <vul-end> }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> h_dport ; } minfo . flags = 0 ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> h_dport ; } minfo. op_errno = 0 ;\n"
  },
  {
    "id": 376,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ip_setup_cork ( struct sock * sk , struct inet_cork * cork , struct ipcm_cookie * ipc , struct rtable * * rtp ) { struct inet_sock * inet = inet_sk ( sk ) ; <vul-start> struct ip_options * opt ; <vul-end> struct rtable * rt ; opt = ipc -> opt ; if ( opt ) { if ( cork -> opt == NULL ) { cork -> opt = kmalloc ( sizeof ( struct ip_options ) + 40 , sk -> sk_allocation ) ; if ( unlikely ( cork -> opt == NULL ) ) return - ENOBUFS ; } <vul-start> memcpy ( cork -> opt , opt , sizeof ( struct ip_options ) + opt -> optlen ) ; <vul-end> cork -> flags |= IPCORK_OPT ; cork -> addr = ipc -> addr ; } rt = * rtp ; if ( unlikely ( ! rt ) ) return - EFAULT ; * rtp = NULL ; cork -> fragsize = inet -> pmtudisc == IP_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; cork -> dst = & rt -> dst ; cork -> length = 0 ; cork -> tx_flags = ipc -> tx_flags ; cork -> page = NULL ; cork -> off = 0 ; return 0 ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu <vul-end> * opt ; <vul-start> -> opt , & opt -> <vul-start> + opt -> opt .\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu * old, <vul-end> * opt ; <vul-start> ENOBUFS ; } old = rcu_dereference_protected ( cork -> opt, sock_owned_by_user ( sk ) ) ; <vul-start>, opt, old -> opt. <vul-end> optlen ) ;\n"
  },
  {
    "id": 377,
    "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <vul-start> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <vul-end> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , \"w\" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , \"failed to set %s (%u) for %s: %s\" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , \"%u\" , val ) ; fclose ( fp ) ; return 0 ; }",
    "golden_answers": [
      "CWE-22 Fixed Code Lines are: <vul-start> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , \"..\" ) || strchr ( name , '/'\n"
    ],
    "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> ( spath ), \"%s\", iface ) >= ( <vul-end> sizeof ( spath\n"
  },
  {
    "id": 378,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir ) <vul-start> { <vul-end> memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & xp -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & xp -> curlft , sizeof ( p -> curlft ) ) ; p -> priority = xp -> priority ; p -> index = xp -> index ; p -> sel . family = xp -> family ; p -> dir = dir ; p -> action = xp -> action ; p -> flags = xp -> flags ; p -> share = XFRM_SHARE_ANY ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> dir ) { memset ( p , 0 , sizeof ( * p ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> dir ) { memset ( p, 0, sizeof ( * p ) ) ;\n"
  },
  {
    "id": 379,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int traceDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; route -> trace = httpCreateTrace ( route -> trace ) ; for ( option = stok ( sclone ( value ) , \" \\\\t\" , & tok ) ; option ; option = stok ( 0 , \" \\\\t\" , & tok ) ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"content\" ) ) { httpSetTraceContentSize ( route -> trace , ( ssize ) getnum ( ovalue ) ) ; } else { httpSetTraceEventLevel ( route -> trace , option , atoi ( ovalue ) ) ; } } return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
  },
  {
    "id": 380,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( \"\\\\n\" , config -> errors ) ; ptr += cut + 1 ; <vul-start> len -= cut ; <vul-end> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> len -= cut + 1\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> len -= cut + 1\n"
  },
  {
    "id": 381,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , <vul-end> int tx_type ) { int i , j ; <vul-start> int16_t out [ 8 * 8 ] ; <vul-end> <vul-start> int16_t * outptr = out ; <vul-end> <vul-start> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <vul-end> const transform_2d ht = IHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { ht . rows ( input , outptr ) ; input += 8 ; outptr += 8 ; } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j * 8 + i ] ; ht . cols ( temp_in , temp_out ) ; <vul-start> for ( j = 0 ; j < 8 ; ++ j ) <vul-end> <vul-start> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <vul-end> <vul-start> + dest [ j * stride + i ] ) ; <vul-end> } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht8x8_64_add_c ( const tran_low_t <vul-end> * input , <vul-start> , j ; tran_low_t <vul-end> out [ 8 <vul-start> 8 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 8 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } <vul-end> } }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht8x8_64_add_c ( const tran_low_t <vul-end> * input, <vul-start>, j ; tran_low_t <vul-end> out [ 8 <vul-start> 8 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 8 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ], ROUND_POWER_OF_TWO ( temp_out [ j ], 5 ) ) ; } <vul-end> } }  \n"
  },
  {
    "id": 382,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void cib_remote_connection_destroy ( gpointer user_data ) { <vul-start> cib_client_t * client = user_data ; <vul-end> if ( client == NULL ) { return ; } crm_trace ( \"Cleaning up after client disconnect: %s/%s\" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( \"Client %s not found in the hashtable\" , client -> name ) ; } } crm_trace ( \"Destroying %s (%p)\" , client -> name , user_data ) ; num_clients -- ; crm_trace ( \"Num unfree\\'d clients: %d\" , num_clients ) ; <vul-start> free ( client -> name ) ; <vul-end> free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; <vul-start> free ( client ) ; <vul-end> crm_trace ( \"Freed the cib client\" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> client = user_data ; int csock = 0 <vul-start> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <vul-start> free ( client -> recv_buf ) ; free ( client\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> user_data ) { remote_connection_t * remote_client = user_data ; <vul-start> client = user_data ; int i <vul-start> num_clients ) ; for ( i = 0 ; i < num_clients ; i ++ ) { free ( client -> name ) ; free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; free ( client ) ; free ( client ) ; } <vul-start> free ( client <vul-end> ) ; crm_trace\n"
  },
  {
    "id": 383,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <vul-start> len = file ? file -> size : 4096 ; <vul-end> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> len = file && file -> size > 0\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> err ; } if ( file && ( <vul-end> file? file <vul-start> size : 4096 ) < 0 ) goto err\n"
  },
  {
    "id": 384,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 mod_ty PyAST_obj2mod ( PyObject * ast , PyArena * arena , int mode ) { mod_ty res ; PyObject * req_type [ 3 ] ; <vul-start> char * req_name [ ] = { \"Module\" , \"Expression\" , \"Interactive\" } ; <vul-end> int isinstance ; req_type [ 0 ] = ( PyObject * ) Module_type ; req_type [ 1 ] = ( PyObject * ) Expression_type ; req_type [ 2 ] = ( PyObject * ) Interactive_type ; <vul-start> assert ( 0 <= mode && mode <= 2 ) ; <vul-end> if ( ! init_types ( ) ) return NULL ; isinstance = PyObject_IsInstance ( ast , req_type [ mode ] ) ; if ( isinstance == - 1 ) return NULL ; if ( ! isinstance ) { PyErr_Format ( PyExc_TypeError , \"expected %s node, got %.400s\" , req_name [ mode ] , Py_TYPE ( ast ) -> tp_name ) ; return NULL ; } if ( obj2ast_mod ( ast , & res , arena ) != 0 ) return NULL ; else return res ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> \"Expression\" , \"Interactive\" , \"FunctionType\" <vul-start> && mode <= 3 <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] = { \"Expression\", \"Interactive\", \"Module\" <vul-end> } ; int <vul-start> <= mode && ( <vul-start> mode <= 2 ) || ( mode == 3 && PyObject_CallMethod ( ast, \"get_global\", NULL )!= NULL )\n"
  },
  {
    "id": 385,
    "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 static int remarkupvals ( global_State * g ) { lua_State * thread ; lua_State * * p = & g -> twups ; int work = 0 ; while ( ( thread = * p ) != NULL ) { work ++ ; lua_assert ( ! isblack ( thread ) ) ; if ( isgray ( thread ) && thread -> openupval != NULL ) p = & thread -> twups ; else { UpVal * uv ; <vul-start> * p = thread -> twups ; <vul-end> thread -> twups = thread ; for ( uv = thread -> openupval ; uv != NULL ; uv = uv -> u . open . next ) { <vul-start> work ++ ; <vul-end> if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ; } } } return work ; }",
    "golden_answers": [
      "CWE-763 Fixed Code Lines are: <vul-start> * uv ; lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <vul-start> next ) { lua_assert ( getage ( uv ) <= getage ( thread ) ) ;\n"
    ],
    "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start> * uv ; if (! iswhite ( thread ) ) markvalue ( g, thread -> openupval ) ; <vul-start> next ) { <vul-end> if (!\n"
  },
  {
    "id": 386,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <vul-start> px -> ft -> data = px ; <vul-end> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( ! px -> ft ) { return FALSE ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( px -> ft == NULL ) return FALSE ;\n"
  },
  {
    "id": 387,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int bta_co_rfc_data_outgoing_size ( void * user_data , int * size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; * size = 0 ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <vul-start> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <vul-end> ret = true ; } else { LOG_ERROR ( \"%s unable to determine bytes remaining to be read on fd %d: %s\" , __func__ , slot -> fd , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> FIONREAD , size )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> FIONREAD, size )\n"
  },
  {
    "id": 388,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <vul-end> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row , mv -> col - ref -> col } ; const MV_JOINT_TYPE j = vp9_get_mv_joint ( & diff ) ; usehp = usehp && vp9_use_mv_hp ( ref ) ; vp9_write_token ( w , vp9_mv_joint_tree , mvctx -> joints , & mv_joint_encodings [ j ] ) ; if ( mv_joint_vertical ( j ) ) encode_mv_component ( w , diff . row , & mvctx -> comps [ 0 ] , usehp ) ; if ( mv_joint_horizontal ( j ) ) encode_mv_component ( w , diff . col , & mvctx -> comps [ 1 ] , usehp ) ; <vul-start> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <vul-end> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , vpx_writer <vul-end> * w , <vul-start> ; if ( <vul-end> cpi -> sf <vul-start> cpi -> sf . mv\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, vpx_writer <vul-end> * w, <vul-start> usehp ) ; <vul-end> }    \n"
  },
  {
    "id": 389,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; <vul-start> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { <vul-end> if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return \">>> out of memory <<<\" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , \"&amp;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , \"&lt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , \"&gt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\\\x0' ; return escaped ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> size_t len ; if ( ! strlen ( text ) ) return \"empty string\" ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> = 0 ; text &&\n"
  },
  {
    "id": 390,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , \"Authentication failure, check credentials.\\\\n\" \"If credentials are valid, the NTLMSSP implementation may be to blame.\\\\n\" ) ; credssp_free ( transport -> credssp ) ; <vul-start> return FALSE ; <vul-end> } credssp_free ( transport -> credssp ) ; return TRUE ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
  },
  {
    "id": 391,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 VOID ixheaacd_shiftrountine_with_rnd_hq ( WORD32 * qmf_real , WORD32 * qmf_imag , WORD32 * filter_states , WORD32 len , WORD32 shift ) { WORD32 * filter_states_rev = filter_states + len ; WORD32 treal , timag ; WORD32 j ; for ( j = ( len - 1 ) ; j >= 0 ; j -= 2 ) { WORD32 r1 , r2 , i1 , i2 ; i2 = qmf_imag [ j ] ; r2 = qmf_real [ j ] ; r1 = * qmf_real ++ ; i1 = * qmf_imag ++ ; <vul-start> timag = ixheaacd_add32 ( i1 , r1 ) ; <vul-end> timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; filter_states_rev [ j ] = timag ; <vul-start> treal = ixheaacd_sub32 ( i2 , r2 ) ; <vul-end> treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32 ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32 ( i2 , r2 ) ; timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; * filter_states_rev ++ = timag ; } }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ; timag = ixheaacd_add32_sat <vul-end> ( i1 , <vul-start> ; treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <vul-end> ( i2 ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> qmf_imag ++ ; if ( len == 3 ) { <vul-start> = timag ; } else { timag = ixheaacd_add32 ( i1, r1 ) ; timag = ( ixheaacd_shl32_sat ( timag, shift ) ) ; filter_states_rev [ j ] = timag ; }\n"
  },
  {
    "id": 392,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , \"_sdp.txt\" ) ; } dump = gf_fopen ( szBuf , \"wt\" ) ; if ( ! dump ) { fprintf ( stderr , \"Failed to open %s for dumping\\\\n\" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , \"* File SDP content *\\\\n\\\\n\" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <vul-start> fprintf ( dump , \"%s\" , sdp ) ; <vul-end> fprintf ( dump , \"\\\\r\\\\n\" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , \"%s\" , sdp ) ; } fprintf ( dump , \"\\\\n\\\\n\" ) ; if ( inName ) gf_fclose ( dump ) ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( sdp && size )\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( dump, \"%s\\\\n\" <vul-end>, sdp )\n"
  },
  {
    "id": 393,
    "question": "CWE-908 Code Input Vulnerable Code Is: CWE-908 static int kvaser_usb_leaf_flush_queue ( struct kvaser_usb_net_priv * priv ) { struct kvaser_cmd * cmd ; int rc ; <vul-start> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <vul-end> if ( ! cmd ) return - ENOMEM ; cmd -> id = CMD_FLUSH_QUEUE ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_flush_queue ) ; cmd -> u . flush_queue . channel = priv -> channel ; cmd -> u . flush_queue . flags = 0x00 ; rc = kvaser_usb_send_cmd ( priv -> dev , cmd , cmd -> len ) ; kfree ( cmd ) ; return rc ; }",
    "golden_answers": [
      "CWE-908 Fixed Code Lines are: <vul-start> ; cmd = kzalloc <vul-end> ( sizeof (\n"
    ],
    "generated_answer": "CWE-908 Fixed Code Lines are: <vul-start> ; cmd = kzalloc <vul-end> ( sizeof (\n"
  },
  {
    "id": 394,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <vul-end> { int i , j , v ; <vul-start> if ( get_bits1 ( gb ) ) { <vul-end> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <vul-start> for ( i = 0 ; i < 64 ; i ++ ) { <vul-end> get_bits ( gb , 8 ) ; } } <vul-start> if ( get_bits1 ( gb ) ) { <vul-end> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <vul-start> for ( i = 0 ; i < 64 ; i ++ ) { <vul-end> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> read_quant_matrix_ext ( MpegEncContext <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> gb ) ; return 0 ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> read_quant_matrix_ext ( MpegEncContext <vul-start>, v ; int num_allocs = 0 ; <vul-start> ) ) { if ( num_allocs == 4 ) return - 1 ; <vul-start> ) ) { if ( num_allocs == 4 ) return - 1 ; <vul-start> ; } } num_allocs ++ ; <vul-start> ) ) { if ( num_allocs == 4 ) return - 1 ; <vul-start> ; } } return 0 ;\n"
  },
  {
    "id": 395,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <vul-start> if ( peer ) { <vul-end> if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> = 0 ; lsa -> l2tp_unused = 0 ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if (! lsk -> conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> conn_id ; lsa -> l2tp_addr = np -> daddr ; if (\n"
  },
  {
    "id": 396,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) { const VP9_COMMON * cm = & cpi -> common ; int64_t unused ; x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; <vul-start> super_block_uvrd ( cpi , x , rate_tokenonly , distortion , <vul-end> skippable , & unused , bsize , INT64_MAX ) ; <vul-start> * rate = * rate_tokenonly + x -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ; <vul-end> return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = DC_PRED ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; <vul-start> * rate_tokenonly + cpi <vul-end> -> intra_uv_mode_cost [\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = DC_PRED ; if (! <vul-start> INT64_MAX ) ; if (! ( cm -> frame_type & VPX_ENC_FLAG_HIGHBITDEPTH ) ) { super_block_uvrd ( cpi, x, rate_tokenonly, distortion, skippable, & unused, bsize, INT64_MAX ) ; * rate = * rate_tokenonly ; return RDCOST ( x -> rdmult, x -> rddiv, * rate, * distortion ) ; }\n"
  },
  {
    "id": 397,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_best_mode ( BEST_MODE * best_mode , int this_rd , RATE_DISTORTION * rd , int other_cost , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; other_cost += x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; best_mode -> yrd = RDCOST ( x -> rdmult , x -> rddiv , ( rd -> rate2 - rd -> rate_uv - other_cost ) , ( rd -> distortion2 - rd -> distortion_uv ) ) ; best_mode -> rd = this_rd ; <vul-start> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <vul-end> <vul-start> vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <vul-end> if ( ( this_mode == B_PRED ) || ( this_mode == SPLITMV ) ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { best_mode -> bmodes [ i ] = x -> e_mbd . block [ i ] . bmi ; } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = this_rd ; memcpy <vul-end> ( & best_mode <vul-start> ) ) ; memcpy <vul-end> ( & best_mode\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = this_rd ; memcpy <vul-end> ( & best_mode <vul-start> ) ) ; memcpy <vul-end> ( & best_mode\n"
  },
  {
    "id": 398,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <vul-start> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <vul-end> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ), sy ) ) { return NULL ; }\n"
  }
]