[
  {
    "id": 0,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_cal_sad ( VP8_COMP * cpi , MACROBLOCKD * xd , MACROBLOCK * x , int recon_yoffset , int near_sadidx [ ] ) { int near_sad [ 8 ] = { 0 } ; BLOCK * b = & x -> block [ 0 ] ; unsigned char * src_y_ptr = * ( b -> base_src ) ; if ( xd -> mb_to_top_edge == 0 && xd -> mb_to_left_edge == 0 ) { near_sad [ 0 ] = near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; } else if ( xd -> mb_to_top_edge == 0 ) { near_sad [ 0 ] = near_sad [ 2 ] = INT_MAX ; <vul-start> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <vul-end> } else if ( xd -> mb_to_left_edge == 0 ) { near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; <vul-start> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <vul-end> } else { <vul-start> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> dst . y_stride <vul-end> ) ; near_sad <vul-start> dst . y_stride <vul-end> ) ; near_sad <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> 16 , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; near_sad <vul-start> pre_y_buffer , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = INT_MAX ; if ( xd -> dst. y_stride == 0 ) { <vul-start> UINT_MAX ) ; } else { near_sad [ 0 ] = INT_MAX ; <vul-start> = INT_MAX ; if ( xd -> dst. y_stride == 0 ) { <vul-start> UINT_MAX ) ; } else { near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ]. sdf ( src_y_ptr, b -> src_stride, xd -> dst. y_buffer - 16, xd -> dst. y_stride * 16, xd -> dst. y_stride, UINT_MAX ) ; } <vul-start>!= INT_MAX ) { <vul-start> UINT_MAX ) ; } <vul-start>!= INT_MAX ) { <vul-start> UINT_MAX ) ; } <vul-start>!= INT_MAX ) { <vul-start> UINT_MAX ) ; } <vul-start>!= INT_MAX ) { <vul-start> UINT_MAX ) ; }\n"
  },
  {
    "id": 1,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ,",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> tp ) ; if ( udqp ) xfs_qm_dqrele ( tp, udqp ) ; if ( gdqp ) xfs_qm_dqrele ( gdqp ) ; <vul-end> return error ;\n"
  },
  {
    "id": 2,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , \"invalid descriptor for config index %d: \" \"type = 0x%X, length = %d\\\\n\" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , \"config %d has too many interfaces: %d, \" \"using maximum allowed: %d\\\\n\" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , \"config %d has an invalid interface association descriptor of length %d, skipping\\\\n\" , cfgno , d -> bLength ) ; continue ; } <vul-start> iad_num ] = d <vul-end> ; iad_num ++\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( config -> intf_assoc [ iad_num ] ) { dev_warn ( ddev, \"found more interfaces \" \"Association Descriptors \" \"than allocated for in \" \"configuration %d\\\\n\", cfgno ) ; } else { struct usb_interface_assoc_descriptor * desc = ( struct usb_interface_assoc_descriptor * ) header ; if ( desc -> bNumInterfaces < 1 ) { dev_err ( ddev, \"invalid number of interfaces\\\\n\" ) ; break ; } desc -> bNumInterfaces = iad_num ; } if ( <vul-start> iad_num ] = desc ; iad_num ++ ; } } else if ( header -> bDescriptorType == USB_DT_DEVICE || header -> bDescriptorType == USB_DT_CONFIG ) { dev_err ( ddev, \"config %d contains an unexpected \" \"descriptor of type 0x%X, skipping\\\\n\", cfgno, header -> bDescriptorType ) ; break ; } size = buffer2 - buffer ; config -> desc. wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; if ( size < buffer2 -> bDescriptorType ) { dev_err ( ddev, \"config %d has no descriptors\\\\n\", cfgno ) ; break ; } size = buffer2 - buffer ; config -> desc. wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; if ( header -> bLength < iad_num + sizeof ( struct usb_descriptor_header ) ) { dev_err ( ddev, \"invalid descriptor descriptor buffer buffer size \" \"for config %d\\\\n\", cfgno ) ; break ; } if ( header -> bDescriptorType == USB_DT_INTERFACE_ASSOCIATION ) { if ( iad_num == USB_MAXIADS ) { dev_err ( ddev, \"found more interfaces \" \"descriptor \" \"than allocated for in \" \"configuration %d\\\\n\", cfgno ) ; break ; } config -> intf_assoc [ iad_num ] = desc ; iad_num ++ ; } } else if ( header -> bDescriptorType == USB_DT_DEVICE || header -> bDescriptorType == USB_DT_CONFIG ) { dev_err ( ddev, \""
  },
  {
    "id": 3,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <vul-start> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <vul-end> <vul-start> return - ENOMEM ; <vul-end> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <vul-end> card -> user_ctl_count <vul-start> return - ENOMEM <vul-end> ; memcpy (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> (! replace ) { err = - ENOMEM ; if ( card -> user_ctl_count >= MAX_USER_CONTROLS - info -> count ) return err ; <vul-end> card -> user_ctl_count <vul-start> card -> user_ctl_count = 0 ; } <vul-end> if ( info\n"
  },
  {
    "id": 4,
    "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) { <vul-start> exit_client ( client_p , client_p , client_p , \"Mixing client and server protocol\" ) ; <vul-end> return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL )",
    "golden_answers": [
      "CWE-285 Fixed Code Lines are: <vul-start> client_p , \"Mixing client and server protocol\" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' ' ) ) { exit_client ( client_p , client_p , client_p , \"Malformed AUTHENTICATE\"\n"
    ],
    "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> 3 ) { exit_client <vul-end> ( client_p,\n"
  },
  {
    "id": 5,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void parse_input ( h2o_http2_conn_t * conn ) <vul-end> { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ; if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) perform_early_exit = 1 ; while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { if ( perform_early_exit == 1 && conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) goto EarlyExit ; const char * err_desc = NULL ; ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { break ; } else if ( ret < 0 ) { if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { enqueue_goaway ( conn , ( int ) ret , err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; } <vul-start> close_connection ( conn ) ; <vul-end> return ; } h2o_buffer_consume ( & conn -> sock -> input , ret ) ; } if ( ! h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_start ( conn -> sock , on_read ) ; <vul-start> return ; <vul-end> EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start>     static int <vul-end> parse_input ( h2o_http2_conn_t <vul-start> ) ; } return <vul-start> ( conn ) <vul-end> ; } h2o_buffer_consume <vul-start> ) ; return 0 <vul-start> sock ) ; return 0 ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>     static int <vul-end> parse_input ( h2o_http2_conn_t <vul-start> ) ; } return ret <vul-end> ; } h2o_buffer_consume <vul-start> on_read ) ; else return ret <vul-end> ; EarlyExit : <vul-start> sock ) ; return ret <vul-end> ; }  \n"
  },
  {
    "id": 6,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <vul-start> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <vul-end> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <vul-start> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <vul-end> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> offset , offset , <vul-end> flags , NULL <vul-start> offset , offset , <vul-end> flags , NULL <vul-start> , data + offset , data_size -\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> > 0? RE_FLAGS_NOT_AT_START : flags, NULL, NULL ) ; } if ( forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code, data + offset, data_size - offset, <vul-end> flags | RE_FLAGS_BACKWARDS <vul-start> RE_FLAGS_NOT_AT_START : flags, NULL, NULL ) ; } switch ( forward_matches ) { case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_RE_FIBERS ; case - 4 : return ERROR_INTERNAL_FATAL_ERROR ; } callback_args. string = ac_match -> string ; callback_args. data_base = data_base ; callback_args. forward_matches = forward_matches ; callback_args. full_word = STRING_IS_FULL_WORD ( ac_match -> string )? ac_match -> forward_code : yr_re_fast_exec ; callback_args. forward_code = yr_re_fast_exec ; callback_args. forward_code = yr_re_fast_exec ; callback_args. forward_code = yr_re_fast_exec ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_fast ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_args. forward_code = yr_re_exec ; callback_"
  },
  {
    "id": 7,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , AVDictionary * opts , AVDictionary * opts2 , int * is_http ) { HLSContext * c = s -> priv_data ; AVDictionary * tmp = NULL ; const char * proto_name = NULL ; int ret ; av_dict_copy ( & tmp , opts , 0 ) ; av_dict_copy ( & tmp , opts2 , 0 ) ; if ( av_strstart ( url , \"crypto\" , NULL ) ) { if ( url [ 6 ] == '+' || url [ 6 ] == ':' ) proto_name = avio_find_protocol_name ( url + 7 ) ; } if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ; if ( ! proto_name ) return AVERROR_INVALIDDATA ; <vul-start> if ( ! av_strstart ( proto_name , \"http\" , NULL ) && ! av_strstart ( proto_name , \"file\" , NULL ) ) <vul-end> return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ':' ) ; else if ( av_strstart ( url , \"crypto\" , NULL ) && ! strncmp ( proto_name , url + 7 , strlen ( proto_name ) ) && url [ 7 + strlen ( proto_name ) ] == ':' ) ; else if ( strcmp ( proto_name , \"file\" ) || ! strncmp ( url , \"file,\" , 5 ) ) return AVERROR_INVALIDDATA ; ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; if ( <vul-end> av_strstart ( proto_name <vul-start> ( proto_name , \"file\" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , \"ALL\" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , \"Filename extension of \\\\\\'%s\\\\\\' is not a common multimedia extension, blocked for security reasons.\\\\n\" \"If you wish to override this adjust allowed_extensions, you can set it to \\\\\\'ALL\\\\\\' to allow all\\\\n\" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <vul-start> , NULL ) ) { ; } else <vul-end> return AVERROR_INVALIDDATA ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if ( * is_http &&\n"
  },
  {
    "id": 8,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ctxt -> rip_relative && likely ( ctxt -> memopp )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ( ctxt -> <vul-end> d & GroupMask\n"
  },
  {
    "id": 9,
    "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <vul-start> int is_udplite = IS_UDPLITE ( sk ) ; <vul-end> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <vul-start> if ( udp_lib_checksum_complete ( skb ) ) <vul-end> goto csum_copy_err ; } <vul-start> if ( skb_csum_unnecessary ( skb ) ) <vul-end> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg",
    "golden_answers": [
      "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid = ! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if ( ! checksum_valid <vul-start> } if ( checksum_valid ||\n"
    ],
    "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid =! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if (! checksum_valid <vul-start> } if ( checksum_valid ||\n"
  },
  {
    "id": 10,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_golden_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( cm -> refresh_golden_frame ) { if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) { cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ; } cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <vul-start> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <vul-end> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cm -> refresh_golden_frame = 0 ; cpi -> frames_since_golden = 0 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) { cpi -> source_alt_ref_pending = 1 ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; } if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ; if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; } else if ( ! cpi -> common . refresh_alt_ref_frame",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> frames_till_gf_update_due ; } memset <vul-end> ( cpi ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> frames_till_gf_update_due ; } memset <vul-end> ( cpi ->\n"
  },
  {
    "id": 11,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <vul-start> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <vul-end> error = - EOPNOTSUPP ; goto out_errno ; <vul-start> } <vul-end> error = fh_want_write ( fh ) ; if ( error ) <vul-start> goto out_errno ; <vul-end> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ; <vul-start> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <vul-end> ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <vul-end> goto out_errno ; <vul-start> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <vul-end> ) ; if <vul-start> error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <vul-end> , argp -> <vul-start> argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <vul-end> fh_drop_write ( fh\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) goto out_drop_write ; error = set_posix_acl ( inode, ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT ) ; if ( error ) goto out_drop_write ; error = set_posix_acl ( inode, ACL_TYPE_DEFAULT, ACL_TYPE_DEFAULT ) ; if ( error ) goto out_drop_write ; fh_drop_write : fh_drop_write ( fh ) ; <vul-end> error = - <vul-start> out_errno ; } fh_verify ( rqstp, & resp -> fh, 0, NFS_MAY_SATTR ) ; if ( nfserr ) goto out ; <vul-start> error ) goto out <vul-end> ; error = <vul-start> goto out_drop_write ; <vul-end> fh_drop_write ( fh\n"
  },
  {
    "id": 12,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; <vul-start> pvc . sap_family = AF_ATMPVC ; <vul-end> pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> - ENOTCONN ; memset ( & pvc, 0, sizeof ( pvc ) ) ;\n"
  },
  {
    "id": 13,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { RING_IDX cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { <vul-start> netdev_dbg ( vif -> dev , \"Need more frags\\\\n\" ) ; <vul-end> return - frags ; } if ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { <vul-start> netdev_dbg ( vif -> dev , \"Too many frags\\\\n\" ) ; <vul-end> return - frags ; } memcpy ( txp , RING_GET_REQUEST ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { <vul-start> netdev_dbg ( vif -> dev , \"Frags galore\\\\n\" ) ; <vul-end> return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > PAGE_SIZE ) ) { <vul-start> netdev_dbg ( vif -> dev , \"txp->offset: %x, size: %u\\\\n\" , <vul-end> <vul-start> txp -> offset , txp -> size ) ; <vul-end> return - frags ; } } while ( ( txp ++ ) -> flags & XEN_NETTXF_more_data ) ; return frags ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> work_to_do ) { netdev_err <vul-end> ( vif -> <vul-start> dev , \"Need more frags\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> dev , \"Too many frags\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-start> size ) { netdev_err ( vif -> dev , \"Frag is bigger than frame.\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-end> ) ; return <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> txp -> size ) ; netbk_fatal_tx_err ( vif\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> work_to_do ) { netdev_err <vul-end> ( vif -> <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> size ) { netdev_err <vul-end> ( vif -> <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> txp -> size ) ; netbk_fatal_tx_err ( vif\n"
  },
  {
    "id": 14,
    "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <vul-start> down_write ( & mm -> mmap_sem ) ; <vul-end> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret",
    "golden_answers": [
      "CWE-667 Fixed Code Lines are: <vul-start> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock\n"
    ],
    "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> goto out ; if (! mmget_still_valid ( mm ) ) goto out_unlock ;\n"
  },
  {
    "id": 15,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof ) { <vul-start> char * ksep , * vsep , * val ; <vul-end> size_t klen , vlen ; size_t new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <vul-start> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <vul-end> if ( ! vsep ) { <vul-start> if ( ! eof ) { <vul-end> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = \"\" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <vul-start> return 1 ; <vul-end> }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> { char * start , * <vul-start> 0 ; } start = var -> ptr + var -> already_scanned ; <vul-start> = memchr ( start <vul-end> , '&' , <vul-start> -> end - start <vul-end> ) ; if <vul-start> eof ) { var -> already_scanned = var -> end - var -> ptr ; <vul-start> end ) ; var -> already_scanned = 0 ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> eof ) { const char * start, * <vul-end> * vsep, <vul-start> } vsep = var -> end - var -> ptr ; start = var -> ptr + var -> end ; vsep = <vul-start> = memchr ( start <vul-end>, '&', <vul-start> -> end - start <vul-end> ) ; if <vul-start>! eof ) <vul-end> { vsep = <vul-start> end ) ; var -> end = var -> ptr + var -> end ;\n"
  },
  {
    "id": 16,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:Name=Value\\\\n\" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <vul-start> strncpy ( szSec , opt_string , sepIdx ) ; <vul-end> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:Name=Value\\\\n\" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <vul-start> strncpy ( szKey , sep , sepIdx ) ; <vul-end> szKey [ sepIdx ] = 0 ; <vul-start> strcpy ( szVal , sep2 + 1 ) ; <vul-end> } if ( ! stricmp ( szKey , \"*\" ) ) { if ( stricmp ( szVal , \"null\" ) ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:*=null\\\\n\" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , \"null\" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , \"Badly formatted option %s - Section name is too long\\\\n\" , opt_string ) ; return ; } <vul-start> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , \"Badly formatted option %s - key name is too long\\\\n\" , opt_string ) ; return ; } <vul-start> = 0 ; if ( strlen ( <vul-end> sep2 + 1 <vul-start> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , \"Badly formatted option %s - value is too long\\\\n\" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> - opt_string ; memcpy <vul-end> ( szSec, <vul-start>, opt_string, sizeof ( szSec ) ) ; szSec [ sizeof ( szSec ) <vul-end> ] = 0 <vul-start> - sep ; memcpy <vul-end> ( szKey, <vul-start>, sep, sizeof ( szKey ) ) ; szKey [ sizeof ( szKey ) <vul-end> ] = 0 <vul-start> = 0 ; memcpy <vul-end> ( szVal,\n"
  },
  {
    "id": 17,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <vul-end> == 0 ) <vul-start> == 0 ) { datagrams = err ; goto out_put ; } <vul-end> if ( err <vul-start> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <vul-start> datagrams ; } <vul-end>      \n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ) ; } <vul-end> if ( err <vul-start> == 0 ) goto out_put ; if ( datagrams!= 0 ) { if ( err!= - EAGAIN ) { sock -> sk -> sk_err = - err ; } return datagrams ; } return err ; out_put : <vul-end> fput_light ( sock <vul-start> == 0 ) goto out_put <vul-end> ; if ( <vul-start> err ; } goto out_put ; } <vul-start> datagrams ; } <vul-end> }    \n"
  },
  {
    "id": 18,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t udpReceiveDatagram ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <vul-start> message -> srcIpAddr = queueItem -> srcIpAddr ; <vul-end> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } udpUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; message -> interface = queueItem -> interface ; message ->\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; message -> interface = queueItem -> interface ; message ->\n"
  },
  {
    "id": 19,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 <vul-start> int hns_nic_net_xmit_hw ( struct net_device * ndev , <vul-end> struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , \"no memory to xmit!\\\\n\" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , \"TX head DMA map failed\\\\n\" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start>       netdev_tx_t <vul-end> hns_nic_net_xmit_hw ( struct <vul-start> len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>       static <vul-start> len ) ; if ( unlikely ( ring -> stats. tx_pkts > ring -> stats. max_tx_pkts ) ) { netdev_err ( ndev, \"Too many tx buffers\\\\n\" ) ; ring -> stats. sw_err_cnt ++ ; goto out_map_frag_fail ; }\n"
  },
  {
    "id": 20,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; <vul-start> distortion = vp8_variance16x16 <vul-end> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; distortion = vpx_variance16x16 <vul-end> ( * (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; distortion = vpx_variance16x16 <vul-end> ( * (\n"
  },
  {
    "id": 21,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void send_ldap_result_ext ( Slapi_PBlock * pb , int err , char * matched , char * text , int nentries , struct berval * * urls , BerElement * ber ) { Slapi_Operation * operation ; passwdPolicy * pwpolicy = NULL ; Connection * conn = NULL ; Slapi_DN * sdn = NULL ; const char * dn = NULL ; ber_tag_t tag ; int flush_ber_element = 1 ; ber_tag_t bind_method = 0 ; int internal_op ; int i , rc , logit = 0 ; char * pbtext ; slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & bind_method ) ; slapi_pblock_get ( pb , SLAPI_OPERATION , & operation ) ; slapi_pblock_get ( pb , SLAPI_CONNECTION , & conn ) ; if ( text ) { pbtext = text ; } else { <vul-start> slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ; <vul-end> } if ( operation == NULL ) { slapi_log_err ( SLAPI_LOG_ERR , \"send_ldap_result_ext\" , \"No operation found: slapi_search_internal_set_pb was incomplete (invalid \\'base\\' ?)\\\\n\" ) ; return ; } if ( operation -> o_status == SLAPI_OP_STATUS_RESULT_SENT ) { return ; } if ( ber != NULL ) { flush_ber_element = 0 ; } if ( err != LDAP_SUCCESS ) { if ( err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN ) { slapi_counter_increment ( g_get_global_snmp_vars ( ) -> ops_tbl . dsSecurityErrors ) ; } else if ( err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS )",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ( pb , SLAPI_RESULT_TEXT <vul-end> , & pbtext\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( pb, SLAPI_RESULT_TEXT <vul-end>, & pbtext\n"
  },
  {
    "id": 22,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( \"Initializing ENC624J600 Ethernet controller...\\\\r\\\\n\" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <vul-end> if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <vul-end> interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <vul-end> interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <vul-end> interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <vul-end> temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <vul-end> temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; <vul-start>",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <vul-end> ) ; if <vul-start> ( interface , ENC624J600_MAADR1 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR2 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR3 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR1 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_MAADR2 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_MAADR3 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_ERXST <vul-end> , ENC624J600_RX_BUFFER_START ) <vul-start> ( interface , ENC624J600_ERXTAIL <vul-end> , ENC624J600_RX_BUFFER_STOP ) <vul-start> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT2 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT3 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT4 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <vul-end> , ETH_MAX_FRAME_SIZE ) <vul-start> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <vul-end> ) ; enc624j600SetBit <vul-start> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <vul-end> ) ; enc624j600DumpReg\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC624J600_ECON2, ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH ) ; enc624j600WriteReg ( interface, ENC624J600_ECON2_ETHEN <vul-end>, ECON2_ETHEN | <vul-start> ( interface, ENC624J600_ECON2_ST <vul-end> ) ; if <vul-start> ( interface, ENC624J600_ECON2_ST <vul-end> ) ; interface <vul-start> ( interface, ENC624J600_ECON2_ST <vul-end> ) ; interface <vul-start> ( interface, ENC624J600_ECON2_ST <vul-end> ) ; if <vul-start> ( interface, ENC624J600_ECON3_ST <vul-end> ) ; interface <vul-start> ( interface, ENC624J600_ECON4_EHT1 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_ECH4_EHT2 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_ECH4_EHT3 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 ) ; enc624j600WriteReg ( interface, ENC624J600_MACON3_TXCRCEN | MACON3_R1 ) ; enc624j600WriteReg ( interface, ENC624J600_MACON4_TXCRCEN | MACON3_R1 ) ; enc624j600WriteReg ( interface, ENC624J600_MACON3_TXCRCEN | MACON3_R1 ) ; enc624j600WriteReg ( interface, ENC624J600_MACON3_TXCRCEN | MACON3_R1 ) ; enc624j600WriteReg ( interface, ENC624J600_MACON3_MAMXFL, ETH_MAX_FRAME_SIZE ) ; enc624j600WritePhyReg ("
  },
  {
    "id": 23,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ; <vul-start> if ( jas_init ( ) ) { <vul-end> abort ( ) ; } cmdname = argv [ 0 ] ; <vul-start> infile = 0 ; <vul-end> verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( \"%s\\\\n\" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ; <vul-start> case OPT_MAXMEM : <vul-end> max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , \"rb\" ) ) ) { fprintf ( stderr , \"cannot open input image file %s\\\\n\" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; <vul-start> 0 ] ; max_samples = 64 * JAS_MEBI ; <vul-start> break ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <vul-start> ) ; } snprintf ( optstr , sizeof ( optstr ) , \"max_samples=%-zu\" , max_samples ) ; <vul-start> , fmtid , optstr <vul-end> ) ) ) <vul-start> ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( \"format name lookup failed\\\\n\" ) ; return EXIT_FAILURE ; } if ( ! ( <vul-start> 0 ; } printf ( \"%s %d %d %d %d %ld\\\\n\" , fmtname <vul-end> , numcmpts , <vul-start> , depth , JAS_CAST ( long , <vul-end> jas_image_rawsize ( image <vul-start> jas_image_rawsize ( image )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> size_t max_mem ; int debug_print ; <vul-start> 0 ] ; debug_print = 0 ; <vul-start> break ; case OPT_MAXMEM : max_mem = jas_parse_maxmem ( jas_optarg, 0, 10 ) ; break ; case <vul-start> ) ) { jas_stream_close ( instream ) ; fprintf ( stderr, \"cannot load image\\\\n\" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; if ( debug_print ) { jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( debug_print ) ; # endif <vul-start> ) ) ; jas_stream_close ( instream ) ; fprintf ( stderr, \"warning: image has no components\\\\n\" ) ; } if ( debug_print ) { jas_setdbglevel ( debug ) ; } <vul-start> ( \"%s %d %d %d %d %ld\\\\n\" <vul-end>, fmtname, <vul-start> ( long ) jas_image_getrawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; debug_print = debug_print <vul-end> ; return EXIT_SUCCESS\n"
  },
  {
    "id": 24,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <vul-end> int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) { int i , x_idx , y ; VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; MODE_INFO * mi = & ctx -> mic ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; MODE_INFO * mi_addr = xd -> mi [ 0 ] ; <vul-start> const struct segmentation * const seg = & cm -> seg ; <vul-end> const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; int max_plane ; assert ( mi -> mbmi . sb_type == bsize ) ; * mi_addr = * mi ; <vul-start> if ( seg -> enabled && output_enabled ) { <vul-end> if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mi_addr -> mbmi . segment_id = <vul-start> vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <vul-end> } <vul-start> else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { <vul-end> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> -> common ; RD_COUNTS * const rdc = & td -> rd_counts ; <vul-start> x = & td <vul-end> -> mb ; <vul-start> cm -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <vul-start> * mi ; * x -> mbmi_ext = ctx -> mbmi_ext ; <vul-start> seg -> enabled <vul-end> ) { if <vul-start> . segment_id = get_segment_id <vul-end> ( cm , <vul-start> ) ; } <vul-end> if ( cpi <vul-start> , bsize , ctx -> rate , ctx -> dist , x -> skip <vul-end> ) ; } <vul-start> ; if ( <vul-end> is_inter_block ( mbmi <vul-start> -> skip ; memcpy <vul-end> ( x -> <vul-start> , sizeof ( ctx -> zcoeff_blk [ 0 ] <vul-end> ) * ctx <vul-start> ) return ; <vul-end> # if CONFIG_INTERNAL_STATS <vul-start> { vp9_update_mv_count ( td <vul-end> ) ; if <vul-start> ) ; ++ td -> counts -> <vul-end> switchable_interp [ ctx <vul-start> ; } } rdc -> comp_pred_diff <vul-end> [ SINGLE_REFERENCE ] <vul-start> -> single_pred_diff ; rdc -> comp_pred_diff <vul-end> [ COMPOUND_REFERENCE ] <vul-start> -> comp_pred_diff ; rdc -> comp_pred_diff <vul-end> [ REFERENCE_MODE_SELECT ] <vul-start> ++ i ) rdc -> filter_diff <vul-end> [ i ] <vul-start> ] ; } for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, <vul-start> x ) ; ThreadData * const td_ = & td -> mb. e_data ; <vul-start> const seg = td -> seg ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; int max_plane ; assert ( mi -> mbmi. sb_type == bsize ) ; * mi_addr = * mi ; if ( seg -> enabled && output_enabled ) { if ( td <vul-end> -> oxcf. <vul-start> aq_mode == CYCLIC_REFRESH_AQ ) { const uint8_t * const map = seg -> update_map? cm -> segmentation_map : td -> last_frame_seg_map ; td -> segment_id = vp9_get_segment_id ( cm, map, bsize, mi_row, mi_col ) ; } else if ( td -> oxcf. aq_mode == CYCLIC_REFRESH_AQ <vul-start> SWITCHABLE ) { const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; <vul-start> -> skip ; memcpy <vul-end> ( x -> <vul-start> SINGLE_REFERENCE ] += ctx -> single_pred_diff ; cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; for ( i = 0 ; i < TX_MODES ; ++ i ) cpi -> rd_filter_diff [ i ] += ctx -> tx_rd_diff [ i ] ; } } else { if ( xd -> oxcf. aq_mode == CYCLIC_REFRESH_AQ ) { vp9_cyclic_refresh_update_segment ( cpi, & x -> <vul-end> mi [ 0 <vul-start> [ 0 ], ctx -> zcoeff_blk [ mbmi -> tx_size ], ctx -> zcoeff_blk [ mbmi -> tx_size ], ctx -> zcoeff_blk [ mbmi -> tx_size ], ctx -> zcoeff_blk [ mbmi ->"
  },
  {
    "id": 25,
    "question": "CWE-601 Code Input Vulnerable Code Is: CWE-601 static int oidc_handle_logout ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { oidc_provider_t * provider = NULL ; char * url = NULL ; <vul-start> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <vul-end> oidc_debug ( r , \"enter (url=%s)\" , url ) ; if ( oidc_is_front_channel_logout ( url ) ) { return oidc_handle_logout_request ( r , c , session , url ) ; } else if ( oidc_is_back_channel_logout ( url ) ) { return oidc_handle_logout_backchannel ( r , c ) ; } if ( ( url == NULL ) || ( apr_strnatcmp ( url , \"\" ) == 0 ) ) { url = c -> default_slo_url ; } else { <vul-start> const char * error_description = NULL ; <vul-end> apr_uri_t uri ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { const char * error_description = apr_psprintf ( r -> pool , \"Logout URL malformed: %s\" , url ) ; oidc_error ( r , \"%s\" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , <vul-start> \"Malformed URL\" , error_description , <vul-end> HTTP_INTERNAL_SERVER_ERROR ) ; } const char * c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { error_description = apr_psprintf ( r -> pool , \"logout value \\\\\"%s\\\\\" does not match the hostname of the current request",
    "golden_answers": [
      "CWE-601 Fixed Code Lines are: <vul-start> = NULL ; char * error_str = NULL ; char * error_description = NULL ; <vul-start> } else { if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <vul-end> return oidc_util_html_send_error ( <vul-start> -> error_template , error_str , error_description , HTTP_BAD_REQUEST <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-601 Fixed Code Lines are: <vul-start> ( r, OIDC_REDIRECT_URI_REQUEST_LOGOUT_SINGLE, & url ) ; oidc_util_get_request_parameter ( r, <vul-start> } else { oidc_util_send_error_request ( r, c <vul-end>, \"Malformed URL\", <vul-start>, \"Malformed URL\", <vul-end> HTTP_INTERNAL_SERVER_ERROR ) ;\n"
  },
  {
    "id": 26,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int tiffcp ( TIFF * in , TIFF * out ) { <vul-start> uint16 bitspersample , samplesperpixel = 1 ; <vul-end> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , \"tiffcp: %s: Can\\'t copy/convert subsampled image.\\\\n\" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel ==",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { uint16 bitspersample = 1\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, samplesperpixel = 0 <vul-end> ; uint16 input_compression\n"
  },
  {
    "id": 27,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <vul-start> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <vul-end> return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( &",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <vul-end> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; OPENSSL_free ( buf_in\n"
  },
  {
    "id": 28,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void print_attr_string ( netdissect_options * ndo , register const u_char * data , u_int length , u_short attr_code ) { register u_int i ; ND_TCHECK2 ( data [ 0 ] , length ) ; switch ( attr_code ) { case TUNNEL_PASS : if ( length < 3 ) <vul-start> { <vul-end> ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ; } if ( * data && ( * data <= 0x1F ) ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; ND_PRINT ( ( ndo , \"Salt %u \" , EXTRACT_16BITS ( data ) ) ) ; data += 2 ; length -= 2 ; break ; case TUNNEL_CLIENT_END : case TUNNEL_SERVER_END : case TUNNEL_PRIV_GROUP : case TUNNEL_ASSIGN_ID : case TUNNEL_CLIENT_AUTH : case TUNNEL_SERVER_AUTH : if ( * data <= 0x1F ) { if ( length < 1 ) <vul-start> { <vul-end> ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ; } if ( * data ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; } break ; <vul-start> case EGRESS_VLAN_NAME : <vul-end> ND_PRINT ( ( ndo , \"%s (0x%02x) \" , tok2str ( rfc4675_tagged , \"Unknown tag\" , * data ) , * data ) ) ; data ++ ; length -- ; break ; } <vul-start> for ( i =",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> < 3 ) goto trunc ; <vul-end> if ( * <vul-start> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; } <vul-end> break ; case <vul-start> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <vul-start> = 0 ; i < length && * data <vul-end> ; i ++\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> < 3 ) goto trunc ; <vul-end> if ( * <vul-start> < 1 ) goto trunc ; <vul-end> if ( * <vul-start> break ; case EGRESS_VLAN_NAME : ND_TCHECK_16BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; ND_TCHECK_8BITS ( data ) ; break ; case <vul-start> break ; } if ( length < 2 ) goto trunc ; <vul-start> < length ; length --, data ++ ) ND_PRINT ( ( ndo, \"%c\", ( * data < 32 || * data > 126 )? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo, \"%s\", tstr ) ) ; return ; } for ( i = 0 ; i < length ; i ++, data ++ ) ND_PRINT ( ( ndo, \"%c\", ( * data < 32 || * data > 126 )? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo, \"%s\", tstr ) ) ; return ; } for ( i = 0 ; * data && i < length ; i ++, data ++ ) ND_PRINT ( ( ndo, \"%c\", ( * data < 32 || * data > 126 )? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo, \"%s\", tstr ) ) ; return ; } } if ( * data && i < length ; i ++, data ++ ) ND_PRINT ( ( ndo, \"%c\", ( * data < 32 || * data > 126 )? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo, \"%s\", tstr ) ) ; return ; } } <vul-end> }    \n"
  },
  {
    "id": 29,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int strncat_from_utf8_libarchive2 ( struct archive_string * as , const void * _p , size_t len , struct archive_string_conv * sc ) { const char * s ; int n ; char * p ; char * end ; uint32_t unicode ; # if HAVE_WCRTOMB mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # else wctomb ( NULL , L'\\\\0' ) ; # endif ( void ) sc ; if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ; s = ( const char * ) _p ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; while ( ( n = _utf8_to_unicode ( & unicode , s , len ) ) != 0 ) { wchar_t wc ; if ( p >= end ) { as -> length = p - as -> s ; if ( archive_string_ensure ( as , <vul-start> as -> length + len * 2 + 1 ) == NULL ) <vul-end> return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; } if ( n < 0 ) { n *= - 1 ; wc = L'?' ; } else wc = ( wchar_t ) unicode ; s += n ; len -= n ; # if HAVE_WCRTOMB n = ( int )",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> -> length + max ( <vul-start> len * 2 , ( size_t ) MB_CUR_MAX )\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> len * 2 <vul-end> ) == NULL\n"
  },
  {
    "id": 30,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 interval * PGTYPESinterval_from_asc ( char * str , char * * endptr ) { interval * result = NULL ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; tm -> tm_year = 0 ; tm -> tm_mon = 0 ; tm -> tm_mday = 0 ; tm -> tm_hour = 0 ; tm -> tm_min = 0 ; tm -> tm_sec = 0 ; fsec = 0 ; <vul-start> if ( strlen ( str ) >= sizeof ( lowstr ) ) <vul-end> { errno = PGTYPES_INTVL_BAD_INTERVAL ; <vul-start> return NULL ; <vul-end> } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; <vul-start> return NULL ; <vul-end> } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } <vul-start> if ( tm2interval ( tm , fsec , result )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <vul-end> ) { errno <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <vul-end> ) { errno <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; <vul-end> free ( result <vul-start> NULL ; } <vul-end> errno = 0\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str, lowstr, field, ftype, & nf, ptr )!= 0 || ( DecodeInterval ( field, ftype, nf, & dtype, tm, & fsec )!= 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if (! result ) return NULL ; if ( dtype!= DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm, fsec, result ) <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; <vul-start> } if ( fsec!= 0 && <vul-start> fsec, result, NULL\n"
  },
  {
    "id": 31,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 ) <vul-start> sas_port_delete ( phy -> port ) ; <vul-end> phy -> port = NULL ; } }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <vul-end> ) ; phy\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == 0 ) sas_destruct_devices ( phy -> port ) ;\n"
  },
  {
    "id": 32,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 bool CompileKeymap ( XkbFile * file , struct xkb_keymap * keymap , enum merge_mode merge ) { bool ok ; XkbFile * files [ LAST_KEYMAP_FILE_TYPE + 1 ] = { NULL } ; enum xkb_file_type type ; struct xkb_context * ctx = keymap -> ctx ; for ( file = ( XkbFile * ) file -> defs ; file ; file = ( XkbFile * ) file -> common . next ) { if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <vul-start> log_err ( ctx , \"Cannot define %s in a keymap file\\\\n\" , <vul-end> <vul-start> xkb_file_type_to_string ( file -> file_type ) ) ; <vul-end> continue ; } if ( files [ file -> file_type ] ) { log_err ( ctx , \"More than one %s section in keymap file; \" \"All sections after the first ignored\\\\n\" , xkb_file_type_to_string ( file -> file_type ) ) ; continue ; } files [ file -> file_type ] = file ; } ok = true ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { if ( files [ type ] == NULL ) { log_err ( ctx , \"Required section %s missing from keymap\\\\n\" , xkb_file_type_to_string ( type ) ) ; ok = false ; } } if ( ! ok ) return false ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { log_dbg ( ctx , \"Compiling %s \\\\\"%s\\\\\"\\\\n\" , xkb_file_type_to_string ( type ) , files [ type ] -> name ) ; ok = compile_file_fns [ type",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , \"Geometry sections are not supported; ignoring\\\\n\" ) ; } else { <vul-start> ) ) ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> LAST_KEYMAP_FILE_TYPE ) { if ( files [ file -> file_type ]!= NULL ) { <vul-start> ) ) ; }\n"
  },
  {
    "id": 33,
    "question": "CWE-611 Code Input Vulnerable Code Is: CWE-611 <vul-start> static VALUE from_document ( VALUE klass , VALUE document ) <vul-end> { xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; <vul-start> Data_Get_Struct ( document , xmlDoc , doc ) ; <vul-end> <vul-start> doc = doc -> doc ; <vul-end> if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) { rb_raise ( rb_eArgError , \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\" ) ; } ctx = xmlSchemaNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , \"Could not parse document\" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , \"@errors\" , errors ) ; <vul-start> return rb_schema ; <vul-end> return Qnil ; }",
    "golden_answers": [
      "CWE-611 Fixed Code Lines are: <vul-start> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <vul-end> xmlDocPtr doc ; <vul-start> VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , \"11\" , & document , & parse_options ) ; <vul-start> doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( \"ParseOptions\" ) ) , rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( \"to_i\" ) , 0 ) ) <vul-start> errors ) ; rb_iv_set ( rb_schema , \"@parse_options\" , parse_options ) ;\n"
    ],
    "generated_answer": "CWE-611 Fixed Code Lines are: <vul-start> VALUE from_document ( int argc, VALUE * argv, VALUE klass ) { VALUE document ; VALUE parse_options ; VALUE parse_options ; xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc, argv, \"11\", & document, & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml, rb_intern ( \"ParseOptions\" ) ), rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } <vul-end> ctx = xmlSchemaNewDocParserCtxt <vul-start> -> doc ; if ( scanned_args == 2 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml, rb_intern ( \"DEFAULT_SCHEMA\" ) ), rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } <vul-start> errors ) ; rb_iv_set ( rb_schema, \"@parse_options\", parse_options ) ;\n"
  },
  {
    "id": 34,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int gs_can_open ( struct net_device * netdev ) { struct gs_can * dev = netdev_priv ( netdev ) ; struct gs_usb * parent = dev -> parent ; int rc , i ; struct gs_device_mode * dm ; u32 ctrlmode ; rc = open_candev ( netdev ) ; if ( rc ) return rc ; if ( atomic_add_return ( 1 , & parent -> active_channels ) == 1 ) { for ( i = 0 ; i < GS_MAX_RX_URBS ; i ++ ) { struct urb * urb ; u8 * buf ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; buf = usb_alloc_coherent ( dev -> udev , sizeof ( struct gs_host_frame ) , GFP_KERNEL , & urb -> transfer_dma ) ; if ( ! buf ) { netdev_err ( netdev , \"No memory left for USB buffer\\\\n\" ) ; usb_free_urb ( urb ) ; return - ENOMEM ; } usb_fill_bulk_urb ( urb , dev -> udev , usb_rcvbulkpipe ( dev -> udev , GSUSB_ENDPOINT_IN ) , buf , sizeof ( struct gs_host_frame ) , gs_usb_receive_bulk_callback , parent ) ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_anchor_urb ( urb , & parent -> rx_submitted ) ; rc = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( rc ) { if ( rc == - ENODEV ) netif_device_detach ( dev -> netdev ) ; netdev_err ( netdev , \"usb_submit failed (err=%d)\\\\n\" , rc ) ; <vul-start> usb_unanchor_urb ( urb ) ; <vul-end> break ; } usb_free_urb ( urb ) ; } } dm",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> ) ; usb_unanchor_urb ( urb ) ; usb_free_urb\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> rc ) ; usb_free_urb ( urb ) ;\n"
  },
  {
    "id": 35,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( \"arptables: loop hook %u pos %u %08X.\\\\n\" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <vul-start> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <vul-end> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <vul-start> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <vul-end> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> if ( ( unconditional ( e <vul-end> ) && ( <vul-start> verdict < 0 <vul-end> ) || visited\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( ( unconditional ( e <vul-end> ) && ( <vul-start> verdict < 0 <vul-end> ) || visited\n"
  },
  {
    "id": 36,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; <vul-start> struct gs_host_config hconf = { <vul-end> . byte_order = 0x0000beef , } ; <vul-start> struct gs_device_config dconf ; <vul-end> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <vul-start> & hconf , <vul-end> <vul-start> sizeof ( hconf ) , <vul-end> 1000 ) ; <vul-start> if ( rc < 0 ) { <vul-end> dev_err ( & intf -> dev , \"Couldn\\'t send data format (err=%d)\\\\n\" , rc ) ; return rc ; <vul-start> } <vul-end> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <vul-start> & dconf , <vul-end> <vul-start> sizeof ( dconf ) , <vul-end> 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , \"Couldn\\'t get device config: (err=%d)\\\\n\" , rc ) ; <vul-start> return rc ; <vul-end> } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , \"Configuring for %d interfaces\\\\n\" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , \"Driver cannot handle more that",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; struct gs_host_config * hconf <vul-end> ; struct gs_device_config <vul-start> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <vul-end> ; rc = <vul-start> . bInterfaceNumber , <vul-end> hconf , sizeof <vul-start> , sizeof ( * <vul-start> 1000 ) ; kfree ( hconf ) ; <vul-start> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <vul-start> . bInterfaceNumber , <vul-end> dconf , sizeof <vul-start> , sizeof ( * <vul-start> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <vul-end> icount + 1 <vul-start> GS_MAX_INTF ) ; kfree ( dconf ) ; <vul-start> ! dev ) { kfree ( dconf ) ; <vul-start> - ENOMEM ; } <vul-start> , intf , <vul-end> dconf ) ; <vul-start> ; kfree ( dconf ) ; kfree ( <vul-start> dev ; } kfree ( dconf ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; struct gs_host_config * hconf ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ), GFP_KERNEL ) ; if (! hconf ) return - ENOMEM <vul-end> ; rc = <vul-start>! dev ) { dconf = kzalloc ( sizeof ( * dconf ), GFP_KERNEL ) ; if (! dconf ) { kfree ( dev ) ; rc = - ENOMEM ; goto err_put_dev ; } <vul-end> init_usb_anchor ( & <vul-start> hconf ), hconf -> desc. bNumEndpoints, <vul-start> rc ; } dconf -> desc. bNumEndpoints, <vul-start> bInterfaceNumber, & dconf -> <vul-start> kfree ( dev ) ; kfree ( dconf <vul-start> dev ; } rc = 0 ; err_put_dev : kfree ( hconf ) ; err_put_dev : kfree ( dev ) ; return rc <vul-end> ; }  \n"
  },
  {
    "id": 37,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : <vul-start> p += 2 ; <vul-end> n += 2 ; len -= 2 ; break ; case 0x40 : <vul-start> p += 3 ; <vul-end> n += 3 ; len -= 3 ; break ; case 0x80 : <vul-start> p += 4 ; <vul-end> n += 4 ; len -= 4 ; break ; case 0xC0 : <vul-start> l = p [ 1 ] ; <vul-end> if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> case 0x00 : if ( len < 2 ) return - 1 ; <vul-start> case 0x40 : if ( len < 3 ) return - 1 ; <vul-start> case 0x80 : if ( len < 4 ) return - 1 ; <vul-start> case 0xC0 : if ( len < 2 ) return - 1 ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case 0x00 : if ( len < 2 ) return - 1 ; <vul-start> case 0x40 : if ( len < 3 ) return - 1 ; <vul-start> case 0x80 : if ( len < 4 ) return - 1 ; <vul-start> case 0xC0 : if ( len < 1 ) return - 1 ;\n"
  },
  {
    "id": 38,
    "question": "CWE-863 Code Input Vulnerable Code Is: CWE-863 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for (",
    "golden_answers": [
      "CWE-863 Fixed Code Lines are: <vul-start> ; if ( * cp == '\\\\0' || <vul-end> strchr ( cp <vul-start> ) != NULL || <vul-end> strcmp ( cp <vul-start> ( cp , \".\" ) == 0 || strcmp ( cp , <vul-start> ) == 0 <vul-end> ) { run_err\n"
    ],
    "generated_answer": "CWE-863 Fixed Code Lines are: <vul-start> if ( ( ( <vul-start>!= NULL ) && ( <vul-end> ( strcmp ( <vul-start> == 0 ) )\n"
  },
  {
    "id": 39,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; daemon ( 1 , 0 ) ; openlog ( \"KVP\" , 0 , LOG_USER ) ; syslog ( LOG_INFO , \"KVP starting; pid is:%d\" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , \"Failed to initialize the pools\" ) ; exit ( - 1 ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , \"netlink socket creation failed; error:%d\" , fd ) ; exit ( - 1 ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , \"bind failed; error:%d\" , error ) ; close ( fd ) ; exit ( - 1 ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <vul-start> ; len = recvfrom <vul-end> ( fd , <vul-start> ) , 0 , addr_p , & addr_l <vul-start> len < 0 || addr . nl_pid <vul-start> ( LOG_ERR , \"recvfrom failed; pid:%u error:%d %s\" , addr . nl_pid , errno , strerror ( errno ) <vul-end> ) ; close\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>. events = 0 ; pfd. revents = 0 ; TEMP_FAILURE_RETRY ( <vul-end> poll ( & <vul-start> 1 ) ; ) <vul-start> ; if ( ( <vul-start>, 0 ) ) <vul-start> ( LOG_ERR, \"recv failed; error:%d\" <vul-end>, len ) <vul-start> 1 ) ; TEMP_FAILURE_RETRY ( <vul-start>, 0 ) )\n"
  },
  {
    "id": 40,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * purgekeys_2_svc ( purgekeys_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg , * funcname ; <vul-start> gss_buffer_desc client_name , service_name ; <vul-end> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = \"kadm5_purgekeys\" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_purgekeys ( ( void * ) handle , arg -> princ , arg -> keepkvno ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 41,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <vul-start> int data_len = elt -> length - <vul-end> <vul-start> sizeof ( struct oz_get_desc_rsp ) + 1 ; <vul-end> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport ,",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <vul-end> data_len = elt <vul-start> -> length - ( <vul-start> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <vul-start> ) + 1 <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) usb_hdr ; unsigned <vul-start> struct oz_get_desc_rsp ) ; if ( data_len < sizeof ( struct oz_get_desc_rsp ) ) { dev_err ( & pd -> dev, \"invalid descriptor buffer length\\\\n\" ) ; break ; } oz_dbg ( ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, elt -> length, offs, total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_dbg ( ON, \"USB_REQ_SET_CONFIG - cnf\\\\n\" ) ; oz_hcd_set_config_rsp ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, elt -> length, offs, total_size ) ; } break ; case OZ_GET_DESCRIPTOR_RSP : { struct oz_get_descriptor_rsp * body = ( struct oz_get_descriptor_rsp * ) usb_hdr ; oz_dbg ( ON, \"USB_REQ_SET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_descriptor_cnf ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, elt -> length, offs, total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_descriptor_rsp * body = ( struct oz_set_descriptor_rsp * ) usb_hdr ; oz_dbg ( ON, \"USB_REQ_SET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_set_descriptor_cnf ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, body ->"
  },
  {
    "id": 42,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , <vul-start> struct nfs4_state_owner * sp , int flags , <vul-end> const struct iattr * attrs ) { struct dentry * parent = dget_parent ( path -> dentry ) ; struct inode * dir = parent -> d_inode ; struct nfs_server * server = NFS_SERVER ( dir ) ; struct nfs4_opendata * p ; p = kzalloc ( sizeof ( * p ) , GFP_KERNEL ) ; if ( p == NULL ) goto err ; p -> o_arg . seqid = nfs_alloc_seqid ( & sp -> so_seqid ) ; if ( p -> o_arg . seqid == NULL ) goto err_free ; p -> path . mnt = mntget ( path -> mnt ) ; p -> path . dentry = dget ( path -> dentry ) ; p -> dir = parent ; p -> owner = sp ; atomic_inc ( & sp -> so_count ) ; p -> o_arg . fh = NFS_FH ( dir ) ; <vul-start> p -> o_arg . open_flags = flags , <vul-end> p -> o_arg . clientid = server -> nfs_client -> cl_clientid ; p -> o_arg . id = sp -> so_owner_id . id ; p -> o_arg . name = & p -> path . dentry -> d_name ; p -> o_arg . server = server ; p -> o_arg . bitmask = server -> attr_bitmask ; p -> o_arg . claim = NFS4_OPEN_CLAIM_NULL ; if ( flags & O_EXCL ) { u32 * s = ( u32 * ) p -> o_arg . u",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> nfs4_state_owner * sp , fmode_t fmode <vul-start> open_flags = flags ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <vul-end> p -> o_arg\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * sp, fmode_t fmode, <vul-start> open_flags = flags ; <vul-end> p -> o_arg\n"
  },
  {
    "id": 43,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { <vul-start> struct page * pages [ NFS4ACL_MAXPAGES ] ; <vul-end> struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; <vul-start> struct page * localpage = NULL ; <vul-end> int ret ; if ( buflen < PAGE_SIZE ) { localpage = alloc_page ( GFP_KERNEL ) ; resp_buf = page_address ( localpage ) ; if ( localpage == NULL ) <vul-start> return - ENOMEM ; <vul-end> args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = PAGE_SIZE ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; <vul-start> if ( res . acl_len > args . acl_len ) <vul-end> <vul-start> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <vul-end> else <vul-start> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <vul-end> if",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> [ NFS4ACL_MAXPAGES ] = { NULL , } <vul-start> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <vul-end> == NULL ) <vul-start> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( \"%s  buf %p buflen %ld npages %d args.acl_len %ld\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; <vul-end> ret = nfs4_call_sync <vul-start> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <vul-end> acl_len > args <vul-start> , NULL , <vul-end> acl_len ) ; <vul-start> inode , resp_buf + res . acl_data_offset , <vul-end> acl_len ) ; <vul-start> ; if ( <vul-end> acl_len > buflen <vul-start> goto out_free ; _copy_from_pages <vul-end> ( buf , <vul-start> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <vul-end> acl_len ; out_free <vul-start> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <vul-end> ) __free_page ( <vul-start> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ) { struct nfs4_getaclargs args = {. fh = NFS_FH ( inode ),. acl_pages = NULL,. acl_len = buflen, } ; struct nfs_getaclres res = {. acl_len = buflen, } ; struct page * resp_buf = NULL ; struct nfs4_getaclargs res = {. acl_len = buflen, } ; void * resp_buf ; struct page * localpage = NULL ; int ret ; if ( buflen < PAGE_SIZE ) { resp_buf = page_address ( NULL ) ; if ( resp_buf == NULL ) return - ENOMEM ; args. acl_pages = NULL ; args. acl_pgbase = 0 ; args. acl_len = PAGE_SIZE ; } else { void * resp_buf ; void * resp_buf ; void * res ; int ret ; if ( buflen < PAGE_SIZE ) { resp_buf = page_address ( buf ) ; if ( localpage ) memcpy ( buf, resp_buf, res. acl_len ) ; } else { nfs4_write_cached_acl ( inode, resp_buf, res. acl_len ) ; } ret = res. acl_len ; out_free : if ( localpage ) __free_page ( localpage ) ; return ret ; } <vul-end>      \n"
  },
  {
    "id": 44,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; <vul-start> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <vul-end> <vul-start> if ( job_id ) <vul-end> free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <vul-end> ( job_id ) <vul-start> ( job_id ) ; free ( coinbase1 ) ; <vul-end> free ( coinbase2\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ntime ) { <vul-end> goto out ;\n"
  },
  {
    "id": 45,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <vul-start> utee_param_to_param ( param , callee_params ) ; <vul-end> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> return res ; res = utee_param_to_param ( utc , <vul-end> param , callee_params <vul-start> , callee_params ) ; if ( res != TEE_SUCCESS ) return res\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return res ; res = <vul-start>, callee_params ) ; if ( res!= TEE_SUCCESS ) return res\n"
  },
  {
    "id": 46,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } if ( ( flags & MagickFalse ) || ( <vul-start> storage_class == PseudoClass )\n"
  },
  {
    "id": 47,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( \"Unable to get gateway certificate.\\\\n\" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <vul-start> char common_name [ FIELD_SIZE + 1 ] ; <vul-end> if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , <vul-start> FIELD_SIZE ) == 0 ) <vul-end> cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( \"Gateway certificate validation succeeded.\\\\n\" ) ; ret = 0 ; goto free_cert ; } log_debug ( \"Gateway certificate validation failed.\\\\n\" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( \"Could not compute certificate sha256 digest.\\\\n\" ) ; goto free_cert ; } for",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start> ; # else if ( validate_hostname ( <vul-end> tunnel -> config <vul-start> -> gateway_host , cert ) == MatchFound <vul-end> ) cert_valid =\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ; # else const <vul-start> + 1 ] = { 0 } <vul-start> ) == 0 && strlen ( tunnel -> config -> gateway_host ) == 1\n"
  },
  {
    "id": 48,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-end> <vul-start> if ( ses -> server -> sign ) { <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-start> } <vul-end> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <vul-start> -> sign ) <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> sec_blob -> NegotiateFlags\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM <vul-end> | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-start> server -> sign && <vul-end> ses -> ntlmssp <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> sec_blob -> NegotiateFlags\n"
  },
  {
    "id": 49,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int vp8_rd_pick_best_mbsegmentation ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * best_ref_mv , int best_rd , int * mdcounts , int * returntotrate , int * returnyrate , int * returndistortion , int mvthresh ) { int i ; BEST_SEG_INFO bsi ; <vul-start> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <vul-end> bsi . segment_rd = best_rd ; bsi . ref_mv = best_ref_mv ; bsi . mvp . as_int = best_ref_mv -> as_int ; bsi . mvthresh = mvthresh ; bsi . mdcounts = mdcounts ; for ( i = 0 ; i < 16 ; i ++ ) { bsi . modes [ i ] = ZERO4X4 ; } if ( cpi -> compressor_speed == 0 ) { rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; } else { int sr ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; if ( bsi . segment_rd < best_rd ) { int col_min = ( ( best_ref_mv -> as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv -> as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv -> as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv -> as_mv . row >>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> BEST_SEG_INFO bsi ; memset <vul-end> ( & bsi\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> BEST_SEG_INFO bsi ; memset <vul-end> ( & bsi\n"
  },
  {
    "id": 50,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , \"(s=%d) processRequest(): read(): %m\" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , \"(s=%d) request connection closed\" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <vul-start> if ( p + l > buf + n ) { <vul-end> syslog ( LOG_WARNING , \"bad request (length encoding l=%u n=%u)\" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , \"bad request (length=0, type=%d)\" , type ) ; goto error ; } syslog ( LOG_INFO , \"(s=%d) request",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ( size_t ) <vul-end> buf + n <vul-start> ; if ( l >= ("
  },
  {
    "id": 51,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> oldubufs ) { vhost_net_ubuf_put_wait_and_free <vul-end> ( oldubufs ) <vul-start> ( ubufs ) vhost_net_ubuf_put_wait_and_free <vul-end> ( ubufs )\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> oldubufs ) { if (! vhost_net_ubuf_get ( oldubufs ) ) { r = - EFAULT ; goto err_ubufs ; } <vul-start> ( ubufs ) { if (! vhost_net_ubuf_get ( ubufs ) ) { r = - EFAULT ; goto err_ubufs ; } <vul-end> err_ubufs : fput\n"
  },
  {
    "id": 52,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , \"unimplemented HWCR wrmsr: 0x%llx\\\\n\" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , \"unimplemented MMIO_CONF_BASE wrmsr: \" \"0x%llx\\\\n\" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\\\n\" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( !",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> arch. pv_time_enabled = false ; vcpu -> arch.\n"
  },
  {
    "id": 53,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_alloc_compressor_data ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int width = cm -> Width ; int height = cm -> Height ; if ( vp8_alloc_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ; if ( vp8_alloc_partition_data ( cpi ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate partition data\" ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> pick_lf_lvl_frame , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate last frame buffer\" ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> scaled_source , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate scaled source buffer\" ) ; vpx_free ( cpi -> tok ) ; { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING unsigned int tokens = 8 * 24 * 16 ; # else unsigned int tokens = cm -> mb_rows * cm -> mb_cols * 24 * 16 ; # endif CHECK_MEM_ERROR ( cpi -> tok , vpx_calloc ( tokens , sizeof ( * cpi -> tok ) ) ) ; } cpi -> zeromv_count = 0 ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; memset <vul-end> ( cpi -> <vul-start> ) ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; memset <vul-end> ( cpi -> <vul-start> ) ) ; memset <vul-end> ( cpi ->\n"
  },
  {
    "id": 54,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int jpc_dec_tiledecode ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { int i ; int j ; jpc_dec_tcomp_t * tcomp ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; int compno ; int rlvlno ; int bandno ; int adjust ; int v ; jpc_dec_ccp_t * ccp ; jpc_dec_cmpt_t * cmpt ; if ( jpc_dec_decodecblks ( dec , tile ) ) { jas_eprintf ( \"jpc_dec_decodecblks failed\\\\n\" ) ; return - 1 ; } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { if ( ! rlvl -> bands ) { continue ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } jpc_undo_roi ( band -> data , band -> roishift , ccp -> roishift - band -> roishift , band -> numbps ) ; if ( tile -> realmode ) { jas_matrix_asl ( band -> data , JPC_FIX_FRACBITS ) ; jpc_dequantize ( band -> data , band -> absstepsize ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> jas_eprintf ( \"RCT requires at least three components\\\\n\" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( \"RCT requires all components have the same domain\\\\n\" <vul-start> 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( \"RCT requires all components have the same domain\\\\n\" ) ; return - 1 ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> 3 ) { jas_eprintf ( \"RCT requires at least three components\\\\n\" ) ; return - 1 ; } jpc_irct ( tile -> tcomps [ 0 ]. data, tile -> tcomps [ 1 ]. data, tile -> tcomps [ 2 ]. data ) ; break ; case JPC_MCT_ICT : if ( dec -> numcomps < 3 ) { jas_eprintf ( \"ICT requires at least three components\\\\n\" ) ; return - 1 ; } jpc_iict ( tile -> tcomps [ 0 ]. data, tile -> tcomps [ 1 ]. data, tile -> tcomps [ 2 ]. data ) ; break ; } if ( tile -> realmode ) { for ( compno = 0, tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno, ++ tcomp ) { for ( i = 0 ; i < jas_matrix_numrows ( tcomp -> data ) ; ++ i ) { jas_matrix_set ( tcomp -> data, i, j, jpc_fixtoint ( tcomp -> data ) ) ; } } } else { jas_eprintf ( \"RCT requires at least three components\\\\n\" ) ; return - 1 ; } jpc_iict ( tile -> tcomps [ 0 ]. data, tile -> tcomps [ 1 ]. data, tile -> tcomps [ 2 ]. data ) ; break ; case JPC_MCT_RCT : if ( dec -> numcomps < 3 ) { jas_eprintf ( \"RCT requires at least three components\\\\n\" ) ; return - 1 ; } jpc_irct ( tile -> tcomps [ 0 ]. data, tile -> tcomps [ 1 ]. data, tile -> tcomps [ 2 ]. data ) ; break ; case JPC_MCT_ICT : if ( dec -> numcomps < 3 ) { jas_eprintf ( \"ICT requires at least three components\\\\n\" ) ; return - 1 ; } jpc_iict ( tile -> tcomps [ 0 ]. data, tile -> tcomps [ 1 ]. data, tile -> tcomps [ 2 ]. data ) ; break ; case JPC_MCT_ICT : if ( dec -> numcomps < 3 )"
  },
  {
    "id": 55,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , \"\\\\n\" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , \" \\\\t\\\\r\\\\n\" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = \"Unbalanced quotes in configuration line\" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , \"timeout\" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = \"Invalid timeout value\" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , \"tcp-keepalive\" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> == - 1 || class == CLIENT_TYPE_MASTER ) { err = \"Unrecognized client limit class: the user specified \" \"an invalid one, or \\'master\\' which has no buffer limits.\" <vul-end> ; goto loaderr\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( class == INT_MIN ) { err = \"Invalid timeout value\" ; goto loaderr ; } else if ( class ==\n"
  },
  {
    "id": 56,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <vul-start> sk_wait_data ( sk , & timeo , NULL ) ; <vul-end> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> break ; } if (! sk_is_gso ( sk ) ) { ret = - ECONNRESET ; break ; }\n"
  },
  {
    "id": 57,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s failed vm entry %x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <vul-start> return 1 ; <vul-end> case EXIT_REASON_CR_ACCESS :",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case EXIT_REASON_VMON : case EXIT_REASON_CAN_EXIT :\n"
  },
  {
    "id": 58,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyMODINIT_FUNC PyInit__ast ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ; m = PyModule_Create ( & _astmodule ) ; if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , \"AST\" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; <vul-start> if ( PyDict_SetItemString ( d , \"mod\" , ( PyObject * ) mod_type ) < 0 ) return NULL ; <vul-end> if ( PyDict_SetItemString ( d , \"Module\" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Interactive\" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Expression\" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; <vul-start> if ( PyDict_SetItemString ( d , \"Suite\" , ( PyObject * ) Suite_type ) < 0 ) return <vul-end> NULL ; if ( PyDict_SetItemString ( d , \"stmt\" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionDef\" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"AsyncFunctionDef\" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"ClassDef\" , ( PyObject * ) ClassDef_type ) < 0 ) return NULL ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <vul-start> ( d , \"FunctionType\" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <vul-start> * ) withitem_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"type_ignore\" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"TypeIgnore\" , ( PyObject * ) TypeIgnore_type\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( PyDict_SetItemString <vul-end> ( d, <vul-start> ; if ( PyDict_SetItemString <vul-end> ( d, <vul-start> ; if ( PyDict_SetItemString <vul-end> ( d,\n"
  },
  {
    "id": 59,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <vul-start> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <vul-end> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , \"Not enough memory to write MCO marker\\\\n\" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <vul-start> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <vul-end> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ;",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ] ) ; <vul-end> l_mco_size = 5 <vul-start> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ] ) ; if ( p_j2k -> m_current_tile_number >= 20 ) { return OPJ_FALSE ; } <vul-start>. m_header_tile_data ; if ( l_current_data == NULL ) { return OPJ_FALSE ; }\n"
  },
  {
    "id": 60,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int mlx5_fpga_conn_create_cq ( struct mlx5_fpga_conn * conn , int cq_size ) { struct mlx5_fpga_device * fdev = conn -> fdev ; struct mlx5_core_dev * mdev = fdev -> mdev ; u32 temp_cqc [ MLX5_ST_SZ_DW ( cqc ) ] = { 0 } ; u32 out [ MLX5_ST_SZ_DW ( create_cq_out ) ] ; struct mlx5_wq_param wqp ; struct mlx5_cqe64 * cqe ; int inlen , err , eqn ; unsigned int irqn ; void * cqc , * in ; __be64 * pas ; u32 i ; cq_size = roundup_pow_of_two ( cq_size ) ; MLX5_SET ( cqc , temp_cqc , log_cq_size , ilog2 ( cq_size ) ) ; wqp . buf_numa_node = mdev -> priv . numa_node ; wqp . db_numa_node = mdev -> priv . numa_node ; err = mlx5_cqwq_create ( mdev , & wqp , temp_cqc , & conn -> cq . wq , & conn -> cq . wq_ctrl ) ; if ( err ) return err ; for ( i = 0 ; i < mlx5_cqwq_get_size ( & conn -> cq . wq ) ; i ++ ) { cqe = mlx5_cqwq_get_wqe ( & conn -> cq . wq , i ) ; cqe -> op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK ; } inlen = MLX5_ST_SZ_BYTES ( create_cq_in ) + sizeof ( u64 ) * conn -> cq . wq_ctrl . buf . npages ; in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) { err = - ENOMEM ; goto err_cqwq ; } err = mlx5_vector2eqn ( mdev , smp_processor_id ( ) , &",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> ( err ) { kvfree ( in ) ; <vul-start> goto err_cqwq ; }\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> ( err ) { kfree ( in ) ; <vul-start> goto err_cqwq ; }\n"
  },
  {
    "id": 61,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) { <vul-start> sf -> adaptive_rd_thresh = 1 ; <vul-end> sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { <vul-start> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <vul-end> <vul-start> sf -> less_rectangular_check = 1 ; <vul-end> <vul-start> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <vul-end> : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; <vul-start> sf -> auto_mv_step_size = 1 ; <vul-end> sf -> adaptive_rd_thresh = 2 ; <vul-start> sf -> subpel_iters_per_step = 1 ; <vul-end> sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <vul-start> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <vul-end> } if ( speed >= 2 ) { <vul-start> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <vul-end> : USE_LARGESTALL ; <vul-start> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <vul-end> sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> speed ) { const int boosted = frame_is_boosted ( cpi ) ; <vul-start> adaptive_rd_thresh = 1 <vul-end> ; sf -> <vul-start> 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <vul-start> cm ) ; } <vul-start> ; sf -> <vul-end> use_rd_breakout = 1 <vul-start> ; sf -> mv . <vul-start> ; sf -> mv . <vul-start> ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <vul-start> -> tx_size_search_method = frame_is_boosted <vul-end> ( cpi ) <vul-start> : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <vul-end> ( cm -> <vul-start> ( cm -> frame_type == KEY_FRAME ) ? 0 : <vul-end> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER <vul-start> ; sf -> allow_partition_search_skip = 1 <vul-end> ; } if <vul-start> 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <vul-end> ; sf -> <vul-start> ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <vul-end> = 1 ; <vul-start> ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <vul-end> ; sf -> <vul-start> = 4 ; if ( cm -> frame_type != KEY_FRAME ) <vul-start> -> mode_search_skip_flags |= <vul-end> FLAG_EARLY_TERMINATE ; sf <vul-start> ; sf -> <vul-end> use_lp32x32fdct = 1 <vul-start> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <vul-start> ; sf -> <vul-end> optimize_coefficients = 0 <vul-start> ; sf -> mv . <vul-start> i ] = INTRA_DC <vul-end> ; sf -> <vul-start> i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> speed ) { VP9_COMMON_INFO * cpi_info = & cpi -> common ; <vul-start> -> use_square_partition_only = cpi_info -> is_intra_only <vul-end> ; sf -> <vul-start> -> less_rectangular_check = cpi_info -> use_partial_ref_search <vul-end> ; sf -> <vul-start> -> tx_size_search_method = cpi_info -> is_boosted ( cpi )? USE_FULL_RD : USE_NONE_RD ; sf -> use_rd_breakout = 1 ; sf -> use_split_method = cpi_info -> use_boosted? USE_ALL_SPLIT : USE_ALL_INTER_SPLIT ; else sf -> disable_split_method = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> use_split_method = cpi_info -> is_boosted ( cpi )? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> subpel_iters_per_step : 2 ; sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INT"
  },
  {
    "id": 62,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) else ip . u . ip6 = entry -> addr . u . ip6 ; # endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> -> mglist && mp -> timer_armed &&\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> mglist && mp -> timer_armed &&\n"
  },
  {
    "id": 63,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; BUG_ON\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, & dh <vul-end> ) ; type\n"
  },
  {
    "id": 64,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int gtStripContig ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileContigRoutine put = img -> put . contig ; uint32 row , y , nrow , nrowsub , rowstoread ; tmsize_t pos ; unsigned char * buf = NULL ; uint32 rowsperstrip ; uint16 subsamplinghor , subsamplingver ; uint32 imagewidth = img -> width ; tmsize_t scanline ; int32 fromskew , toskew ; int ret = 1 , flip ; tmsize_t maxstripsize ; TIFFGetFieldDefaulted ( tif , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplingver == 0 ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"Invalid vertical YCbCr subsampling\" ) ; return ( 0 ) ; } maxstripsize = TIFFStripSize ( tif ) ; flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) <vul-start> { <vul-end> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; nrow = ( row + rowstoread > h ? h -",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> nrow ) { uint32 temp ; <vul-start> % subsamplingver ; temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"Integer overflow in gtStripContig\" ) ; return 0 ; } <vul-start> , maxstripsize , temp <vul-end> * scanline )\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> nrow ) { uint16 subsamplingver_new = subsamplingver? subsamplingver_new : 0 ; <vul-start>, maxstripsize, subsamplingver_new <vul-end> ) == (\n"
  },
  {
    "id": 65,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( \"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , \"%s: Request was disconnected from state\" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( \"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( \"ikev2_parent_inI2outR2_tail returned %s\" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <vul-start> passert ( GLOBALS_ARE_RESET ( ) ) ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
  },
  {
    "id": 66,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <vul-start> int copied , error = - EINVAL ; <vul-end> msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( \"%d -= %d\\\\n\" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = - EINVAL <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = - EINVAL <vul-end> ; if (\n"
  },
  {
    "id": 67,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 tsize_t t2p_readwrite_pdf_image_tile ( T2P * t2p , TIFF * input , TIFF * output , ttile_t tile ) { uint16 edge = 0 ; tsize_t written = 0 ; unsigned char * buffer = NULL ; tsize_t bufferoffset = 0 ; unsigned char * samplebuffer = NULL ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; uint16 i = 0 ; ttile_t tilecount = 0 ; ttile_t septilecount = 0 ; tsize_t septilesize = 0 ; # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint32 xuint32 = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; edge |= t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; edge |= t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; if ( ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) && ( ( edge == 0 ) # if defined ( JPEG_SUPPORT ) || defined ( OJPEG_SUPPORT ) || ( t2p -> pdf_compression == T2P_COMPRESS_JPEG ) # endif ) ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t )",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> if ( count > <vul-end> 4 ) {\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> if ( count > 0 && count\n"
  },
  {
    "id": 68,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void joint_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int_mv * frame_mv , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , int * rate_mv ) { <vul-start> const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; <vul-end> const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] } ; int_mv ref_mv [ 2 ] ; int ite , ref ; <vul-start> uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; <vul-end> <vul-start> const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; <vul-end> struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ; <vul-start> struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; <vul-end> int last_besterr [ 2 ] = { INT_MAX , INT_MAX } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 0 ] ) , vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 1 ] ) } ; <vul-start> for ( ref = 0 ; ref < 2 ; ++ ref ) { <vul-end> <vul-start> ref_mv [ ref ] = mbmi -> ref_mvs [ refs [",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) { const VP9_COMMON * const cm = & cpi -> common ; const <vul-start> , ref ; <vul-end> const InterpKernel * <vul-start> * kernel = vp9_filter_kernels [ <vul-end> mbmi -> interp_filter <vul-start> mbmi -> interp_filter ] ; struct scale_factors sf <vul-end> ; struct buf_2d <vul-start> MAX_MB_PLANE ] ; <vul-end> int last_besterr [ <vul-start> ) } ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <vul-start> ref ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> as_int ; } # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <vul-start> -> sadperbit16 ; MV <vul-end> tmp_mv ; int <vul-start> 1 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <vul-start> as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <vul-end> plane [ 0 <vul-start> ) ; tmp_mv <vul-end> = frame_mv [ <vul-start> ] ] . as_mv ; tmp_mv <vul-end> . col >>= <vul-start> ; tmp_mv . <vul-end> row >>= 3 <vul-start> , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <vul-start> . as_mv , second_pred <vul-end> ) ; if <vul-start> , & tmp_mv <vul-end> , & ref_mv <vul-start> = cpi -> find_fractional_mv_step <vul-end> ( x , <vul-start> , & tmp_mv , & ref_mv [ id ] <vul-start> . as_mv , <vul-end> cpi -> common <vul-start> -> sf . mv . subpel_iters_per_step , NULL , <vul-end> x -> nmvjointcost <vul-start> 0 ] = ref_yv12 [ 0 ] <vul-end> ; if ( <vul-start> ] ] . as_mv = tmp_mv <vul-end> ; last_besterr [ <vul-start> as_mv , & x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> ) ; } <vul-end> }    \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> rate_mv ) { int ref_width = xd -> common. mb_rows ; int ref_height = xd -> common. mb_cols ; <vul-start> * second_pred = memalign <vul-end> ( 16, <vul-start> ( 16, ref_height <vul-end> * sizeof ( <vul-start> ( mbmi -> interp_filter ) ; const int filter_width = mbmi -> filter_width [ bsize ] ; const int filter_height = mbmi -> filter_height [ bsize ] <vul-end> ; struct buf_2d <vul-start> struct buf_2d scaled_first_yv12 [ 2 ] ; int last_besterr [ 2 ] = { INT_MAX, INT_MAX } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { vp9_get_scaled_ref_frame ( cpi, mbmi -> ref_frame [ 0 ] ), vp9_get_scaled_ref_frame ( cpi, mbmi -> ref_frame [ 1 ] ) } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { vp9_get_scaled_ref_frame ( cpi, mbmi -> ref_frame [ 0 ] ), vp9_get_scaled_ref_frame ( cpi, mbmi -> ref_frame [ 1 ] ) } ; const const BLOCK_SIZE bsize_aligned = bsize_aligned ; const int ref_width = xd -> common. mb_rows_aligned [ bsize ] ; const int ref_height = xd -> common. mb_rows_aligned [ bsize ] ; const int ref_width = xd -> common. mb_cols_aligned [ bsize ] ; const int ref_height = xd -> common. mb_height_aligned [ bsize ] ; const int ref_width = xd -> common. mb_cols_aligned [ bsize ] ; const int height = xd -> common. mb_rows_aligned [ bsize ] ; const int height = xd -> common. mb_cols_aligned [ bsize ] ; const int width = xd -> common. mb_cols_aligned [ bsize ] ; const int height = xd -> common. mb_cols_aligned [ bsize ] ; const int height = xd -> common. mb_rows_aligned [ bsize ] ; const int height = xd"
  },
  {
    "id": 69,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( \"AirPDcapScanForKeys\" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication: EAPOL packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not EAPOL-Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <vul-start> if ( ( tot_len - offset - 4 ) < bodyLength ) { <vul-end> AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"EAPOL body too short\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> if ( ( ( <vul-start> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( tot_len < offset + 4 ||\n"
  },
  {
    "id": 70,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_all_tile_parts ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , opj_stream_private_t * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 tilepartno = 0 ; OPJ_UINT32 l_nb_bytes_written = 0 ; OPJ_UINT32 l_current_nb_bytes_written ; OPJ_UINT32 l_part_tile_size ; OPJ_UINT32 tot_num_tp ; OPJ_UINT32 pino ; OPJ_BYTE * l_begin_data ; opj_tcp_t * l_tcp = 00 ; opj_tcd_t * l_tcd = 00 ; opj_cp_t * l_cp = 00 ; l_tcd = p_j2k -> m_tcd ; l_cp = & ( p_j2k -> m_cp ) ; l_tcp = l_cp -> tcps + p_j2k -> m_current_tile_number ; tot_num_tp = opj_j2k_get_num_tp ( l_cp , 0 , p_j2k -> m_current_tile_number ) ; ++ p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; for ( tilepartno = 1 ; tilepartno < tot_num_tp ; ++ tilepartno ) { p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = tilepartno ; l_current_nb_bytes_written = 0 ; l_part_tile_size = 0 ; l_begin_data = p_data ; <vul-start> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <vul-end> p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } p_data += l_current_nb_bytes_written ; l_nb_bytes_written += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_part_tile_size , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm (",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> , p_data , p_total_data_size , <vul-start> , p_data , p_total_data_size ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, p_data, p_total_data_size,\n"
  },
  {
    "id": 71,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void ecryptfs_decode_from_filename ( unsigned char * dst , size_t * dst_size , const unsigned char * src , size_t src_size ) { u8 current_bit_offset = 0 ; size_t src_byte_offset = 0 ; size_t dst_byte_offset = 0 ; if ( dst == NULL ) { ( * dst_size ) = ecryptfs_max_decoded_size ( src_size ) ; goto out ; } while ( src_byte_offset < src_size ) { unsigned char src_byte = filename_rev_map [ ( int ) src [ src_byte_offset ] ] ; switch ( current_bit_offset ) { case 0 : dst [ dst_byte_offset ] = ( src_byte << 2 ) ; current_bit_offset = 6 ; break ; case 6 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 4 ) ; dst [ dst_byte_offset ] = ( ( src_byte & 0xF ) << 4 ) ; current_bit_offset = 4 ; break ; case 4 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 2 ) ; dst [ dst_byte_offset ] = ( src_byte << 6 ) ; current_bit_offset = 2 ; break ; case 2 : dst [ dst_byte_offset ++ ] |= ( src_byte ) ; <vul-start> dst [ dst_byte_offset ] = 0 ; <vul-end> current_bit_offset = 0 ; break ; } src_byte_offset ++ ; } ( * dst_size ) = dst_byte_offset ; out : return ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> src_byte ) ; <vul-end> current_bit_offset = 0\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> src_byte ) ; if ( dst_byte_offset >= * dst_size ) { ( * dst_size ) = ecryptfs_max_decoded_size ( src_size ) ; goto out ; }\n"
  },
  {
    "id": 72,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ifindex ; else { dst = skb_dst ( skb ) ; <vul-start> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <vul-end> if ( (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ifindex ; else { struct ipv6_txoptions * opt ; opt = rcu_dereference <vul-end> ( skb_dst ( <vul-start> ) -> dev ) ; if ( opt ) iif = opt -> ifindex ; } <vul-end> if ( (\n"
  },
  {
    "id": 73,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int init_pci ( struct vmctx * ctx ) { struct mem_range mr ; struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; size_t lowmem ; int bus , slot , func ; int success_cnt = 0 ; int error ; pci_emul_iobase = PCI_EMUL_IOBASE ; pci_emul_membase32 = vm_get_lowmem_limit ( ctx ) ; pci_emul_membase64 = PCI_EMUL_MEMBASE64 ; create_gsi_sharing_groups ( ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; bi -> iobase = pci_emul_iobase ; bi -> membase32 = pci_emul_membase32 ; bi -> membase64 = pci_emul_membase64 ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; <vul-start> assert ( ops != NULL ) ; <vul-end> pr_notice ( \"pci init %s\\\\r\\\\n\" , fi -> fi_name ) ; error = pci_emul_init ( ctx , ops , bus , slot , func , fi ) ; if ( error ) { pr_err ( \"pci %s init failed\\\\n\" , fi -> fi_name ) ; goto pci_emul_init_fail ; } success_cnt ++ ; } } pci_emul_iobase += BUSIO_ROUNDUP ; pci_emul_iobase = roundup2 ( pci_emul_iobase , BUSIO_ROUNDUP ) ; bi -> iolimit = pci_emul_iobase",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pr_notice ( \"pci init %s\\\\r\\\\n\" <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; bzero ( <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; bzero ( <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; return 0 <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pci_emul_deinit ( ctx\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ops < 0 ) goto pci_emul_init_fail <vul-end> ; pr_notice ( <vul-start> mr ) ; if ( ops < 0 ) goto pci_emul_init_fail <vul-end> ; bzero ( <vul-start> mr ) ; if ( ops < 0 ) goto pci_emul_init_fail <vul-end> ; pr_notice ( <vul-start> fi_name ) ; if ( ops < 0 ) goto pci_emul_init_fail <vul-end> ; pci_emul_deinit (\n"
  },
  {
    "id": 74,
    "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int ivr_read_header ( AVFormatContext * s ) { unsigned tag , type , len , tlen , value ; int i , j , n , count , nb_streams = 0 , ret ; uint8_t key [ 256 ] , val [ 256 ] ; AVIOContext * pb = s -> pb ; AVStream * st ; int64_t pos , offset , temp ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; avio_skip ( pb , 5 ) ; temp = avio_rb64 ( pb ) ; while ( ! avio_feof ( pb ) && temp ) { offset = temp ; temp = avio_rb64 ( pb ) ; } avio_skip ( pb , offset - avio_tell ( pb ) ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 16 ) ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; } if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb",
    "golden_answers": [
      "CWE-834 Fixed Code Lines are: <vul-start> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> ) ) ; }\n"
    ],
    "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> j ++ ) { avio_get_str ( pb, len, key, sizeof ( key ) ) ; <vul-start> ) ) ; }\n"
  },
  {
    "id": 75,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = joinbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int hstartcol ; if ( bufsize > QMFB_JOINBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } hstartcol = ( numrows + 1 - parity ) >> 1 ; n = hstartcol ; srcptr = & a [ 0 ] ; dstptr = buf ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } srcptr += stride ; dstptr += JPC_QMFB_COLGRPSIZE ; } srcptr = & a [ hstartcol * stride ] ; dstptr = & a [ ( 1 - parity ) * stride ] ; n = numrows - hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += stride",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( buf == joinbuf &&\n"
  },
  {
    "id": 76,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , \"title\" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; if ( strcmp ( sub_demuxer -> name , \"srt\" ) && strcmp ( sub_demuxer -> name , \"ass\" ) ) goto error ; if (\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> avformat_alloc_context ( ) ) ) goto error ; if (! ast -> sub_ctx -> pb\n"
  },
  {
    "id": 77,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_cyclic_refresh_setup ( VP9_COMP * const cpi ) { VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; struct segmentation * const seg = & cm -> seg ; <vul-start> unsigned char * const seg_map = cpi -> segmentation_map ; <vul-end> <vul-start> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; <vul-end> if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) || <vul-start> ( cpi -> svc . temporal_layer_id > 0 ) ) { <vul-end> vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_disable_segmentation ( & cm -> seg ) ; <vul-start> if ( cm -> frame_type == KEY_FRAME ) <vul-end> <vul-start> cr -> sb_index = 0 ; <vul-end> return ; } else { int qindex_delta = 0 ; <vul-start> int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ; <vul-end> int xmis , ymis , x , y , qindex2 ; <vul-start> const float rate_ratio_qdelta = 2.0 ; <vul-end> vp9_clear_system_state ( ) ; cr -> max_sbs_perframe = 10 ; cr -> max_qdelta_perc = 50 ; cr -> min_block_size = BLOCK_8X8 ; cr -> time_for_refresh = 1 ; cr -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 2 ; cr -> thresh_dist_sb = 8 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * vp9_convert_qindex_to_q ( cm -> base_qindex ) ) ; if ( cpi -> sf . use_nonrd_pick_mode ) { cr -> thresh_rate_sb",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; <vul-end> const int apply_cyclic_refresh <vul-start> , rc ) ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <vul-start> > 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <vul-end> ( seg_map , <vul-start> == KEY_FRAME ) { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; <vul-start> = 0 ; } <vul-start> 0 ; int <vul-end> qindex2 ; const <vul-start> qindex2 ; const double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <vul-end> ; qindex2 = <vul-start> ( seg , CR_SEGMENT_ID_BOOST1 <vul-end> , SEG_LVL_ALT_Q , <vul-start> qindex_delta ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; const int is_keyframe = ( cm -> frame_type == KEY_FRAME ) ; <vul-start>, rc ) ; int qindex_delta = 0 ; int i, block_count, bl_index, sb_rows, sb_cols, sbs_in_frame <vul-start> 0 ) ) { if ( cpi -> sf. use_nonrd_pick_mode ) { if ( cpi -> svc. temporal_layer_id > 0 ) { seg_map [ 0 ] = 0 ; } else { seg_map [ 0 ] = 0 ; } } else if ( is_keyframe ) { if ( cpi -> svc. temporal_layer_id == 0 ) { seg_map [ 0 ] = 0 ; } else { seg_map [ 0 ] = cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg_map [ cpi -> seg. seg. seg_map [ cpi -> seg. seg. seg. seg. seg. seg. seg. seg. seg. seg. seg. seg. <vul-start> == KEY_FRAME ) { <vul-start> = 0 ; } <vul-start> float rate_ratio_qdelta = 2.0 <vul-end> ; vp9_clear_system_state ( <vul-start> qindex2 ) ; seg -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 2 ; cr -> thresh_dist_sb = 8 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * vp9_convert_qindex_to_q ( cm -> base_qindex ) * vp9_convert_qindex_to_q ( cm -> base_qindex ) ) ;\n"
  },
  {
    "id": 78,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; <vul-start> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <vul-end> int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\\\'' && * raw != \\'\"\\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { <vul-start> char * s = \"\" ; <vul-end> char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , 0 ) <vul-end> ) ; char <vul-start> errstr ) { const\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, * s <vul-end> ; char * <vul-start> errstr ) { <vul-end> char buf [ <vul-start> char * s <vul-end> ; s = <vul-start> ) ; } if (! str ) return NULL ;\n"
  },
  {
    "id": 79,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ; <vul-start> int is_keyframe_qaunt_set = 0 ; <vul-end> vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , \" \" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"option missing value: %s\\\\n\" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } <vul-start> if ( strcmp ( \"encoding-mode\" , option_name ) == 0 ) { <vul-end> res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> } else if ( strcmp ( \"layers\" , option_name ) == 0 ) { <vul-end> svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> } else if ( strcmp ( \"quantizers\" , option_name ) == 0 ) { <vul-end> res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> if ( ! is_keyframe_qaunt_set ) { <vul-end> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <vul-end> ; if ( <vul-start> ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <vul-end> ) ; if <vul-start> ( strcmp ( \"max-quantizers\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <vul-end> ) ; if <vul-start> ( strcmp ( \"min-quantizers\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <vul-end> ) ; if <vul-start> ) break ; } else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <vul-end> ) ; if <vul-start> ) break ; } else if ( strcmp ( \"bitrates\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <vul-end> ; } else <vul-start> input_string ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: auto alt ref: Maxinum %d(REF_FRAMES - layers) layers could\" \"enabled auto alt reference frame, but % layers are enabled\\\\n\" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * input_ptr ; <vul-end> vpx_codec_err_t res = <vul-start> } if ( ( option_name == NULL ) || <vul-start> ( \"encoding-mode\", option_name ) == 0 ) || ( <vul-start> ( \"layers\", option_name ) == 0 ) || ( <vul-start> ( \"scale-factors\", option_name ) == 0 ) || ( <vul-start> ( \"quantizers\", option_name ) == 0 ) ) { res = parse_quantizer_values ( svc_ctx, option_value, 0 ) ; if ( res!= VPX_CODEC_OK ) break ; if ( is_keyframe_qaunt_set ( svc_ctx ) <vul-end> ) { SvcInternal <vul-start> ; if ( <vul-end> res!= VPX_CODEC_OK <vul-start> ) break ; <vul-end> } else { <vul-start> input_string ) ; }\n"
  },
  {
    "id": 80,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotate_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; <vul-start> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; <vul-end> while ( EOFBlob ( image ) != MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> int depth ; quantum_info = ( QuantumInfo * ) NULL ; <vul-start> ) ; } if ( quantum_info != ( QuantumInfo * ) NULL )\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> int depth ; MagickBooleanType quantum_status ; <vul-start> ) ; } quantum_status = SetQuantumExtent ( image, quantum_info, quantum_info -> quantum_columns, quantum_info -> quantum_rows ) ; if ( quantum_status == MagickFalse ) break ;\n"
  },
  {
    "id": 81,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - ENOMEM ; <vul-start> interface = intf -> cur_altsetting ; <vul-end> endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - EIO ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , interface -> desc . bInterfaceNumber , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , \"/input0\" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch (",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> intf -> cur_altsetting ; if (! interface -> desc. bNumEndpoints ) return - EINVAL\n"
  },
  {
    "id": 82,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <vul-start> const char * data , int optional ) <vul-end> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <vul-start> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <vul-end> if ( optional ) { INFO ( \"failed to mount \\'%s\\' on \\'%s\\' (optional): %s\" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( \"remounting %s on %s to respect bind or remount options\" , fsname ? fsname : \"(none)\" , target ? target : \"(none)\" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( \"(at remount) flags for %s was %lu, required extra flags are %lu\" , fsname , sb . f_flag , required_flags",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> , int optional , const char * rootfs <vul-start> endif if ( safe_mount <vul-end> ( fsname , <vul-start> MS_REMOUNT , data , rootfs <vul-start> , data ) < 0\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start>, int optional, uid_t * check_ruid <vul-start> endif if ( safe_mount <vul-end> ( fsname, <vul-start> MS_REMOUNT, data, check_ruid\n"
  },
  {
    "id": 83,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <vul-start> cleanup_free char * base_path = NULL ; <vul-end> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , \"--version\" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( \"prctl(PR_SET_NO_NEW_CAPS) failed\" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( \"--cap-add in setuid mode can be used only by root\" ) ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> mode_t old_umask ; const <vul-end> char * base_path <vul-start> ; base_path = \"/tmp\" ; <vul-end> __debug__ ( (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> char * base_path = NULL ; cleanup_free char * tmp_path <vul-start> \"Can\\'t open /proc\" ) ; tmp_path = mkdtemp ( \"/run/user/%d/.bubblewrap\", real_uid ) ; if ( ensure_dir ( tmp_path, 0755 ) ) { free ( tmp_path ) ; base_path = tmp_path ; } <vul-start> = xasprintf ( \"/tmp/.bubblewrap-%d\" <vul-end>, real_uid )\n"
  },
  {
    "id": 84,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int hfsplus_readdir ( struct file * filp , void * dirent , filldir_t filldir ) { struct inode * inode = filp -> f_path . dentry -> d_inode ; struct super_block * sb = inode -> i_sb ; int len , err ; char strbuf [ HFSPLUS_MAX_STRLEN + 1 ] ; hfsplus_cat_entry entry ; struct hfs_find_data fd ; struct hfsplus_readdir_data * rd ; u16 type ; if ( filp -> f_pos >= inode -> i_size ) return 0 ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & fd ) ; if ( err ) return err ; hfsplus_cat_build_key ( sb , fd . search_key , inode -> i_ino , NULL ) ; err = hfs_brec_find ( & fd ) ; if ( err ) goto out ; switch ( ( u32 ) filp -> f_pos ) { case 0 : if ( filldir ( dirent , \".\" , 1 , 0 , inode -> i_ino , DT_DIR ) ) goto out ; filp -> f_pos ++ ; case 1 : <vul-start> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <vul-end> fd . entrylength ) ; if ( be16_to_cpu ( entry . type ) != HFSPLUS_FOLDER_THREAD ) { printk ( KERN_ERR \"hfs: bad catalog folder thread\\\\n\" ) ; err = - EIO ; goto out ; } if ( fd . entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR \"hfs: truncated catalog thread\\\\n\" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , \"..\" , 2 , 1 ,",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <vul-start> out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; }\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> case 1 : if ( fd. entrylength > sizeof ( entry ) ) { printk ( KERN_ERR \"hfs: truncated catalog folder entry\\\\n\" ) ; err = - EIO ; goto out ; }\n"
  },
  {
    "id": 85,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <vul-start> dec -> xstart = siz -> xoff ; <vul-end> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV (",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * cmpt ; size_t size ; <vul-start> tileheight ) ; if ( ! jas_safe_size_mul ( <vul-end> dec -> numhtiles <vul-start> dec -> numhtiles , <vul-end> dec -> numvtiles <vul-start> dec -> numvtiles , & size <vul-end> ) ) { <vul-start> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( \"numtiles = %d; numhtiles = %d; numvtiles = %d;\\\\n\" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * cmpt ; int numtiles ; <vul-start> tileheight ) ; numtiles = JAS_MIN ( dec -> numhtiles, dec -> numvtiles ) ; dec -> tiles = jas_alloc2 ( numtiles, sizeof ( jpc_dec_tile_t ) ) ) { return - 1 ; } for ( tileno = 0, tile = dec -> tiles ; tileno < numtiles ; ++ tileno, ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> xstart = JAS_MAX ( dec -> xstart, dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> yend, dec -> yoff ) ; dec -> tilewidth = JAS_MAX ( dec -> tilewidth, dec -> tileheight ) ; dec -> tileheight = JAS_MAX ( dec -> yend, dec -> tileheight ) ; dec -> tilexoff = JAS_MAX ( dec -> tilexoff, dec -> tilewidth ) ; dec -> tileyoff = JAS_MAX ( dec -> yend, dec -> tileheight ) ; dec -> tilexoff = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tileheight = JAS_MAX ( dec -> tileyoff, dec -> tilewidth ) ; dec -> tileheight = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tilexoff = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tileyoff = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tileyoff = JAS_MAX ( dec -> tilexoff, dec -> tileheight ) ; dec -> tilexoff = JAS_MAX ( dec -> tileyoff, dec -> tilewidth ) ; dec -> tileyoff = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tileyoff = JAS_MAX ( dec -> tileyoff, dec -> tileheight ) ; dec -> tileyoff = JAS_MAX ( dec -> tilexoff, dec -> tileheight ) ; dec -> tileyoff = JAS_MAX"
  },
  {
    "id": 86,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; <vul-start> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <vul-end> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; <vul-start> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <vul-end> return KADM5_BAD_MASK ; <vul-start> if ( entry == ( kadm5_principal_ent_t ) NULL ) <vul-end> return EINVAL ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; if ( ret ) return ( ret ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ; if ( ret ) goto done ; adb . aux_attributes |= KADM5_POLICY ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( entry == NULL ) return EINVAL ; if ( <vul-start> KADM5_POLICY ) && entry -> policy == NULL <vul-end> ) return KADM5_BAD_MASK <vul-start> ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = krb5_get_entry ( handle, entry -> principal, & kdb, & adb ) ; if ( ret ) return ( ret ) ; if ( <vul-start> & KADM5_POLICY ) ) { ret = KADM5_BAD_MASK ; goto done ; } ret = check_tl_data_flags ( handle -> context, kdb, entry -> tl_data, mask ) ; if ( ret ) goto done ; if ( mask & KADM5_TL_DATA ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } ret = check_tl_data_flags ( handle -> context, kdb, entry -> tl_data, mask ) ; if ( ret ) goto done ; ret = KADM5_OK ; done : if ( have_pol ) { ret2 = kadm5_free_policy_ent_rec ( handle -> lhandle, & adb ) ; if ( ret ) goto done ; ret = ret2 ; } if ( have_pol ) { ret2 = kadm5_free_policy_ent_rec ( handle -> lhandle, & adb ) ; if ( ret ) goto done ; ret = ret2 ; } if ( have_pol ) { ret = KADM5_BAD_MASK ; goto done ; } ret = kadm5_free_policy_ent_rec ( handle -> context, kdb, & adb ) ; if ( ret ) goto done ; ret = KADM5_BAD_MASK ; if ( ret2 ) goto done ; ret = kadm5_free_policy_ent_rec ( handle -> lhandle, & adb ) ; if ( ret ) goto done ; ret = KADM5_OK ; done : if ( have_pol ) { ret"
  },
  {
    "id": 87,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <vul-start> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <vul-end> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , \"n:%\" PRId64 \" pts:%s pts_time:%s pos:%\" PRId64 \" \" \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \" \"checksum:%08X plane_checksum:[%08X\" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> frame -> data [ plane ] && frame -> linesize <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
  },
  {
    "id": 88,
    "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 int <vul-start> run_cmd ( int fd , ... ) <vul-end> { pid_t pid ; sigset_t sigm , sigm_old ; sigemptyset ( & sigm ) ; sigaddset ( & sigm , SIGTERM ) ; sigprocmask ( SIG_BLOCK , & sigm , & sigm_old ) ; pid = fork ( ) ; if ( pid < 0 ) { sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; fd_printf ( STO , \"*** cannot fork: %s ***\\\\r\\\\n\" , strerror ( errno ) ) ; return - 1 ; } else if ( pid ) { int status , r ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; do { r = waitpid ( pid , & status , 0 ) ; } while ( r < 0 && errno == EINTR ) ; term_apply ( STI ) ; if ( WIFEXITED ( status ) ) { fd_printf ( STO , \"\\\\r\\\\n*** exit status: %d ***\\\\r\\\\n\" , WEXITSTATUS ( status ) ) ; return WEXITSTATUS ( status ) ; } else if ( WIFSIGNALED ( status ) ) { fd_printf ( STO , \"\\\\r\\\\n*** killed by signal: %d ***\\\\r\\\\n\" , WTERMSIG ( status ) ) ; return - 1 ; } else { fd_printf ( STO , \"\\\\r\\\\n*** abnormal termination: 0x%x ***\\\\r\\\\n\" , r ) ; return - 1 ; } } else { long fl ; <vul-start> char cmd [ 512 ] ; <vul-end> term_remove ( STI ) ; term_erase ( fd ) ; fl = fcntl ( fd , F_GETFL ) ; fl &= ~ O_NONBLOCK ; fcntl ( fd , F_SETFL",
    "golden_answers": [
      "CWE-77 Fixed Code Lines are: <vul-start> int fd , const char * cmd , const char * args_extra <vul-end> ) { pid_t <vul-start> long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <vul-end> ; term_remove ( <vul-start> STO ) ; argc = 0 ; r = split_quoted <vul-end> ( cmd , <vul-start> ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , \"Cannot parse command\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , \"Cannot parse extra args\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , \"No command given\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , \"$ %s %s\\\\n\" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <vul-end> fd_printf ( STDERR_FILENO <vul-start> ( STDERR_FILENO , \"exec: %s\\\\n\" , strerror ( errno ) <vul-end> ) ; exit <vul-start> ; exit ( RUNCMD_EXEC_FAIL <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> fd,..., char * * cmd <vul-start> va_list vls ; <vul-end> va_start ( vls <vul-start> '\\\\0' ; } <vul-end> establish_child_signal_handlers ( ) <vul-start> NULL ) ; free ( cmd ) ;\n"
  },
  {
    "id": 89,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( \"mvs.stt\" , \"a\" ) ; mb_index = 0 ; fprintf ( mvs , \"Mb Modes for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs , \"Mb mv ref for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs , \"UV Modes for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , \"\\\\n\" ) <vul-end> ; fprintf ( <vul-start> \"\\\\n\" ) ; <vul-end> fprintf ( mvs\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"\\\\n\" ) ; <vul-end> { int b_row <vul-start> \"\\\\n\" ) ; <vul-end> } fprintf (\n"
  },
  {
    "id": 90,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - ENOMEM ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000U / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000U / sizeof ( struct kiocb ) ) ) ) { pr_debug ( \"ENOMEM: nr_events too high\\\\n\" ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2UL ) ) return ERR_PTR ( - EAGAIN ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , GFP_KERNEL ) ; if ( ! ctx ) return ERR_PTR ( - ENOMEM ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; INIT_LIST_HEAD ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch =",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ; err : <vul-end> free_percpu ( ctx\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; err : mutex_lock ( & ctx -> users. lock ) ; list_del ( & ctx -> node ) ; mutex_unlock ( & ctx -> users. lock ) ;\n"
  },
  {
    "id": 91,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } <vul-start> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <vul-end> return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( \"all tiles are outside the image area\\\\n\" ) ; return - 1 ; } if (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> comps = jas_alloc3 ( siz -> numcomps, <vul-end> sizeof ( jpc_sizcomp_t\n"
  },
  {
    "id": 92,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <vul-start> int yy , mm , dd , hr , min , sec , csec ; <vul-end> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <vul-start> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" , <vul-end> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine: purported control blade line doesn\\'t have code values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <vul-start> \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d,",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> sec , csec , <vul-end> pkt_len ; int <vul-start> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end> , & yy <vul-start> ( line , \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end> , direction , <vul-start> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine: packet header has a negative packet length\" ) ; return FALSE\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> sec, csec, neg <vul-start> ( line, \"%4d-%2d-%2d,%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end>, & yy <vul-start> ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end>, & yy <vul-start> ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end>, direction, <vul-start> ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end>, direction, <vul-start> FALSE ; } if ( pkt_len < 0 || pkt_len > WTAP_MAX_PACKET_SIZE ||! valid_packet_length ( line, caplen ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine: packet line doesn\\'t have a valid packet length\" ) ; return FALSE ; }\n"
  },
  {
    "id": 93,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) \"xdg-open\" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( \"View/edit a text file\" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_Save\" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_Cancel\" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , scrolled , TRUE , TRUE , 0 ) ; gtk_widget_set_size_request ( scrolled , 640 , 480 ) ; gtk_widget_show",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> == GTK_RESPONSE_OK ) { <vul-start> item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> == GTK_RESPONSE_OK ) { <vul-start> item_name ) ; }\n"
  },
  {
    "id": 94,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int main ( int argc , char * * argv ) { setlocale ( LC_ALL , \"\" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\\\n\" \"\\\\t[-r REPO]\\\\n\" \"\\\\n\" \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\\\n\" \"ABRT system cache.\" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = \"build_ids\" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , \"yes\" , NULL , _ ( \"Noninteractive, assume \\'Yes\\' to all questions\" ) ) , OPT_STRING ( 'i' , \"ids\" , & build_ids , \"BUILD_IDS_FILE\" , _ ( \"- means STDIN, default: build_ids\" ) ) , OPT_STRING ( 'e' , \"exact\" , & exact , \"EXACT\" , _ ( \"Download only specified files\" ) ) , OPT_STRING ( 'r' , \"repo\" , & repo , \"REPO\" , _ ( \"Pattern to use when searching for repos, default: *debug*\" ) ) , OPT_STRING ( 's' , \"size_mb\" , & size_mb , \"SIZE_MB\" , _ ( \"Ignored option\" ) ) , OPT_END ( ) } ; const unsigned opts",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR \"/abrt-tmp-debuginfo.XXXXXX\" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( \"Failed to create working directory\" ) ; log_info ( \"Created working directory: %s\" , tmp_directory ) ; const char * args [ 13 <vul-end> ] ; { <vul-start> ++ ] = \"--tmpdir\" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <vul-start> ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( \"fork\" ) ; if ( pid == 0 ) { <vul-start> ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( \"waitpid\" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( \"Removed working directory: %s\" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( \"Failed to remove working directory\" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( \"Child terminated with signal %d\" , WTERMSIG ( status ) ) ; error_msg_and_die ( \"Child exit failed\" ) ; }\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> ) ; } # if 0 <vul-start> ) ; } # endif <vul-start> ) ; } # if 0 <vul-start> args ) ; # endif\n"
  },
  {
    "id": 95,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = \"\" ; const char * corrupt = \"corrupt: \" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = \"Can\\'t read SAT\" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( \"SAT\" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = \"Can\\'t read SSAT\" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( \"SSAT\" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = \"Can\\'t read directory\" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> scn , root_storage <vul-end> ) ) <\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> root_storage -> d_storage_uuid, root_storage\n"
  },
  {
    "id": 96,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int ndp_sock_recv ( struct ndp * ndp ) { struct ndp_msg * msg ; enum ndp_msg_type msg_type ; size_t len ; int err ; msg = ndp_msg_alloc ( ) ; if ( ! msg ) return - ENOMEM ; len = ndp_msg_payload_maxlen ( msg ) ; err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , <vul-start> & msg -> addrto , & msg -> ifindex ) ; <vul-end> if ( err ) { err ( ndp , \"Failed to receive message\" ) ; goto free_msg ; } <vul-start> dbg ( ndp , \"rcvd from: %s, ifindex: %u\" , <vul-end> <vul-start> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <vul-end> if ( len < sizeof ( * msg -> icmp6_hdr ) ) { warn ( ndp , \"rcvd icmp6 packet too short (%luB)\" , len ) ; err = 0 ; goto free_msg ; } err = ndp_msg_type_by_raw_type ( & msg_type , msg -> icmp6_hdr -> icmp6_type ) ; if ( err ) { err = 0 ; goto free_msg ; } ndp_msg_init ( msg , msg_type ) ; ndp_msg_payload_len_set ( msg , len ) ; if ( ! ndp_msg_check_valid ( msg ) ) { warn ( ndp , \"rcvd invalid ND message\" ) ; err = 0 ; goto free_msg ; } dbg ( ndp , \"rcvd %s, len: %zuB\" , ndp_msg_type_info ( msg_type ) -> strabbr , len ) ; if ( ! ndp_msg_check_opts ( msg ) ) { err = 0 ; goto free_msg ; } err = ndp_call_handlers",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> msg -> ifindex , & msg -> hoplimit <vul-start> ( ndp , \"rcvd from: %s, ifindex: %u, hoplimit: %d\" <vul-end> , str_in6_addr ( <vul-start> msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , \"ignoring packet with bad hop limit (%d)\" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <vul-end> if ( len\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> & msg -> if_addr <vul-end>, & msg <vul-start> & msg -> if_index <vul-end> ) ; if <vul-start> ( ndp, \"rcvd from: %s, ifindex: %u, addrto: %s\" <vul-end>, str_in6_addr ( <vul-start>, msg -> if_addr <vul-end> ) ; if\n"
  },
  {
    "id": 97,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <vul-start> struct mlx5_ib_create_qp_resp resp ; <vul-end> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , \"block multicast loopback isn\\'t supported\\\\n\" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , \"cross-channel isn\\'t",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> struct mlx5_ib_create_qp_resp resp = { }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct mlx5_ib_create_qp_resp resp = { 0 } <vul-start> ; resp. data = ( void * ) & resp ; resp.\n"
  },
  {
    "id": 98,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == BR_STATE_DISABLED ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = PTR_ERR ( mp ) ; if ( IS_ERR ( mp ) ) goto err ; if ( ! port ) { <vul-start> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <vul-end> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; err = - ENOMEM ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> port ) { if ( hlist_unhashed ( & mp -> mglist ) )\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> port ) { mp -> flags |= BR_MGMT_LOCKED ;\n"
  },
  {
    "id": 99,
    "question": "CWE-129 Code Input Vulnerable Code Is: CWE-129 static av_cold int vqa_decode_init ( AVCodecContext * avctx ) { VqaContext * s = avctx -> priv_data ; int i , j , codebook_index , ret ; s -> avctx = avctx ; avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( s -> avctx -> extradata_size != VQA_HEADER_SIZE ) { av_log ( s -> avctx , AV_LOG_ERROR , \"expected extradata size of %d\\\\n\" , VQA_HEADER_SIZE ) ; return AVERROR ( EINVAL ) ; } s -> vqa_version = s -> avctx -> extradata [ 0 ] ; switch ( s -> vqa_version ) { case 1 : case 2 : break ; case 3 : avpriv_report_missing_feature ( avctx , \"VQA Version %d\" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; default : avpriv_request_sample ( avctx , \"VQA Version %i\" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; } s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <vul-start> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <vul-end> s -> width = s -> height = 0 ; return ret ; } s -> vector_width = s -> avctx -> extradata [ 10 ] ; s -> vector_height = s -> avctx -> extradata [ 11 ] ; s -> partial_count = s -> partial_countdown = s -> avctx -> extradata [ 13 ] ; if ( ( s -> vector_width != 4",
    "golden_answers": [
      "CWE-129 Fixed Code Lines are: <vul-start> ( ret = ff_set_dimensions ( avctx , <vul-end> s -> width <vul-start> s -> height <vul-end> ) ) <\n"
    ],
    "generated_answer": "CWE-129 Fixed Code Lines are: <vul-start> ( ret = vqa_decode_check_size <vul-end> ( s ->\n"
  },
  {
    "id": 100,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <vul-start> DPRINTF ( 4 , ( \"enabling filegen for %s statistics \\'%s%s\\'\\\\n\" , <vul-end> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <vul-start> filegen_flag = filegen -> flag ; <vul-end> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , \"stats %s unrecognized\" , filegen_string ) ; continue ; } <vul-start> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , \"filegen category \\'%s\\' unrecognized\" , filegen_file ) ; continue ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 4, ( \"enabling filegen for %s statistics \\'%s%s\\'\" <vul-end>, filegen_string, <vul-start> filegen_file ) ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts!= NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_Flag : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR, \"Unknown filegen option token %d\", my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen, filegen_file, filegen_type, filegen_flag ) ; } } for ( ; my_node!= NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen_flag = filegen -> flag ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts!= NULL ; my_opts = my_opts -> link ) { attr_val * my_opts = HEAD_PFIFO ( my_node -> link ) ; for ( ; my_opts!= NULL ; my_opts = my_opts -> link ) { attr_val * my_opts = my_opts -> link -> link ) { attr_val * my_opts = my_opts -> value. i ; attr_val * my_opts = attr -> value. s ; if ( attr!= NULL ) { attr_val * my_opts = attr -> value. s ; if ( attr -> i == T_Flag ) { msyslog ( LOG_ERR, ( \"Filegen option token token %d\", my_opts -> attr ) ) ; exit ( 1 ) ; } } filegen_config ( filegen, filegen_file"
  },
  {
    "id": 101,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags ) { struct mm_struct * mm = vma -> vm_mm ; struct dev_pagemap * pgmap = NULL ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; <vul-start> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <vul-end> pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; if ( pgmap ) page = pte_page ( pte ) ;",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) && ! can_follow_write_pte ( pte , flags <vul-end> ) ) {\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> FOLL_WRITE ) && pte_trans_huge_or_free_page <vul-end> ( pte )\n"
  },
  {
    "id": 102,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( len > 1 ) { if ( <vul-start> <= 127 ) { <vul-start> -> size ; } else { <vul-end> op -> jump <vul-start> -> size ; } } else { op -> jump = addr ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = R_ANAL_OP_TYPE_JMP ; <vul-end> op -> fail <vul-start> -> fail = addr + ( 8 * data [ 1 ] + <vul-end> op -> size <vul-start> op -> size )\n"
  },
  {
    "id": 103,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 void Init_ossl_cipher ( void ) { # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ; eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ; # endif cCipher = rb_define_class_under ( mOSSL , \"Cipher\" , rb_cObject ) ; eCipherError = rb_define_class_under ( cCipher , \"CipherError\" , eOSSLError ) ; rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ; rb_define_copy_func ( cCipher , ossl_cipher_copy ) ; rb_define_module_function ( cCipher , \"ciphers\" , ossl_s_ciphers , 0 ) ; rb_define_method ( cCipher , \"initialize\" , ossl_cipher_initialize , 1 ) ; rb_define_method ( cCipher , \"reset\" , ossl_cipher_reset , 0 ) ; rb_define_method ( cCipher , \"encrypt\" , ossl_cipher_encrypt , - 1 ) ; rb_define_method ( cCipher , \"decrypt\" , ossl_cipher_decrypt , - 1 ) ; rb_define_method ( cCipher , \"pkcs5_keyivgen\" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb_define_method ( cCipher , \"update\" , ossl_cipher_update , - 1 ) ; rb_define_method ( cCipher , \"final\" , ossl_cipher_final , 0 ) ; rb_define_method ( cCipher , \"name\" , ossl_cipher_name , 0 ) ; rb_define_method ( cCipher , \"key=\" , ossl_cipher_set_key , 1 ) ; rb_define_method ( cCipher , \"auth_data=\" , ossl_cipher_set_auth_data , 1 ) ; rb_define_method ( cCipher , \"auth_tag=\" , ossl_cipher_set_auth_tag , 1 ) ; rb_define_method ( cCipher , \"auth_tag\" , ossl_cipher_get_auth_tag , - 1 ) ; rb_define_method ( cCipher , \"auth_tag_len=\" , ossl_cipher_set_auth_tag_len , 1 ) ; rb_define_method ( cCipher , \"authenticated?\" , ossl_cipher_is_authenticated , 0 ) ; rb_define_method ( cCipher , \"key_len=\" , ossl_cipher_set_key_length , 1 ) ; rb_define_method ( cCipher , \"key_len\" , ossl_cipher_key_length , 0 ) ; rb_define_method ( cCipher , \"iv=\" , ossl_cipher_set_iv ,",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> \"auth_tag_len\" ) ; id_key_set = rb_intern_const ( \"key_set\" ) ;\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> \"auth_tag_len\" ) ; id_auth_tag = rb_intern_const ( \"auth_tag\" ) ;\n"
  },
  {
    "id": 104,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\\\n\" , dbname ? dbname : \"NULL\" , user ? user : \"NULL\" , password ? password : \"NULL\" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) { <vul-start> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <vul-end> mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ) ) { if ( imp_dbh -> pmysql )\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) { imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> enable_utf8 = FALSE ;\n"
  },
  {
    "id": 105,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; <vul-start> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <vul-end> swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] ,",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , \"missing endpoints\\\\n\" ) ; return - ENODEV ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> interrupt_in_buffer ; \\\\\\n} <vul-end> while ( 0 <vul-start> return 0 ; <vul-end> }    \n"
  },
  {
    "id": 106,
    "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = \"\" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , \"/\" ) ) { if ( access ( \"WikiHome\" , R_OK ) != 0 ) wiki_redirect ( res , \"/WikiHome?create\" ) ; page = \"/WikiHome\" ; } if ( ! strcmp ( page , \"/styles.css\" ) ) { http_response_set_content_type ( res , \"text/css\" ) ; http_response_printf ( res , \"%s\" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , \"/favicon.ico\" ) ) { http_response_set_content_type ( res , \"image/ico\" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , \"api/\" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <vul-start> if ( strchr ( page , '/' ) ) <vul-end> { http_response_set_status ( res , 404 , \"Not Found\" ) ; http_response_printf ( res , \"<html><body>404 Not Found</body></html>\\\\n\" ) ; http_response_send ( res ) ; exit",
    "golden_answers": [
      "CWE-22 Fixed Code Lines are: <vul-start> } if ( ! page_name_is_good ( page <vul-end> ) ) {\n"
    ],
    "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> } if ( * page == '/' ||\n"
  },
  {
    "id": 107,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ; <vul-start> char * fpath = NULL , * cgdir = NULL , * controller ; <vul-end> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; } <vul-start> fprintf ( stderr , \"rmdir: verifying access to %s:%s (req path %s)\\\\n\" , <vul-end> controller , cgdir , path ) ; if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <vul-end> ret = - EACCES ; goto out ; } <vul-start> if ( ! cgfs_remove ( controller , cgroup ) ) { <vul-end> ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ; <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> , * controller , * next = NULL <vul-start> out ; } <vul-end> if ( ! <vul-start> , cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <vul-end> ) ) { <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <vul-start> cgdir ) ; free ( next ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, * controller, * root_dir <vul-start> out ; } <vul-end> if (! <vul-start> if (! caller_may_see_dir ( fc -> pid, controller, cgroup ) ) { ret = - ENOENT ; goto out ; } if (! <vul-start> if (! caller_may_see_dir ( fc -> pid, controller, cgroup ) ) { ret = - ENOENT ; goto out ; } if (! <vul-start> if (! cgfs_remove_item ( root_dir, cgroup ) ) { ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( root_dir ) ; return <vul-end> ret ; } <vul-start> cgdir ) ; <vul-end> }    \n"
  },
  {
    "id": 108,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <vul-start> int do_rf64 = 0 , write_junk = 1 ; <vul-end> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <vul-start> DS64Chunk ds64_chunk ; <vul-end> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( \"can\\'t create valid RIFF wav header for non-normalized floating data!\" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( \"total_data_bytes = %lld, so rf64\" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( \"total_data_bytes = %lld, so riff\" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> write_junk = 1 , table_length = 0 <vul-start> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <vul-start> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <vul-end> sizeof ( junkchunk <vul-start> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <vul-start> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <vul-start> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , \"dmmy\" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <vul-start> ) ) ) ) { error_line ( \"can\\'t write .WAV data, disk probably full!\" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( \"can\\'t write .WAV data, disk probably full!\" ) ; return FALSE ; } if ( <vul-end> ( write_junk &&\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> write_junk = 1, ds32_chunk <vul-start> ; DS64Chunk ds64_chunk ; DS32_chunk ds32_chunk <vul-start> ) ) ; ds32_chunk = sizeof ( ds32_chunk ) ; <vul-start> ; ds64_chunk. ChunkSize = ds32_chunk ; ds32_chunk. <vul-start> ( & ds64hdr, & ds32_chunk <vul-start> ds64_chunk ) ) || ( write_junk && (! DoWriteFile ( outfile, & ds32_chunk, sizeof ( ds32_chunk ), & bcount ) || bcount!= ds32_chunk ) ) <vul-start> ( outfile, & ds32_chunk, sizeof ( ds32_chunk ), & bcount ) || bcount!= ds32_chunk ) ) { error_line ( \"can\\'t write.WAV data, disk probably full!\" ) ; return FALSE ; } if ( write_junk && (! DoWriteFile ( outfile, & ds64hdr, sizeof ( ds64hdr ), & bcount ) || bcount!= ds32_chunk ) ) || (! DoWriteFile ( outfile, & ds64_chunk, sizeof ( ds64_chunk ), & bcount ) || bcount!= ds32_chunk ) ) || (! DoWriteFile ( outfile, & ds64_chunk, sizeof ( ds64_chunk ), & bcount ) || bcount!= ds32_chunk ) ) { error_line ( \"can\\'t write.WAV data, disk probably full!\" ) ; return FALSE ; } <vul-end> if ( write_junk\n"
  },
  {
    "id": 109,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error: cannot get box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error: expecting signature box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect magic number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting file type box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf (",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> != JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> != JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> : JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> >= JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>!= JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts ( <vul-start> ; i < JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts ( <vul-start>!= JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts (\n"
  },
  {
    "id": 110,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; <vul-start> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <vul-end> <vul-start> pthread_mutex_unlock ( & slot_lock ) ; <vul-end> <vul-start> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <vul-end> } else { LOG_ERROR ( \"%s socket signaled for read while disconnected, slot: %d, channel: %d\" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( \"%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d\" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <vul-start> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <vul-end> cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ;",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ) || ( TEMP_FAILURE_RETRY ( <vul-start> & size ) ) <vul-start> size ) ) { <vul-end> BTA_JvRfcommWrite ( slot <vul-start> id ) ; } <vul-start> ( need_close || TEMP_FAILURE_RETRY ( <vul-start> , & size )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) || ( TEMP_FAILURE_RETRY ( <vul-start> size ) ) ) { <vul-start> slot_lock ) ; TEMP_FAILURE_RETRY ( <vul-start> id ) ; } <vul-start> ( need_close || TEMP_FAILURE_RETRY ( <vul-start> & size ) )\n"
  },
  {
    "id": 111,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> if ( dh == NULL ) { msg = \"nf_ct_dccp: short packet \" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = \"nf_ct_dccp: truncated/malformed packet \" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = \"nf_ct_dccp: bad checksum coverage \" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = \"nf_ct_dccp: bad checksum \" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = \"nf_ct_dccp: reserved packet type \" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, & dh, 0\n"
  },
  {
    "id": 112,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int __vcpu_run ( struct kvm_vcpu * vcpu ) { int r ; struct kvm * kvm = vcpu -> kvm ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; <vul-start> r = vapic_enter ( vcpu ) ; <vul-end> if ( r ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; return r ; } r = 1 ; while ( r > 0 ) { if ( vcpu -> arch . mp_state == KVM_MP_STATE_RUNNABLE && ! vcpu -> arch . apf . halted ) r = vcpu_enter_guest ( vcpu ) ; else { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_vcpu_block ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) { kvm_apic_accept_events ( vcpu ) ; switch ( vcpu -> arch . mp_state ) { case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ; vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ; break ; case KVM_MP_STATE_INIT_RECEIVED : break ; default : r = - EINTR ; break ; } } } if ( r <= 0 ) break ; clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ; if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ; if ( dm_request_for_irq_injection ( vcpu ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat .",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> srcu ) ; <vul-end> r = 1 <vul-start> srcu_idx ) ; <vul-end> return r ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; r = kvm_vcpu_apf_enter ( vcpu ) ; if ( r ) { goto out ; } r = <vul-start> srcu_idx ) ; out :\n"
  },
  {
    "id": 113,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <vul-start> guint pkt_len ; <vul-end> int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , \"%9d] %2d:%2d:%2d.%9d %9s %9s\" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba: record header isn\\'t valid\" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\\\0' ; } while ( strcmp ( line , \"OFFSET 0001-0203\" ) != 0 ) ; <vul-start> num_items_scanned = sscanf ( line + 64 , \"LEN=%9u\" , & pkt_len ) ; <vul-end> if (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> int num_items_scanned ; int pkt_len , <vul-end> pktnum , hr <vul-start> + 64 , \"LEN=%9d\" <vul-end> , & pkt_len <vul-start> g_strdup ( \"toshiba: OFFSET line doesn\\'t have valid LEN item\" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba: packet header has a negative packet length\"\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> int num_items_scanned ; <vul-end> int pktnum, <vul-start> + 64, \"LEN=%9uK\" <vul-end>, & pkt_len <vul-start> + 64, \"LEN=%9uK\" <vul-end>, & pkt_len\n"
  },
  {
    "id": 114,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; <vul-start> struct ieee_802_11_phdr phdr ; <vul-end> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"PPI\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , \"PPI version %u, %u bytes\" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , \"PPI version %u, %u bytes\" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <vul-start> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <vul-end> ( wtap_encap_dissector_table , <vul-start> ( wtap_encap_dissector_table , wtap_encap <vul-end> , next_tvb , <vul-start> pinfo , tree , TRUE , phdrp\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> struct ieee_802_11_phdr phdr ; gint flag = 0 <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE <vul-start> ; if ( <vul-end> flag == TRUE"
  },
  {
    "id": 115,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 sds sdsnewlen ( const void * init , size_t initlen ) { void * sh ; sds s ; char type = sdsReqType ( initlen ) ; if ( type == SDS_TYPE_5 && initlen == 0 ) type = SDS_TYPE_8 ; int hdrlen = sdsHdrSize ( type ) ; unsigned char * fp ; <vul-start> sh = s_malloc ( hdrlen + initlen + 1 ) ; <vul-end> if ( sh == NULL ) return NULL ; if ( init == SDS_NOINIT ) init = NULL ; else if ( ! init ) memset ( sh , 0 , hdrlen + initlen + 1 ) ; s = ( char * ) sh + hdrlen ; fp = ( ( unsigned char * ) s ) - 1 ; switch ( type ) { case SDS_TYPE_5 : { * fp = type | ( initlen << SDS_TYPE_BITS ) ; break ; } case SDS_TYPE_8 : { SDS_HDR_VAR ( 8 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_16 : { SDS_HDR_VAR ( 16 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_32 : { SDS_HDR_VAR ( 32 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_64 : { SDS_HDR_VAR ( 64 , s ) ; sh -> len = initlen ; sh -> alloc =",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * fp ; assert ( initlen + hdrlen + 1 > initlen ) ;\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; sh = s_calloc <vul-end> ( hdrlen +\n"
  },
  {
    "id": 116,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void call_bind_status ( struct rpc_task * task ) { int status = - EIO ; if ( task -> tk_status >= 0 ) { dprint_status ( task ) ; task -> tk_status = 0 ; task -> tk_action = call_connect ; return ; } switch ( task -> tk_status ) { case - ENOMEM : dprintk ( \"RPC: %5u rpcbind out of memory\\\\n\" , task -> tk_pid ) ; rpc_delay ( task , HZ >> 2 ) ; goto retry_timeout ; case - EACCES : dprintk ( \"RPC: %5u remote rpcbind: RPC program/version \" \"unavailable\\\\n\" , task -> tk_pid ) ; if ( task -> tk_msg . rpc_proc -> p_proc == 0 ) { status = - EOPNOTSUPP ; break ; } <vul-start> rpc_delay ( task , 3 * HZ ) ; <vul-end> goto retry_timeout ; case - ETIMEDOUT : dprintk ( \"RPC: %5u rpcbind request timed out\\\\n\" , task -> tk_pid ) ; goto retry_timeout ; case - EPFNOSUPPORT : dprintk ( \"RPC: %5u unrecognized remote rpcbind service\\\\n\" , task -> tk_pid ) ; break ; case - EPROTONOSUPPORT : dprintk ( \"RPC: %5u remote rpcbind version unavailable, retrying\\\\n\" , task -> tk_pid ) ; task -> tk_status = 0 ; task -> tk_action = call_bind ; return ; case - ECONNREFUSED : case - ECONNRESET : case - ENOTCONN : case - EHOSTDOWN : case - EHOSTUNREACH : case - ENETUNREACH : case - EPIPE : dprintk ( \"RPC: %5u remote rpcbind unreachable: %d\\\\n\" , task -> tk_pid , task -> tk_status ) ; if ( ! RPC_IS_SOFTCONN ( task ) )",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> break ; } if ( task -> tk_msg. rpc_proc -> p_msg == NULL ) { status = - EPERM ; break ; }\n"
  },
  {
    "id": 117,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <vul-start> __mincore_unmapped_range ( addr , end , vma , vec ) ; <vul-end> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <vul-start> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <vul-end> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <vul-start> if ( non_swap_entry ( entry ) ) { <vul-end> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) ) { memset ( vec , 1 , nr <vul-end> ) ; goto <vul-start> pte ) ) * vec = 0 <vul-end> ; else if <vul-start> pte ) ; * vec = ! ! <vul-end> non_swap_entry ( entry <vul-start> ( entry ) ; <vul-end> } vec ++\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) { mincore_unmapped_range <vul-end> ( addr, <vul-start> pte ) ) mincore_unmapped_range <vul-end> ( addr, <vul-start> ; if ( pte_none ( pte ) ) { * vec = 1 ; goto out ; } if (\n"
  },
  {
    "id": 118,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int peer_recv_callback ( rdpTransport * transport , wStream * s , void * extra ) { freerdp_peer * client = ( freerdp_peer * ) extra ; rdpRdp * rdp = client -> context -> rdp ; switch ( rdp -> state ) { case CONNECTION_STATE_INITIAL : if ( ! rdp_server_accept_nego ( rdp , s ) ) return - 1 ; if ( rdp -> nego -> selected_protocol & PROTOCOL_NLA ) { sspi_CopyAuthIdentity ( & client -> identity , & ( rdp -> nego -> transport -> credssp -> identity ) ) ; IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , TRUE ) ; credssp_free ( rdp -> nego -> transport -> credssp ) ; <vul-start> } <vul-end> else { IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , FALSE ) ; } break ; case CONNECTION_STATE_NEGO : if ( ! rdp_server_accept_mcs_connect_initial ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CONNECT : if ( ! rdp_server_accept_mcs_erect_domain_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ERECT_DOMAIN : if ( ! rdp_server_accept_mcs_attach_user_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ATTACH_USER : if ( ! rdp_server_accept_mcs_channel_join_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CHANNEL_JOIN : if ( rdp -> settings -> DisableEncryption ) { if ( ! rdp_server_accept_client_keys ( rdp , s ) ) return - 1 ; break ; } rdp -> state = CONNECTION_STATE_ESTABLISH_KEYS ; case CONNECTION_STATE_ESTABLISH_KEYS",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;\n"
  },
  {
    "id": 119,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) { int rc ; enum exfat_mode mode ; exfat_tzset ( ) ; memset ( ef , 0 , sizeof ( struct exfat ) ) ; parse_options ( ef , options ) ; if ( match_option ( options , \"ro\" ) ) mode = EXFAT_MODE_RO ; else if ( match_option ( options , \"ro_fallback\" ) ) mode = EXFAT_MODE_ANY ; else mode = EXFAT_MODE_RW ; ef -> dev = exfat_open ( spec , mode ) ; if ( ef -> dev == NULL ) return - EIO ; if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) { if ( mode == EXFAT_MODE_ANY ) ef -> ro = - 1 ; else ef -> ro = 1 ; } ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; if ( ef -> sb == NULL ) { exfat_close ( ef -> dev ) ; exfat_error ( \"failed to allocate memory for the super block\" ) ; return - ENOMEM ; } memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( \"failed to read boot sector\" ) ; return - EIO ; } if ( memcmp ( ef -> sb -> oem_name , \"EXFAT \" , 8",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> exfat_error ( \"exFAT file system is not found\" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( \"too small sector size: 2^%hhd\" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( \"too big cluster size: 2^(%hhd+%hhd)\" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <vul-start> } if ( <vul-end> le64_to_cpu ( ef\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; exfat_error ( \"exFAT file system is not found\" <vul-end> ) ; return <vul-start> ; exfat_error ( \"unsupported FAT version: %hhu.%hhu\" <vul-end>, ef ->\n"
  },
  {
    "id": 120,
    "question": "CWE-134 Code Input Vulnerable Code Is: CWE-134 static void thunar_transfer_job_copy_node ( ThunarTransferJob * job , ThunarTransferNode * node , GFile * target_file , GFile * target_parent_file , GList * * target_file_list_return , GError * * error ) { ThunarThumbnailCache * thumbnail_cache ; ThunarApplication * application ; ThunarJobResponse response ; GFileInfo * info ; GError * err = NULL ; GFile * real_target_file = NULL ; gchar * base_name ; _thunar_return_if_fail ( THUNAR_IS_TRANSFER_JOB ( job ) ) ; _thunar_return_if_fail ( node != NULL && G_IS_FILE ( node -> source_file ) ) ; _thunar_return_if_fail ( target_file == NULL || node -> next == NULL ) ; _thunar_return_if_fail ( ( target_file == NULL && target_parent_file != NULL ) || ( target_file != NULL && target_parent_file == NULL ) ) ; _thunar_return_if_fail ( error == NULL || * error == NULL ) ; application = thunar_application_get ( ) ; thumbnail_cache = thunar_application_get_thumbnail_cache ( application ) ; g_object_unref ( application ) ; for ( ; err == NULL && node != NULL ; node = node -> next ) { if ( G_LIKELY ( target_file == NULL ) ) { base_name = g_file_get_basename ( node -> source_file ) ; target_file = g_file_get_child ( target_parent_file , base_name ) ; g_free ( base_name ) ; } else target_file = g_object_ref ( target_file ) ; info = g_file_query_info ( node -> source_file , G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , exo_job_get_cancellable ( EXO_JOB ( job ) ) , & err ) ; if ( info == NULL ) { g_object_unref ( target_file ) ; break ; } <vul-start> exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ; <vul-end> retry_copy",
    "golden_answers": [
      "CWE-134 Fixed Code Lines are: <vul-start> job ) , \"%s\" ,\n"
    ],
    "generated_answer": "CWE-134 Fixed Code Lines are: <vul-start> job ), \"%s\",\n"
  },
  {
    "id": 121,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <vul-end> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <vul-start> UINT32 tempWidth ; <vul-end> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <vul-start> for ( y = 0 ; y < context -> height ; y ++ ) <vul-end> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <vul-start> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <vul-start> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <vul-start> ) ; } return TRUE ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <vul-start> BYTE a_val ; INT16 temp_r_val ; UINT16 temp_g_val ; <vul-start> -> ColorLossLevel ; temp_r_val = ( context -> ChromaSubsamplingLevel? context -> width : 0 ) ; temp_g_val = ( context -> ChromaSubsamplingLevel? context -> height : 0 ) ; if ( context -> priv -> PlaneBuffers [ 0 ] + y * rw > temp_r_val || context -> priv -> PlaneBuffers [ 1 ] + y * rw > temp_g_val || context -> priv -> PlaneBuffers [ 2 ] + y * rw > temp_g_val ) return FALSE ; <vul-start> a_val ; UINT32 temp_w ; temp_w = ROUND_UP_TO ( context -> width, 8 ) ; rw = ( context -> ChromaSubsamplingLevel? tempWidth : context -> width ) ; if ( context -> priv -> PlaneBuffers [ 3 ] + y * rw > temp_w ) return FALSE ; r_val = ( UINT16 ) ( ( r_val << 5 ) | ( g_val << 5 ) | ( ( b_val << 3 ) ) | ( ( a_val << 1 ) << 3 ) ) ; b_val = ( UINT16 ) ( ( aval << 1 ) + g_val << 5 ) | ( ( a_val << 1 ) << 5 ) | ( ( a_val << 1 ) << 3 ) ) ; aplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; g_val = ( UINT16 ) ( ( r_val << 5 ) | ( g_val << 5 ) | ( ( a_val << 1 ) << 3 ) ) ; r_val = ( INT16 ) ( ( r_val << 5 ) | ( a_val << 1 ) ) ; g_val = ( INT16 ) ( ( aval << 1 ) << 5 ) | ( ( aval << 1 ) << 3 ) ; a_val = 0xFF ; src += 2 ; break ; case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++"
  },
  {
    "id": 122,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) { struct shmid_kernel * shp ; int err , version ; struct ipc_namespace * ns ; if ( cmd < 0 || shmid < 0 ) return - EINVAL ; version = ipc_parse_version ( & cmd ) ; ns = current -> nsproxy -> ipc_ns ; switch ( cmd ) { case IPC_INFO : case SHM_INFO : case SHM_STAT : case IPC_STAT : return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; case IPC_RMID : case IPC_SET : return shmctl_down ( ns , shmid , cmd , buf , version ) ; case SHM_LOCK : case SHM_UNLOCK : { struct file * shm_file ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock1 ; } audit_ipc_obj ( & ( shp -> shm_perm ) ) ; err = security_shm_shmctl ( shp , cmd ) ; if ( err ) goto out_unlock1 ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { kuid_t euid = current_euid ( ) ; err = - EPERM ; if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && ! uid_eq ( euid , shp -> shm_perm . cuid ) ) goto out_unlock0 ; if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) goto out_unlock0 ; } shm_file",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( shp -> shm_file. state!= SHM_UNLOCKING <vul-end> ) goto out_unlock0\n"
  },
  {
    "id": 123,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; <vul-start> } <vul-end> line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ENOBUFS ; } memset ( & line, 0, sizeof ( line ) ) ;\n"
  },
  {
    "id": 124,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mp_join_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_join * mpj = ( const struct mp_join * ) opt ; <vul-start> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <vul-end> ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && <vul-start> ! ( opt_len == 24 && flags & TH_ACK ) ) <vul-end> return 0 ; if ( opt_len != 24 ) { if ( mpj -> sub_b & MP_JOIN_B ) ND_PRINT ( ( ndo , \" backup\" ) ) ; ND_PRINT ( ( ndo , \" id %u\" , mpj -> addr_id ) ) ; } switch ( opt_len ) { case 12 : ND_PRINT ( ( ndo , \" token 0x%x\" \" nonce 0x%x\" , EXTRACT_32BITS ( mpj -> u . syn . token ) , EXTRACT_32BITS ( mpj -> u . syn . nonce ) ) ) ; break ; case 16 : ND_PRINT ( ( ndo , \" hmac 0x%\" PRIx64 \" nonce 0x%x\" , EXTRACT_64BITS ( mpj -> u . synack . mac ) , EXTRACT_32BITS ( mpj -> u . synack . nonce ) ) ) ; break ; case 24 : { size_t i ; ND_PRINT ( ( ndo , \" hmac 0x\" ) ) ; for ( i = 0 ; i < sizeof ( mpj -> u . ack . mac ) ; ++ i ) ND_PRINT ( ( ndo , \"%02x\" , mpj",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> == 12 && ( <vul-start> & TH_SYN ) ) <vul-start> == 24 && ( <vul-start> flags & TH_ACK )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> == 12 && ( <vul-start> flags & TH_SYN ) <vul-start> == 16 && ( <vul-start> flags & TH_ACK )\n"
  },
  {
    "id": 125,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void ndpi_search_oracle ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , \"search ORACLE\\\\n\" ) ; if ( packet -> tcp != NULL ) { sport = ntohs ( packet -> tcp -> source ) , dport = ntohs ( packet -> tcp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , \"calculating ORACLE over tcp\\\\n\" ) ; if ( ( dport == 1521 || sport == 1521 ) <vul-start> && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) <vul-end> || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) { NDPI_LOG_INFO ( ndpi_struct , \"found oracle\\\\n\" ) ; ndpi_int_oracle_add_connection ( ndpi_struct , flow ) ; } else if ( packet -> payload_packet_len == 213 && packet -> payload [ 0 ] == 0x00 && packet -> payload [ 1 ] == 0xd5 && packet -> payload [ 2 ] == 0x00 && packet -> payload [ 3 ] == 0x00 ) { NDPI_LOG_INFO (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( packet -> payload_packet_len >= 3 && packet ->\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ( ( <vul-end> packet -> payload <vul-start> ] == 0x07 ) && ( ( packet -> payload [ 1 ] == 0xff ) && ( ( packet -> payload [ 2 ] == 0x00 ) ) || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( ( packet -> payload [ 0 ] == 0x01 ) ) ) ) && ( ( packet -> payload [ 1 ]!= 0x00 ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 0 ] == 0x07 ) && ( ( packet -> payload [ 1 ] == 0x07 ) && ( ( packet -> payload [ 2 ] == 0x00 ) || ( ( packet -> payload [ 0 ] == 0x01 ) ) ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( ( packet -> payload [ 0 ] == 0x01 ) ) ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 0 ] == 0x07 ) && ( ( packet -> payload [ 1 ] == 0xff ) && ( ( packet -> payload [ 2 ] == 0x00 ) || ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 2 ] == 0x00 ) || ( ( packet -> payload [ 0 ] == 0x07 ) && ( ( packet -> payload [ 1 ] == 0x01 ) ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 ) && ( ( packet -> payload [ 2 ] == 0x00 ) && ( ( packet -> payload [ 3 ] == 0x00 )"
  },
  {
    "id": 126,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i +",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input url %s is too long, truncating to %d chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <vul-start> url_arg ) ; } <vul-start> ! e ) { strncpy <vul-end> ( the_url , <vul-start> ( sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <vul-end> gf_dm_sess_del ( sess <vul-start> str ) { strncpy <vul-end> ( the_url , <vul-start> , \"MP4Client \" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <vul-end> ; gf_term_connect (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ext ; if ( strlen ( url_arg ) + 1 > sizeof ( the_url ) ) { return 1 ; } <vul-start> ( logfile, \"GF_LOG_FILE: Could not open file %s\\\\n\" <vul-end>, the_url )\n"
  },
  {
    "id": 127,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <vul-end> TOKENEXTRA * * tp , int mi_row , <vul-start> int mi_col , BLOCK_SIZE bsize , int * rate , <vul-end> int64_t * dist , int do_recon , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; TOKENEXTRA * tp_orig = * tp ; <vul-start> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <vul-end> int i , pl ; BLOCK_SIZE subsize ; <vul-start> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <vul-end> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; <vul-start> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <vul-end> int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , TileDataEnc * tile_data <vul-end> , TOKENEXTRA * <vul-start> int mi_row , int mi_col , <vul-end> BLOCK_SIZE bsize , <vul-start> BLOCK_SIZE bsize , RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <vul-end> ) { VP9_COMMON <vul-start> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <vul-start> x = & td <vul-end> -> mb ; <vul-start> * ctx = & pc_tree -> none <vul-end> ; int i <vul-start> BLOCK_SIZE subsize ; RD_COST this_rdc , sum_rdc , best_rdc <vul-end> ; int do_split <vul-start> . subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <vul-start> * tp_orig ; <vul-end> assert ( num_8x8_blocks_wide_lookup <vul-start> [ bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <vul-start> bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <vul-end> x -> mb_energy <vul-start> bsize ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <vul-end> ) ; } <vul-start> ( bsize <= max_size && bsize >= min_size <vul-end> ) ; partition_horz_allowed <vul-start> ( bsize <= max_size && bsize > min_size <vul-end> ) || force_horz_split <vul-start> ( bsize <= max_size && bsize > min_size <vul-end> ) || force_vert_split <vul-start> &= bsize > min_size <vul-end> ; } if <vul-start> } save_context ( x <vul-end> , mi_row , <vul-start> bsize ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <vul-end> = 0 ; <vul-start> = 0 ; } } # endif <vul-end> if ( partition_none_allowed <vul-start> ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> != INT_MAX ) <vul-start> bsize ) ; this_rdc . rate += cpi <vul-end> -> partition_cost [ <vul-start> PARTITION_NONE ] ; this_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <vul-end> ) { int64_t <vul-start> ) { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <vul-end> ; if ( <vul-start> >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <vul-end> >>= 8 - <vul-start> ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <vul-end> ; if ( <vul-start> if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <vul-end> ) { do_split <vul-start> } } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <vul-end> for ( i <vul-start> < 4 && sum_rdc . rdcost < best_rdc . rdcost <vul-end> ; ++ i <vul-start> ) continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <vul-end> ; rd_pick_partition ( <vul-start> ( cpi , td , tile_data <vul-end> , tp , <vul-start> subsize , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> = INT64_MAX ; break ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && i == <vul-start> bsize ) ; sum_rdc . rate += cpi <vul-end> -> partition_cost [ <vul-start> PARTITION_SPLIT ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <vul-end> ; } } <vul-start> } restore_context ( x <vul-end> , mi_row , <vul-start> ( partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <vul-end> ) { subsize <vul-start> , PARTITION_HORZ ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && mi_row + <vul-start> cm -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <vul-end> update_state ( cpi <vul-start> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <vul-end> pred_interp_filter = ctx <vul-start> ( cpi , tile_data , x <vul-end> , mi_row + <vul-start> mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <vul-end> = get_subsize ( <vul-start> , PARTITION_VERT ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && mi_col + <vul-start> cm -> mi_cols && bsize > BLOCK_8X8 <vul-start> ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> vertical [ 1 ] . <vul-end> pred_interp_filter = ctx <vul-start> ( cpi , tile_data , x <vul-end> , mi_row , <vul-start> mi_step , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <vul-end> < INT_MAX && <vul-start> < INT_MAX && best_rdc . dist <vul-end> < INT64_MAX && <vul-start> < INT64_MAX && pc_tree -> index != 3 <vul-end> ) { int <vul-start> BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp <vul-end> , mi_row , <vul-start> , output_enabled , bsize , pc_tree <vul-end> ) ; } <vul-start> ; assert ( best_rdc . rate <vul-end> < INT_MAX ) <vul-start> ; assert ( best_rdc . dist <vul-end> < INT64_MAX )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, TileDataEnc * tile_data, TileDataEnc * tile_data <vul-end>, TOKENEXTRA * <vul-start> BLOCK_SIZE bsize, RD_COST * rd_cost, int64_t * rd_cost, int64_t best_rd, int64_t * rd_cost, int64_t * rd_cost <vul-end>, int do_recon <vul-start> & cpi -> td. <vul-start> * ctx = & x -> e_mbd ; MACROBLOCK * const x = & x -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT * const xd_l = & x -> e_mbd ; const int mi_row = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT * const xd_c = & x -> e_mbd ; const int mi_col = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT * const xd_a [ 16 * MAX_MB_PLANE ], a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT * const sl [ 8 ] ; int this_rate, sum_rate = 0, best_rate = 0 ; int64_t best_dist = 0 ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int force_vert_split = ( mi_row + mi_step >= cm -> mi_rows ; const int yss = x -> e_mbd. plane [ 1 ]. subsampling_x ; const int yss = x -> e_mbd. plane [ 1 ]. subsampling_y ; int partition_horz_allowed = ( mi_row + mi_step >= cm -> mi_rows ; const int partition_vert_allowed = ( mi_col + mi_step >= cm -> mi_cols ) ; int partition_horz_allowed = ( mi_row + mi_"
  },
  {
    "id": 128,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <vul-start> event_data -> snk_config = <vul-end> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> goto err ; cpu = cpumask_first ( mask ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto err ; if (! sink_ops ( sink ) -> get_buffer ) goto err ;\n"
  },
  {
    "id": 129,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static grub_err_t find_file ( const char * currpath , grub_fshelp_node_t currroot , grub_fshelp_node_t * currfound , struct grub_fshelp_find_file_closure * c ) { <vul-start> # ifndef _MSC_VER <vul-end> <vul-start> char fpath [ grub_strlen ( currpath ) + 1 ] ; <vul-end> # else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; <vul-start> # endif <vul-end> char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; while ( * name == '/' ) name ++ ; if ( ! * name ) { <vul-start> * currfound = currnode ; <vul-end> return 0 ; } for ( ; ; ) { int found ; struct find_file_closure cc ; next = grub_strchr ( name , '/' ) ; if ( next ) { while ( * next == '/' ) * ( next ++ ) = '\\\\0' ; } if ( type != GRUB_FSHELP_DIR ) { free_node ( currnode , c ) ; <vul-start> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , \"not a directory\" ) ; <vul-end> } cc . name = name ; cc . type = & type ; cc . oldnode = & oldnode ; cc . currnode = & currnode ; found = c -> iterate_dir ( currnode , iterate , & cc ) ; if ( ! found ) { <vul-start> if ( grub_errno ) <vul-end> <vul-start> return grub_errno ; <vul-end> break ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> c ) { char * fpath = grub_malloc ( <vul-end> grub_strlen ( currpath <vul-start> ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <vul-end> grub_strlen ( currpath <vul-start> 1 ) ; <vul-end> while ( * <vul-start> currfound = currnode ; free ( fpath ) <vul-start> c ) ; free ( fpath ) ; <vul-start> ( grub_errno ) { free ( fpath ) ; <vul-start> return grub_errno ; } <vul-start> c ) ; free ( fpath ) ; <vul-start> oldnode , c ) ; free ( fpath <vul-start> c ) ; free ( fpath ) ; <vul-start> = type ; free ( fpath ) ; <vul-start> next ; } free ( fpath ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> c ) { char * fpath = grub_malloc ( <vul-end> grub_strlen ( currpath <vul-start> ) + 1 ) ; <vul-end> char * name <vul-start> name ) { free_node ( currnode, c ) ; <vul-start> return grub_error ( GRUB_ERR_BAD_FILE_TYPE <vul-end>, \"not a directory\" ) <vul-start> found ) { free_node ( currnode, c ) ; <vul-start> ( grub_errno ) { <vul-start> return grub_errno ; } <vul-start> next ; } free_node ( currnode, c ) ; <vul-start> next ; } free_node ( currnode, c ) ;\n"
  },
  {
    "id": 130,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kcalloc ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) <vul-start> return ERR_PTR ( - EINVAL ) ; <vul-end> * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not (",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> > nr_parens ) { ret = - EINVAL ; goto out_free ; } <vul-end> * ( ++\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> return ERR_PTR ( <vul-end> EINVAL ) ;\n"
  },
  {
    "id": 131,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( \"in wwunpack\\\\n\" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( \"WWPack: Array of structs out of section\\\\n\" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( \"WWPack: Compressed data out of file\\\\n\" ) ; break ; } cli_dbgmsg ( \"WWP: src: %x, szd: %x, srcend: %x - %x\\\\n\" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( \"WWPack: Unable to allocate memory for compd\\\\n\" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( \"WWPack: unpack memory address out of bounds.\\\\n\" ) ; return CL_EFORMAT ; }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 8 ) ; if ( scount >= szd ) { return CL_EFORMAT ; }\n"
  },
  {
    "id": 132,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <vul-start> if ( track -> timescale > UINT16_MAX ) { <vul-end> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( \"lpcm\" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , \"enca\" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ;",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> timescale > UINT16_MAX || ! track -> par -> channels\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> { if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( \"lpcm\" ) ; else if ( <vul-start> -> timescale > UINT32_MAX <vul-end> ) { if\n"
  },
  {
    "id": 133,
    "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static long _syscall ( long num , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) { long ret = - 1 ; oe_errno = 0 ; switch ( num ) { # if defined ( OE_SYS_creat ) case OE_SYS_creat : { const char * pathname = ( const char * ) arg1 ; oe_mode_t mode = ( oe_mode_t ) arg2 ; int flags = ( OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC ) ; ret = oe_open ( pathname , flags , mode ) ; if ( oe_errno == OE_ENOENT ) { oe_errno = OE_ENOSYS ; goto done ; } goto done ; } # endif # if defined ( OE_SYS_open ) case OE_SYS_open : { const char * pathname = ( const char * ) arg1 ; int flags = ( int ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } # endif case OE_SYS_openat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; uint32_t mode = ( uint32_t ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; }",
    "golden_answers": [
      "CWE-552 Fixed Code Lines are: <vul-start> ) arg4 ; <vul-end> struct oe_sockaddr * <vul-start> * dest_add = ( <vul-end> struct oe_sockaddr *\n"
    ],
    "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> arg4 ; const oe_socklen_t * addrlen = ( oe_socklen_t * ) arg3 ; const <vul-start> struct oe_sockaddr * ) arg4 ; const struct oe_sockaddr * <vul-start> dest_add = ( struct oe_sockaddr * ) arg5 <vul-end> ; ret =\n"
  },
  {
    "id": 134,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * delete_policy_2_svc ( dpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> name ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , NULL , NULL ) ) { log_unauth ( \"kadm5_delete_policy\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_DELETE ; } else { ret . code = kadm5_delete_policy ( ( void * ) handle , arg -> name ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_delete_policy\" , ( ( prime_arg == NULL ) ? \"(null)\" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; }",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> ) ; } exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 135,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void ikev2_parent_outI1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( \"ikev2 parent outI1: calculated ke+nonce, sending I1\" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , \"%s: Request was disconnected from state\" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_outI1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_cur_state ( ) ; reset_globals ( ) ; <vul-start> passert ( GLOBALS_ARE_RESET ( ) ) ; <vul-end> }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
  },
  {
    "id": 136,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int mk_request_error ( int http_status , struct client_session * cs , struct session_request * sr ) { int ret , fd ; mk_ptr_t message , * page = 0 ; struct error_page * entry ; struct mk_list * head ; struct file_info finfo ; mk_header_set_http_status ( sr , http_status ) ; if ( http_status != MK_CLIENT_LENGTH_REQUIRED && http_status != MK_CLIENT_BAD_REQUEST && http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE ) { mk_list_foreach ( head , & sr -> host_conf -> error_pages ) { entry = mk_list_entry ( head , struct error_page , _head ) ; if ( entry -> status != http_status ) { continue ; } ret = mk_file_get_info ( entry -> real_path , & finfo ) ; if ( ret == - 1 ) { break ; } fd = open ( entry -> real_path , config -> open_flags ) ; if ( fd == - 1 ) { break ; } sr -> fd_file = fd ; <vul-start> sr -> bytes_to_send = finfo . size ; <vul-end> sr -> headers . content_length = finfo . size ; sr -> headers . real_length = finfo . size ; memcpy ( & sr -> file_info , & finfo , sizeof ( struct file_info ) ) ; mk_header_send ( cs -> socket , cs , sr ) ; return mk_http_send_file ( cs , sr ) ; } } mk_ptr_reset ( & message ) ; switch ( http_status ) { case MK_CLIENT_BAD_REQUEST : page = mk_request_set_default_page ( \"Bad Request\" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_FORBIDDEN : page = mk_request_set_default_page ( \"Forbidden\"",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; sr -> fd_is_fdt = MK_FALSE ; sr ->\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; sr -> fd_is_fdt = 0 ; sr ->\n"
  },
  {
    "id": 137,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , <vul-start> int disable_inter_mode_mask , int this_mode , int ref_frame , <vul-end> int second_ref_frame ) { if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && ( second_ref_frame == NONE || <vul-start> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <vul-end> <vul-start> int rfc = mode_context [ ref_frame ] ; <vul-end> int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ; int c2 = cost_mv_ref ( cpi , NEARESTMV , rfc ) ; int c3 = cost_mv_ref ( cpi , ZEROMV , rfc ) ; if ( this_mode == NEARMV ) { if ( c1 > c3 ) return 0 ; } else if ( this_mode == NEARESTMV ) { if ( c2 > c3 ) return 0 ; } else { assert ( this_mode == ZEROMV ) ; <vul-start> if ( second_ref_frame == NONE ) { <vul-end> <vul-start> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <vul-end> <vul-start> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <vul-end> return 0 ; } else { <vul-start> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ]",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <vul-end> == NONE || <vul-start> this_mode ] [ ref_frames [ 1 ] <vul-end> ] . as_int <vul-start> = mode_context [ ref_frames [ 0 ] <vul-end> ] ; int <vul-start> ; if ( ref_frames [ 1 ] <vul-end> == NONE ) <vul-start> NEARESTMV ] [ ref_frames [ 0 ] <vul-end> ] . as_int <vul-start> NEARMV ] [ ref_frames [ 0 ] <vul-end> ] . as_int <vul-start> NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <vul-end> ] . as_int <vul-start> NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <vul-end> ] . as_int\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> disable_inter_mode_mask, int this_mode, int ref_frame, int <vul-end> second_ref_frame ) { <vul-start> == NONE || ( <vul-start> == 0 ) && ( cpi -> oxcf. pass == 2 ) ) <vul-start> = mode_context [ <vul-end> ref_frame ] ; <vul-start> ; if ( cpi -> oxcf. pass == 2 <vul-end> ) { if <vul-start> if ( ( cpi -> oxcf. pass <vul-end> >= c2 && <vul-start> || ( c3 > c2 && frame_mv [ NEARESTMV ] [ ref_frame ]. as_int == 0 ) || ( c3 <vul-start> if ( ( cpi -> oxcf. pass <vul-end> >= c1 && <vul-start> if ( ( cpi -> oxcf. pass <vul-end> >= c2 && <vul-start> && frame_mv [ NEARESTMV ] [ ref_frame ]. as_int == 0 ) || ( cpi -> oxcf. pass <vul-end> >= c1 && <vul-start> && frame_mv [ NEARMV ] [ ref_frame ]. as_int == 0 ) || ( cpi -> oxcf. pass <vul-end> >= c2 && <vul-start> && frame_mv [ NEARMV ] [ ref_frame ]. as_int == 0 ) || ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ]. as_int == 0 ) ) return 0 ; } else { if ( ( cpi -> oxcf. pass == 2 <vul-end> && frame_mv [ <vul-start> NEARESTMV ] [ <vul-end> ref_frame ].\n"
  },
  {
    "id": 138,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 <vul-start> dictionary * iniparser_load ( const char * ininame ) <vul-end> { FILE * in ; char line [ ASCIILINESZ + 1 ] ; char section [ ASCIILINESZ + 1 ] ; char key [ ASCIILINESZ + 1 ] ; char tmp [ ( ASCIILINESZ * 2 ) + 1 ] ; char val [ ASCIILINESZ + 1 ] ; int last = 0 ; int len ; int lineno = 0 ; int errs = 0 ; dictionary * dict ; if ( ( in = fopen ( ininame , \"r\" ) ) == NULL ) { fprintf ( stderr , \"iniparser: cannot open %s\\\\n\" , ininame ) ; return NULL ; } dict = dictionary_new ( 0 ) ; if ( ! dict ) { fclose ( in ) ; return NULL ; } memset ( line , 0 , ASCIILINESZ ) ; memset ( section , 0 , ASCIILINESZ ) ; memset ( key , 0 , ASCIILINESZ ) ; memset ( val , 0 , ASCIILINESZ ) ; last = 0 ; while ( fgets ( line + last , ASCIILINESZ - last , in ) != NULL ) { lineno ++ ; len = ( int ) strlen ( line ) - 1 ; if ( len == 0 ) continue ; if ( line [ len ] != '\\\\n' && ! feof ( in ) ) { fprintf ( stderr , \"iniparser: input line too long in %s (%d)\\\\n\" , ininame , lineno ) ; dictionary_del ( dict ) ; fclose ( in ) ; return NULL ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> char * ininame , load_options options <vul-start> case LINE_ERROR : if ( options & HIDE_ERRORED_LINE_CONTENT ) { <vul-start> ( stderr , \"iniparser: syntax error in %s (%d)\\\\n\" , ininame , lineno ) ; } else { fprintf ( stderr , <vul-start> line ) ; }\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> char * ininame, const char * section, const char * key, const char * val <vul-start> case LINE_ERROR : if ( key ) strncpy ( key, val, sizeof ( key ) ) ; <vul-start> ( stderr, \"iniparser: syntax error in %s (%d):\\\\n\" <vul-end>, ininame, <vul-start> ( stderr, \"-> %s\\\\n\" <vul-end>, line )\n"
  },
  {
    "id": 139,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , \"(pad1)\" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , \"(padn: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(padn)\" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , \"(refresh: trunc)\" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , \"(refresh: %u)\" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , \"(altcoa: trunc)\" ) ) ; goto trunc ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ndo, <vul-end> bp [ i\n"
  },
  {
    "id": 140,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static const char * parse_string ( cJSON * item , const char * str ) <vul-end> { <vul-start> const char * ptr = str + 1 ; <vul-end> char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \\'\\\\\"\\' ) { <vul-start> ep = str ; <vul-end> <vul-start> return 0 ; <vul-end> } <vul-start> while ( * ptr != \\'\\\\\"\\' && * ptr && ++ len ) <vul-end> <vul-start> if ( * ptr ++ == '\\\\\\\\' ) <vul-end> <vul-start> ptr ++ ; <vul-end> <vul-start> if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) <vul-end> return 0 ; ptr = str + 1 ; ptr2 = out ; <vul-start> while ( * ptr != \\'\\\\\"\\' && * ptr ) { <vul-end> if ( * ptr != '\\\\\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\\\b' ; break ; case 'f' : * ptr2 ++ = '\\\\f' ; break ; case 'n' : * ptr2 ++ = '\\\\n' ; break ; case 'r' : * ptr2 ++ = '\\\\r' ; break ; case 't' : * ptr2 ++ = '\\\\t' ; break ; case 'u' : <vul-start> sscanf ( ptr + 1 , \"%4x\" , & uc ) ; <vul-end> <vul-start> ptr += 4 ; <vul-end> if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) <vul-start> break",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> char * str , <vul-end> const char * <vul-start> const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * <vul-end> out ; int <vul-start> \\'\\\\\"\\' ) { * <vul-start> = str ; return 0 ; <vul-end> } while ( <vul-start> while ( * end_ptr <vul-end> != \\'\\\\\"\\' && <vul-start> \\'\\\\\"\\' && * end_ptr <vul-end> && ++ len <vul-start> ++ len ) if ( * end_ptr <vul-end> ++ == '\\\\\\\\' <vul-start> == '\\\\\\\\' ) end_ptr ++ ; out = ( char * ) cJSON_malloc ( len + 1 ) <vul-end> ; if ( <vul-start> if ( ! out ) return 0 ; item -> valuestring <vul-end> = out ; <vul-start> = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) <vul-end> { if ( <vul-start> case 'u' : uc = parse_hex4 ( ptr + 1 ) ; <vul-end> ptr += 4 <vul-start> += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } <vul-start> == 0 ) { * ep = str ; return 0 ; } <vul-end> if ( uc <vul-start> <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } <vul-end> if ( ptr <vul-start> != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 <vul-end> ( ptr + <vul-start> ptr + 3 ) ; <vul-end> ptr += 6 <vul-start> > 0xDFFF ) { * ep = str ; return 0 ; } <vul-end> uc = 0x10000 <vul-start> uc = 0x10000 + ( <vul-end> ( ( uc <vul-start> & 0x3FF ) ) <vul-start> < 0x80 ) len = 1 ; <vul-end> else if ( <vul-start> break ; } ptr ++ <vul-end> ; } } <vul-start> == \\'\\\\\"\\' ) ptr ++ <vul-end> ; return ptr\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char * str, const char * * ptr, size_t len ) { char * ptr2 ; char * out ; int len = 0 ; unsigned uc, uc2 ; if ( * ptr == \\'\\\\\"\\' ) { ep = str ; return 0 ; } while ( * ptr!= \\'\\\\\"\\' && * ptr && ++ len ) if ( * ptr == '\\\\\\\\' ) ptr ++ ; if (! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) return 0 ; ptr = str + 1 ; ptr2 = out ; while ( * ptr!= \\'\\\\\"\\' && * ptr ) { if ( * ptr!= '\\\\\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\\\b' ; break ; case 'f' : * ptr2 ++ = '\\\\f' ; break ; case 'n' : * ptr2 ++ = '\\\\n' ; break ; case 'r' : * ptr2 ++ = '\\\\r' ; break ; case 't' : * ptr2 ++ = '\\\\t' ; break ; case 'u' : sscanf ( ptr + 1, \"%4x\", & uc ) ; ptr += 4 ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; } ptr2 += len ; switch ( len ) { case 4 : * ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } } * ptr2 = 0 ; if ( * ptr == \\'\\\\\"\\' ) { * ptr2 ++ = * ptr ; } else { * ptr2 ++ = * ptr ; } } * ptr2 = 0 ; if ( * ptr == \\'\\\\\"\\' ) { * ptr2 ++ = * ptr ; } else { * ptr2 ++ = * ptr ; } } * ptr2 = 0 ; if ( * ptr == \\'\\\\\"\\' )"
  },
  {
    "id": 141,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_diamond_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; *",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> in_what , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here , in_what_stride <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> in_what, in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here, in_what_stride <vul-end> ) ; if\n"
  },
  {
    "id": 142,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <vul-start> u8 opcode = BPF_OP ( insn -> code ) ; <vul-end> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , \"R%d 32-bit pointer arithmetic prohibited\\\\n\" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , \"R%d pointer arithmetic on %s prohibited, null-check it first\\\\n\" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> -> code ) ; int ret <vul-start> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , \"R%d tried to add from different maps or paths\\\\n\" , dst ) ; return ret ; } <vul-start> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , \"R%d tried to sub from different maps or paths\\\\n\" , dst ) ; return ret ; }\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> -> src_reg ; int ret = 0 ; <vul-start> case BPF_ADD : ret = check_reg_sane_offset ( env, off_reg, ptr_reg -> type ) ; if ( ret < 0 ) { verbose ( env, \"R%d tried to add pointer from scalar\\\\n\", dst ) ; return ret ; } <vul-start> case BPF_SUB : ret = check_reg_sane_offset ( env, ptr_reg, ptr_reg -> type ) ; if ( ret < 0 ) { verbose ( env, \"R%d tried to subtraction from stack pointer prohibited\\\\n\", dst ) ; return ret ; }\n"
  },
  {
    "id": 143,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_yv12_copy_frame_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; # if 0 assert ( src_ybc -> y_width == dst_ybc -> y_width ) ; assert ( src_ybc -> y_height == dst_ybc -> y_height ) ; # endif <vul-start> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <vul-end> <vul-start> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <vul-end> src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <vul-start> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <vul-end> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <vul-start> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <vul-end> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> dst_ybc ) ; return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> dst_ybc ) ; assert ( src_ybc -> uv_width == dst_ybc -> uv_width ) ; assert ( src_ybc -> uv_height == dst_ybc -> uv_height ) ;\n"
  },
  {
    "id": 144,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , \"no magic-number found!\" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"%3s \" , tok2str ( juniper_direction_values , \"---\" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\tJuniper PCAP Flags [%s]\" , bittok2str ( jnx_flag_values , \"none\" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> -> header_len ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <vul-start> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; while ( jnx_ext_len >= JUNIPER_EXT_TLV_OVERHEAD <vul-end> ) { if <vul-start> ; } } ND_TCHECK2 ( p [ 0 ], l2info -> header_len ) ;\n"
  },
  {
    "id": 145,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"slice type too large (%d) at %d %d\\\\n\" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( <vul-end> h0 -> cur_pic_ptr <vul-start> { if ( <vul-end> last_pic_structure != PICT_FRAME <vul-start> { if ( <vul-end> last_pic_structure != PICT_FRAME\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> (! last_pic_droppable <vul-end> ) { ff_thread_report_progress <vul-start> (! last_pic_droppable <vul-end> ) { ff_thread_report_progress\n"
  },
  {
    "id": 146,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cmd_info ( void * data , const char * input ) { RCore * core = ( RCore * ) data ; bool newline = r_config_get_i ( core -> config , \"scr.interactive\" ) ; RBinObject * o = r_bin_cur_object ( core -> bin ) ; RCoreFile * cf = core -> file ; int i , va = core -> io -> va || core -> io -> debug ; int mode = 0 ; int is_array = 0 ; Sdb * db ; for ( i = 0 ; input [ i ] && input [ i ] != ' ' ; i ++ ) ; if ( i > 0 ) { switch ( input [ i - 1 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : mode = R_CORE_BIN_SIMPLE ; break ; } } if ( mode == R_CORE_BIN_JSON ) { if ( strlen ( input + 1 ) > 1 ) { is_array = 1 ; } } if ( is_array ) { r_cons_printf ( \"{\" ) ; } if ( ! * input ) { cmd_info_bin ( core , va , mode ) ; } if ( ! strcmp ( input , \"*\" ) ) { input = \"I*\" ; } RBinObject * obj = r_bin_cur_object ( core -> bin ) ; while ( * input ) { switch ( * input ) { case 'b' : { ut64 baddr = r_config_get_i ( core -> config , \"bin.baddr\" ) ; if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> case 'l' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <vul-start> 0 ) ; } <vul-start> case 'i' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <vul-start> 0 ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case 'l' : if ( obj -> libs ) { <vul-start> ; break ; }\n"
  },
  {
    "id": 147,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-start> int mi_row , int mi_col , vp9_reader * r ) { <vul-end> struct segmentation * const seg = & cm -> seg ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> const BLOCK_SIZE bsize = mbmi -> sb_type ; <vul-end> int predicted_segment_id , segment_id ; if ( ! seg -> enabled ) return 0 ; <vul-start> predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <vul-end> bsize , mi_row , mi_col ) ; <vul-start> if ( ! seg -> update_map ) <vul-end> return predicted_segment_id ; <vul-start> if ( seg -> temporal_update ) { <vul-end> <vul-start> const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <vul-end> <vul-start> mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ; <vul-end> segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ; } else { segment_id = read_segment_id ( r , seg ) ; } <vul-start> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <vul-end> return segment_id ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int mi_col , vpx_reader <vul-end> * r ) <vul-start> -> mbmi ; int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <vul-end> ; if ( <vul-start> ; predicted_segment_id = <vul-end> cm -> last_frame_seg_map <vul-start> cm -> last_frame_seg_map ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <vul-end> ; if ( <vul-start> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <vul-start> return predicted_segment_id ; } <vul-start> ) { const vpx_prob <vul-end> pred_prob = vp9_get_pred_prob_seg_id <vul-start> -> seg_id_predicted = vpx_read <vul-end> ( r , <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , segment_id )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int mi_col, vpx_reader <vul-end> * r ) <vul-start> BLOCK_SIZE bsize = mbmi -> sb_type * mbmi -> sb_rows * mbmi -> sb_cols <vul-end> ; int predicted_segment_id <vul-start> ; predicted_segment_id = get_segment_id <vul-end> ( cm, <vul-start> cm -> last_frame_seg_map, xd -> mbmi_ext <vul-start> -> update_map ) { set_segment_id ( cm, bsize, mi_row, mi_col, segment_id ) ; <vul-start> return predicted_segment_id ; } <vul-start> ) { const vpx_prob pred_prob = get_pred_prob_seg_id <vul-end> ( seg, <vul-start> -> seg_id_predicted = vpx_read <vul-end> ( r, <vul-start> ) ; } <vul-end> return segment_id ;\n"
  },
  {
    "id": 148,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <vul-start> if ( shdr -> sh_size < 1 ) { <vul-end> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning: Cannot allocate memory (Check Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> sh_size < 1 || shdr -> sh_size > SIZE_MAX\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> sh_size < 1 || shdr -> sh_size > SIZE_MAX\n"
  },
  {
    "id": 149,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 jpc_ms_t * jpc_getms ( jas_stream_t * in , jpc_cstate_t * cstate ) { jpc_ms_t * ms ; jpc_mstabent_t * mstabent ; jas_stream_t * tmpstream ; if ( ! ( ms = jpc_ms_create ( 0 ) ) ) { return 0 ; } if ( jpc_getuint16 ( in , & ms -> id ) || ms -> id < JPC_MS_MIN || ms -> id > JPC_MS_MAX ) { jpc_ms_destroy ( ms ) ; return 0 ; } mstabent = jpc_mstab_lookup ( ms -> id ) ; ms -> ops = & mstabent -> ops ; if ( JPC_MS_HASPARMS ( ms -> id ) ) { if ( jpc_getuint16 ( in , & ms -> len ) || ms -> len < 3 ) { jpc_ms_destroy ( ms ) ; return 0 ; } ms -> len -= 2 ; if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { jpc_ms_destroy ( ms ) ; return 0 ; } if ( jas_stream_copy ( tmpstream , in , ms -> len ) || jas_stream_seek ( tmpstream , 0 , SEEK_SET ) < 0 ) { jas_stream_close ( tmpstream ) ; jpc_ms_destroy ( ms ) ; return 0 ; } if ( ( * ms -> ops -> getparms ) ( ms , cstate , tmpstream ) ) { ms -> ops = 0 ; jpc_ms_destroy ( ms ) ; jas_stream_close ( tmpstream ) ; return 0 ; } if ( jas_getdbglevel ( ) > 0 ) { jpc_ms_dump ( ms , stderr ) ; } <vul-start> if ( JAS_CAST ( ulong , jas_stream_tell",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ( JAS_CAST ( jas_ulong <vul-end> , jas_stream_tell (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ( JAS_CAST ( jas_ulong <vul-end>, jas_stream_tell (\n"
  },
  {
    "id": 150,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <vul-start> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\tOptions [%s]\" , bittok2str ( ospf6_option_values , \"none\" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t Designated Router %s\" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , \", Backup Designated Router %s\" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> hello6 * ) op + OSPF6HDR_LEN ; ND_TCHECK ( hellop -> hello_dr ) ; ND_TCHECK ( hellop -> hello_bdr ) ; ND_TCHECK ( hellop -> hello_bdr ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_TCHECK ( hellop -> hello_options ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr )!= 0 ) ND_PRINT ( ( ndo, \"\\\\n\\\\t Designated Router %s\", ipaddr_string ( ndo, & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo, \"\\\\n\\\\t Backup Designated Router %s\", ipaddr_string ( ndo, & hellop -> hello_bdr ) ) ) ; ++ hellop ; } hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) <vul-end> ) ; ND_PRINT\n"
  },
  {
    "id": 151,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( \"/dev/null\" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( \"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]\" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , ' ' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , ' ' ) [ 0 ] = '\\\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( \"CCpp.conf\" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , \"MakeCompatCore\" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"SaveBinaryImage\" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"VerboseLog\" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> , fsuid , <vul-end> NULL ) ;\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start>, fsuid, rootdir,\n"
  },
  {
    "id": 152,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <vul-end> { mp4object * mp4 = ( mp4object * ) handle ; if ( mp4 == NULL ) return 0.0 ; GPMF_stream metadata_stream , * ms = & metadata_stream ; uint32_t teststart = 0 ; uint32_t testend = mp4 -> indexcount ; <vul-start> double rate = 0.0 ; <vul-end> if ( mp4 -> indexcount < 1 ) return 0.0 ; <vul-start> if ( mp4 -> indexcount > 3 ) <vul-end> { teststart ++ ; <vul-start> testend -- ; <vul-end> <vul-start> } <vul-end> <vul-start> uint32_t * payload = GetPayload ( handle , NULL , teststart ) ; <vul-end> <vul-start> uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ; <vul-end> int32_t ret = GPMF_Init ( ms , payload , payloadsize ) ; <vul-start> if ( ret != GPMF_OK ) <vul-end> goto cleanup ; { uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; uint32_t missing_samples = 0 ; while ( ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) <vul-start> { <vul-end> missing_samples = 1 ; teststart ++ ; <vul-start> payload = GetPayload ( handle , payload , teststart ) ; <vul-end> <vul-start> payloadsize = GetPayloadSize ( handle , teststart ) ; <vul-end> <vul-start> ret = GPMF_Init ( ms , payload , payloadsize ) ; <vul-end> } if ( missing_samples ) { teststart ++ ; payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ;",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> , uint32_t flags , double * firstsampletime , double * lastsampletime <vul-start> rate = 0.0 ; uint32_t * payload ; uint32_t payloadsize ; int32_t ret <vul-start> return 0.0 ; payload = GetPayload ( handle , NULL , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; { uint64_t minimumtimestamp = 0 ; uint64_t starttimestamp = 0 ; uint64_t endtimestamp = 0 ; uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; double intercept = 0.0 ; while ( teststart < <vul-end> mp4 -> indexcount <vul-start> mp4 -> indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) <vul-end> ) { teststart <vul-start> teststart ++ ; payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } if ( ret == GPMF_OK && payload ) { uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ; if ( starttimestamp ) { GPMF_stream any_stream ; GPMF_Init ( & any_stream , payload , payloadsize ) ; minimumtimestamp = starttimestamp ; while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) { uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ; if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ; } } testend = mp4 -> indexcount ; do { <vul-start> testend -- ; <vul-end> payload = GetPayload <vul-start> ( handle , payload , testend ) ; <vul-end> payloadsize = GetPayloadSize <vul-start> ( handle , testend ) ; <vul-end> ret = GPMF_Init <vul-start> payloadsize ) ; } while ( testend > 0 <vul-end> && GPMF_OK != <vul-start> GPMF_RECURSE_LEVELS ) ) ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ; else { uint32_t i ; for ( i = teststart ; i <= testend ; i ++ ) { <vul-end> payload = GetPayload <vul-start> , payload , i <vul-end> ) ; payloadsize <vul-start> ( handle , i ) ; if ( GPMF_OK == <vul-end> GPMF_Init ( ms <vul-start> , payloadsize ) ) if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) endsamples += GPMF_PayloadSampleCount ( ms ) ; } } if ( starttimestamp != 0 <vul-end> ) { uint32_t <vul-start> ) { uint32_t last_samples = GPMF_PayloadSampleCount ( ms ) ; uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples ; double time_stamp_scale = 1000000000.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) endtimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData <vul-end> ( & find_stream <vul-start> ( & find_stream ) ) ; if ( endtimestamp ) { double approxrate = 0.0 ; if ( endsamples > startsamples ) approxrate <vul-end> = ( double <vul-start> indexcount ) ; if ( approxrate == 0.0 ) approxrate <vul-end> = ( double <vul-start> indexcount ) ; while ( time_stamp_scale >= 1 ) { rate = ( double ) ( totaltimestamped_samples ) / ( ( double ) ( endtimestamp - starttimestamp ) / time_stamp_scale ) ; if ( rate * 0.9 < approxrate && approxrate < rate * 1.1 ) break ; time_stamp_scale *= 0.1 ; } if ( time_stamp_scale < 1.0 ) rate = 0.0 ; intercept = ( ( ( double ) minimumtimestamp - ( double ) starttimestamp ) / time_stamp_scale ) * rate ; } } if ( rate == 0.0 ) { if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) ) { if ( endsamples > startsamples ) rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) <vul-end> mp4 -> indexcount <vul-start> mp4 -> indexcount ) ; if ( rate == 0.0 ) rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ; double in , out ; if ( GPMF_OK == GetPayloadTime ( handle , teststart , & in , & out ) ) intercept = ( double ) - in * rate ; } else { uint32_t payloadpos = 0 , payloadcount = 0 ; double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ; uint32_t * repeatarray = malloc ( mp4 -> indexcount <vul-start> teststart ; payloadpos <= testend ; payloadpos ++ ) { payload = GetPayload ( handle , payload , payloadpos ) ; payloadsize = GetPayloadSize ( handle , payloadpos ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) { GPMF_stream find_stream2 ; GPMF_CopyState ( ms , & find_stream2 ) ; payloadcount ++ <vul-end> ; if ( <vul-start> == GPMF_FindNext ( & find_stream2 <vul-end> , fourcc , <vul-start> , fourcc , <vul-end> GPMF_CURRENT_LEVEL ) ) <vul-start> repeatarray ) { double <vul-end> in , out <vul-start> ) samples ; if ( GPMF_OK == <vul-start> & out ) ) <vul-end> meanX += out <vul-start> uint32_t repeat = GPMF_PayloadSampleCount <vul-end> ( ms ) <vul-start> repeatarray ) { double <vul-end> in , out <vul-start> ) samples ; if ( GPMF_OK == <vul-start> & out ) ) <vul-end> meanX += out <vul-start> } } } else { <vul-end> repeatarray [ payloadpos <vul-start> [ payloadpos ] = 0 ; } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos <= testend ; payloadpos ++ ) { double in , out ; if ( repeatarray [ payloadpos ] && GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) { top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] <vul-start> meanX ) ; } <vul-start> / bot ; rate = slope ; intercept = meanY - slope * meanX ; <vul-start> # if 0 printf ( \"%c%c%c%c start offset = %f (%.3fms) rate = %f\\\\n\" <vul-end> , PRINTF_4CC ( <vul-start> intercept / slope , rate ) ; printf ( \"%c%c%c%c first sample at time %.3fms\\\\n\" , PRINTF_4CC ( fourcc ) , - 1000.0 * intercept / slope ) ; # endif <vul-end> } else { <vul-start> repeatarray ) ; } } if ( firstsampletime && lastsampletime ) { uint32_t endpayload = mp4 -> indexcount ; do { endpayload -- ; payload = GetPayload ( handle , payload , endpayload ) ; payloadsize = GetPayloadSize ( handle , endpayload ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ; if ( endpayload > 0 && ret == GPMF_OK ) { uint32_t totalsamples = endsamples - startsamples ; float timo = 0.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ; double first , last ; first = - intercept / rate - timo ; last = first + ( double ) totalsamples / rate ; if ( firstsampletime ) * firstsampletime = first ; if ( lastsampletime ) * lastsampletime = last ; } <vul-end> } } } <vul-start> ( payload ) <vul-end> FreePayload ( payload <vul-start> = NULL ; <vul-end> return rate ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, uint32_t flags, uint32_t num_samples <vul-start> rate = 0.0 ; uint32_t * payload = NULL ; uint32_t payloadsize = 0 <vul-start> -> indexcount ; uint32_t * expect = NULL ; uint32_t * expectptr = NULL <vul-start> return 0.0 ; <vul-end> if ( mp4 <vul-start> > 3 ) <vul-end> teststart ++ ; <vul-start> teststart ++ ; <vul-end> testend -- ; <vul-start> -- ; } expectptr = ( uint32_t * ) GPMF_RawData ( ms ) ; <vul-start> ( handle, expectptr <vul-end>, NULL, <vul-start>, NULL, payload, teststart ) ) ; payload = ( uint32_t * ) GPMF_RawData ( ms ) ; payloadsize = GetPayloadSize ( handle, expectptr <vul-end> ) ; int32_t <vul-start> ; int32_t ret ; ret = GPMF_Init ( ms, payload, payloadsize ) ; if ( ret!= GPMF_OK ) goto cleanup ; if ( flags & GPMF_RECURSE_LEVELS ) ) { if ( mp4 -> indexcount == 4 ) { expectptr = ( uint32_t * ) GPMF_RawData ( ms ) ; payload = ( uint32_t * ) GPMF_RawData ( ms ) ; } else { expectptr = ( uint32_t * ) GPMF_RawData ( ms ) ; payloadsize = GetPayloadSize ( handle, expectptr ) ; } if ( expectptr ) { rate = 0.0 ; } else { rate = 0.0 ; } } else { uint32_t payloadpos = 0, payloadcount = 0 ; double slope = 0.0 ; if ( mp4 -> indexcount > 0 ) { rate = 0.0 ; } else { rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) mp4 -> indexcount + 1 ) ) / ( double ) mp4 -> indexcount + 1 ) ; } } else { uint32_t payloadpos = 0, payloadcount = 0 ; double slope = 0.0 ; if ( mp4 -> indexcount > 0 ) { rate = 0.0 ; if ( mp4 -> indexcount > 0 ) { rate = 0.0 ; } else { rate = ( double ) ( samples ) / ( mp"
  },
  {
    "id": 153,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <vul-start> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <vul-end> duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows must be unconditional and \" \"use the STANDARD target with \" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
  },
  {
    "id": 154,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void * zend_mm_realloc_heap ( zend_mm_heap * heap , void * ptr , size_t size , size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC ) { size_t page_offset ; size_t old_size ; size_t new_size ; void * ret ; # if ZEND_DEBUG size_t real_size ; zend_mm_debug_info * dbg ; # endif page_offset = ZEND_MM_ALIGNED_OFFSET ( ptr , ZEND_MM_CHUNK_SIZE ) ; if ( UNEXPECTED ( page_offset == 0 ) ) { if ( UNEXPECTED ( ptr == NULL ) ) { return zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; } old_size = zend_mm_get_huge_block_size ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_DEBUG real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif if ( size > ZEND_MM_MAX_LARGE_SIZE ) { # if ZEND_DEBUG size = real_size ; # endif # ifdef ZEND_WIN32 new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , MAX ( REAL_PAGE_SIZE , ZEND_MM_CHUNK_SIZE ) ) ; # else new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , REAL_PAGE_SIZE ) ; # endif if ( new_size == old_size ) { # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } else if ( new_size < old_size ) { if ( zend_mm_chunk_truncate ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size -= old_size - new_size ; # endif # if ZEND_MM_STAT heap -> size -= old_size - new_size ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size (",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> { int old_bin_num <vul-end> = ZEND_MM_SRUN_BIN_NUM ( <vul-start> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <vul-start> return ptr ; }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> old_bin_num, bin_num, old_size <vul-start> old_bin_num ] ; old_size = ZEND_MM_SMALL_SIZE_TO_BIN ( size ) ; if ( old_size == 0 ) { # if ZEND_DEBUG dbg = zend_mm_get_debug_info ( heap, ptr ) ; dbg -> size = real_size ; dbg -> filename = __zend_filename ; dbg -> orig_filename = __zend_orig_filename ; dbg -> lineno = __zend_lineno ; dbg -> orig_lineno = __zend_orig_lineno ; # endif return ptr ; } else { <vul-start> ; # endif }\n"
  },
  {
    "id": 155,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; <vul-start> int hstartcol ; <vul-end> if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { <vul-start> hstartcol = ( numrows + 1 - parity ) >> 1 ; <vul-end> <vul-start> m = numrows - hstartcol ; <vul-end> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } <vul-start> dstptr = & a [ hstartcol * stride ] ; <vul-end> srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> m ; int hstartrow <vul-end> ; if ( <vul-start> 2 ) { hstartrow <vul-end> = ( numrows <vul-start> = numrows - hstartrow <vul-end> ; n = <vul-start> & a [ hstartrow <vul-end> * stride ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int m ; jas_size_t <vul-end> hstartcol ; if <vul-start> 2 ) { <vul-end> m = numrows <vul-start> = numrows - ( int ) <vul-start> & a [ ( int ) <vul-start> numrows + 1 <vul-end> ) * stride\n"
  },
  {
    "id": 156,
    "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = \"Deleting\" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 6 : <vul-start> # line 96 \"re_grammar.y\" <vul-end> { yr_free ( ( ( * yyvaluep ) . class_vector ) ) ; } <vul-start> # line 1045 \"re_grammar.c\" <vul-end> break ; case 26 : <vul-start> # line 97 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1051 \"re_grammar.c\" break ; case 27 : <vul-start> # line 98 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1057 \"re_grammar.c\" break ; case 28 : <vul-start> # line 99 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1063 \"re_grammar.c\" break ; case 29 : <vul-start> # line 100 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1069 \"re_grammar.c\" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }",
    "golden_answers": [
      "CWE-674 Fixed Code Lines are: <vul-start> : # line 104 <vul-end> \"re_grammar.y\" { yr_free <vul-start> } # line 1053 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 106 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 107 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 108 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <vul-end> \"re_grammar.c\" break ;\n"
    ],
    "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> : # line 112 \"re_grammar.y\" { yr_free_class_vector <vul-end> ( ( ( <vul-start> } # line 1051 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 112 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1057 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 112 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1061 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1061 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 1051 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1061 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 1051 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1057 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 1082 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1061 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 1082 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1082 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 1082 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1082 <vul-end> \"re_grammar.c\" break ;\n"
  },
  {
    "id": 157,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * setv4key_principal_2_svc ( setv4key_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setv4key_principal ( ( void * ) handle , arg -> princ , arg -> keyblock ) ; } else { log_unauth ( \"kadm5_setv4key_principal\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_setv4key_principal\" ,",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 158,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int psf_close ( SF_PRIVATE * psf ) { uint32_t k ; int error = 0 ; if ( psf -> codec_close ) { error = psf -> codec_close ( psf ) ; psf -> codec_close = NULL ; } ; if ( psf -> container_close ) error = psf -> container_close ( psf ) ; error = psf_fclose ( psf ) ; <vul-start> psf_close_rsrc ( psf ) ; <vul-end> free ( psf -> container_data ) ; free ( psf -> codec_data ) ; free ( psf -> interleave ) ; free ( psf -> dither ) ; free ( psf -> peak_info ) ; free ( psf -> broadcast_16k ) ; free ( psf -> loop_info ) ; free ( psf -> instrument ) ; free ( psf -> cues ) ; free ( psf -> channel_map ) ; free ( psf -> format_desc ) ; free ( psf -> strings . storage ) ; if ( psf -> wchunks . chunks ) for ( k = 0 ; k < psf -> wchunks . used ; k ++ ) free ( psf -> wchunks . chunks [ k ] . data ) ; free ( psf -> rchunks . chunks ) ; free ( psf -> wchunks . chunks ) ; free ( psf -> iterator ) ; free ( psf -> cart_16k ) ; memset ( psf , 0 , sizeof ( SF_PRIVATE ) ) ; free ( psf ) ; return error ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> psf ) ; if ( psf -> rsrc_filename ) psf_free_rsrc_filename ( psf -> rsrc_filename ) ;\n"
  },
  {
    "id": 159,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , \"git_stream\" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error ||",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; int is_valid = ( error == GIT_OK ) <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> * cert ; <vul-end> if ( ( <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
  },
  {
    "id": 160,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewHmp ( uint8_t * hmp_data , uint32_t hmp_size ) { uint8_t is_hmp2 = 0 ; uint32_t zero_cnt = 0 ; uint32_t i = 0 ; uint32_t hmp_file_length = 0 ; uint32_t hmp_chunks = 0 ; uint32_t hmp_divisions = 0 ; uint32_t hmp_unknown = 0 ; uint32_t hmp_bpm = 0 ; uint32_t hmp_song_time = 0 ; struct _mdi * hmp_mdi ; uint8_t * * hmp_chunk ; uint32_t * chunk_length ; uint32_t * chunk_ofs ; uint32_t * chunk_delta ; uint8_t * chunk_end ; uint32_t chunk_num = 0 ; uint32_t hmp_track = 0 ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t end_of_chunks = 0 ; uint32_t var_len_shift = 0 ; float tempo_f = 500000.0 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; if ( memcmp ( hmp_data , \"HMIMIDIP\" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; return NULL ; } hmp_data += 8 ; hmp_size -= 8 ; if ( ! memcmp ( hmp_data , \"013195\" , 6 ) ) { hmp_data += 6 ; hmp_size -= 6 ; is_hmp2 = 1 ; } if ( is_hmp2 ) { zero_cnt = 18 ; } else { zero_cnt = 24 ; } for ( i = 0 ; i < zero_cnt ; i ++ ) { if ( hmp_data [ i ] != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; return NULL ; } } hmp_data += zero_cnt ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ] + chunk_length [ i ] ; chunk_length [ i ] -= chunk_ofs <vul-start> += 3 ; chunk_length [ i ] -= 3 ; <vul-start> hmp_mdi , hmp_chunk [ i ] , chunk_length <vul-start> ] = 1 ; chunk_length [ i ] -= 3 <vul-start> += setup_ret ; chunk_length [ i ] -= setup_ret ; <vul-start> ; if ( chunk_length [ i ] && <vul-start> { do { if ( ! chunk_length [ i ] ) break ; <vul-start> ] ++ ; chunk_length [ i ] -- ; <vul-start> ) ; } if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , \"file too short\" , 0 ) ; goto _hmp_end ; } <vul-start> i ] ++ ; chunk_length [ i ] --\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] ; } hmp_size -= ( uint32_t ) chunk_length [ i ] ; <vul-start> i ] + hmp_size <vul-end> ; hmp_chunk [\n"
  },
  {
    "id": 161,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static fp_info * fp_set_per_packet_inf_from_conv ( umts_fp_conversation_info_t * p_conv_data , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree _U_ ) { fp_info * fpi ; guint8 tfi , c_t ; int offset = 0 , i = 0 , j = 0 , num_tbs , chan , tb_size , tb_bit_off ; gboolean is_control_frame ; umts_mac_info * macinf ; rlc_info * rlcinf ; guint8 fake_lchid = 0 ; gint * cur_val = NULL ; fpi = wmem_new0 ( wmem_file_scope ( ) , fp_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 , fpi ) ; fpi -> iface_type = p_conv_data -> iface_type ; fpi -> division = p_conv_data -> division ; fpi -> release = 7 ; fpi -> release_year = 2006 ; fpi -> release_month = 12 ; fpi -> channel = p_conv_data -> channel ; fpi -> dch_crc_present = p_conv_data -> dch_crc_present ; fpi -> link_type = FP_Link_Ethernet ; # if 0 if ( ! pinfo -> fd -> flags . visited && p_conv_data -> reset_frag ) { fpi -> reset_frag = p_conv_data -> reset_frag ; p_conv_data -> reset_frag = FALSE ; } # endif fpi -> srcport = pinfo -> srcport ; fpi -> destport = pinfo -> destport ; fpi -> com_context_id = p_conv_data -> com_context_id ; if ( pinfo -> link_dir == P2P_DIR_UL ) { fpi -> is_uplink = TRUE ; } else { fpi -> is_uplink = FALSE ; } is_control_frame = tvb_get_guint8 ( tvb , offset ) & 0x01 ; switch ( fpi -> channel ) { case CHANNEL_HSDSCH : fpi ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; c_t = ( <vul-start> , 4 ) + 1 ) % 0xf <vul-start> ] = c_t <vul-end> ; macinf -> <vul-start> lchId_type_table [ c_t <vul-end> ] ; rlcinf <vul-start> lchId_rlc_map [ c_t <vul-end> ] ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 4 ) ; if ( fpi -> lchid [ j + chan ] == 0 ) { <vul-start> 1 ] ; } else { c_t = p_conv_data -> dch_type_table [ p_conv_data -> dch_type_map [ p_conv_data -> dch_type_map [ chan ] ] ; } <vul-start> chan ] = c_t <vul-end> ; } }\n"
  },
  {
    "id": 162,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; <vul-start> struct sctp_sockaddr_entry * laddr ; <vul-end> union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; <vul-start> __u8 matchlen = 0 ; <vul-end> __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( \"%s: dst=%pI6 \" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( \"src=%pI6 - \" , & fl6 -> saddr ) ; } <vul-start> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <vul-end> if ( ! asoc || saddr ) goto out ; bp = & asoc -> base .",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <vul-start> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <vul-start> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-start> , fl6 , final_p <vul-end> , false ) <vul-start> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-start> , fl6 , final_p <vul-end> , false )\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> * bp ; <vul-end> union sctp_addr * <vul-start> sctp_addr dst_saddr ; __u32 matchlen = 0 ; __u32 bmatchlen ; __u8 * daddr_copy = NULL ; __u8 * fl6_dst = NULL ; __u8 * bmatchlen = NULL ; __u8 * daddr_copy = NULL <vul-end> ; memset ( <vul-start>, fl6, & fl6_dst, sizeof ( fl6_dst ) ) ; if (! dst ) goto out ; bp = & asoc -> base. bind_addr ; scope = sctp_scope ( daddr ) ; if ( ipv6_addr_type ( & daddr -> v6. sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> fl6_oif = daddr -> v6. sin6_port ; pr_debug ( \"src=%pI6 - \", & fl6 -> saddr ) ; if (! baddr || ( matchlen < bmatchlen ) ) goto out ; bp = & asoc -> base. bind_addr ; scope = sctp_scope ( daddr ) ; if (! fl6 -> fl6_sport ) { fl6 -> fl6_sport = htons ( bp -> port ) ; fl6 -> fl6_sport = htons ( bp -> port ) ; } fl6 -> fl6_flow = IPPROTO_SCTP ; if (! fl6 -> fl6_flow ) { fl6 -> fl6_sport = htons ( bp -> port ) ; } fl6 -> fl6_flow = fl6 -> fl6_proto ; daddr = & fl6 -> fl6_daddr ; if ( ipv6_addr_type ( & daddr -> v6. sin6_addr ) & IPV6_ADDR_LINKLOCAL ) { fl6 -> fl6_proto = IPPROTO_UDP ; } daddr = & fl6 -> fl6_daddr ; if ( ipv6_addr_type ( & daddr -> v6. sin6_port ) & IPV6_ADDR_LEN ) { fl6 -> fl6_sport = baddr -> v6. sin6_port ; daddr = & daddr -> v6. sin6_port ; }"
  },
  {
    "id": 163,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> * sizeof ( <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> ; pixels =\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> rows * ( size_t ) <vul-start> -> rows * ( size_t )\n"
  },
  {
    "id": 164,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { # define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id * p ; struct ikev1_pl_id id ; static const char * idtypestr [ ] = { \"IPv4\" , \"IPv4net\" , \"IPv6\" , \"IPv6net\" , } ; static const char * ipsecidtypestr [ ] = { NULL , \"IPv4\" , \"FQDN\" , \"user FQDN\" , \"IPv4net\" , \"IPv6\" , \"IPv6net\" , \"IPv4range\" , \"IPv6range\" , \"ASN1 DN\" , \"ASN1 GN\" , \"keyid\" , } ; int len ; const u_char * data ; ND_PRINT ( ( ndo , \"%s:\" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; p = ( const struct ikev1_pl_id * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; if ( sizeof ( * p ) < item_len ) { data = ( const u_char * ) ( p + 1 ) ; len = item_len - sizeof ( * p ) ; } else { data = NULL ; len = 0 ; } # if 0 ND_PRINT ( ( ndo , \" [phase=%d doi=%d proto=%d]\" , phase , doi , proto ) ) ; # endif switch ( phase ) { # ifndef USE_IPSECDOI_IN_PHASE1 case 1 : # endif default : ND_PRINT ( ( ndo , \" idtype=%s\" , STR_OR_ID ( id . d .",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( len < 32 ) ND_PRINT ( ( ndo , \" len=%d [bad: < 32]\" <vul-end> , len )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( len < 128 <vul-end> ) ND_PRINT (\n"
  },
  {
    "id": 165,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <vul-start> if ( data -> multi_easy ) <vul-end> <vul-start> curl_multi_cleanup ( data -> multi_easy ) ; <vul-end> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> -> multi_easy ) { <vul-start> multi_easy ) ; data -> multi_easy = NULL ; }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> multi_easy ) { struct curl_multi_easy_state * state = data -> multi_easy ; if ( state -> clean_sema ) curl_multi_easy_cleanup ( state -> clean_sema ) ; } <vul-end> Curl_llist_destroy ( &\n"
  },
  {
    "id": 166,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_build_intra_predictors_mbuv_s_c ( MACROBLOCKD * x , unsigned char * uabove_row , unsigned char * vabove_row , unsigned char * uleft , unsigned char * vleft , int left_stride , unsigned char * upred_ptr , unsigned char * vpred_ptr , int pred_stride ) { unsigned char uleft_col [ 8 ] ; unsigned char utop_left = uabove_row [ - 1 ] ; unsigned char vleft_col [ 8 ] ; unsigned char vtop_left = vabove_row [ - 1 ] ; int i , j ; for ( i = 0 ; i < 8 ; i ++ ) { uleft_col [ i ] = uleft [ i * left_stride ] ; vleft_col [ i ] = vleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . uv_mode ) { case DC_PRED : { int expected_udc ; int expected_vdc ; int shift ; int Uaverage = 0 ; int Vaverage = 0 ; if ( x -> up_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uabove_row [ i ] ; Vaverage += vabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uleft_col [ i ] ; Vaverage += vleft_col [ i ] ; } } if ( ! x -> up_available && ! x -> left_available ) { expected_udc = 128 ; expected_vdc = 128 ; } else { shift = 2 + x -> up_available + x -> left_available",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( upred_ptr , <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr , <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr , <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr , <vul-start> ++ ) { memset <vul-end> ( upred_ptr , <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( upred_ptr, <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr, <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr, <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr, <vul-start> ++ ) { memset <vul-end> ( upred_ptr, <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr,\n"
  },
  {
    "id": 167,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL rdp_decrypt ( rdpRdp * rdp , STREAM * s , int length , UINT16 securityFlags ) { BYTE cmac [ 8 ] ; BYTE wmac [ 8 ] ; if ( rdp -> settings -> EncryptionMethods == ENCRYPTION_METHOD_FIPS ) { UINT16 len ; BYTE version , pad ; BYTE * sig ; if ( stream_get_left ( s ) < 12 ) return FALSE ; stream_read_UINT16 ( s , len ) ; stream_read_BYTE ( s , version ) ; stream_read_BYTE ( s , pad ) ; sig = s -> p ; stream_seek ( s , 8 ) ; length -= 12 ; if ( ! security_fips_decrypt ( s -> p , length , rdp ) ) { printf ( \"FATAL: cannot decrypt\\\\n\" ) ; return FALSE ; } if ( ! security_fips_check_signature ( s -> p , length - pad , sig , rdp ) ) { printf ( \"FATAL: invalid packet signature\\\\n\" ) ; return FALSE ; } s -> size -= pad ; return TRUE ; } if ( stream_get_left ( s ) < 8 ) return FALSE ; stream_read ( s , wmac , sizeof ( wmac ) ) ; length -= sizeof ( wmac ) ; <vul-start> security_decrypt ( s -> p , length , rdp ) ; <vul-end> if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ; else security_mac_signature ( rdp , s -> p , length , cmac ) ; if ( memcmp ( wmac , cmac , sizeof ( wmac ) ) != 0 )",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> wmac ) ; if ( ! <vul-start> , rdp ) ) return FALSE\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> wmac ) ; if (! <vul-start>, rdp ) ) { printf ( \"FATAL: cannot decrypt\\\\n\" ) ; return FALSE ; } <vul-end> if ( securityFlags\n"
  },
  {
    "id": 168,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; <vul-start> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <vul-end> goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , \"Weird descriptor references\\\\n\" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, 0 ) ; if (! data_interface ||! control_interface ) goto skip_normal_probe\n"
  },
  {
    "id": 169,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( \"section len: %u properties %u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( \"CDF_VECTOR with nelements == 0\\\\n\" ) ) ; goto out ; } <vul-start> j < nelements && i < sh . sh_properties ; <vul-end> j ++ ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; o = CDF_TOLE2 ( q, 2 ) <vul-end> ; } else <vul-start> ; o = CDF_TOLE2 ( q, 1 ) <vul-end> ; } else\n"
  },
  {
    "id": 170,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static int <vul-end> <vul-start> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <vul-end> { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; <vul-start> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <vul-end> pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <vul-start> ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-end> hexdump = FALSE ; ND_PRINT ( ( ndo , \"%sRPKI-RTRv%u, %s PDU (%u), length: %u\" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , \"Unknown\" , pdu_type ) , <vul-start> pdu_type , pdu_len ) ) ; <vul-end> switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : <vul-start> case RPKI_RTR_END_OF_DATA_PDU : <vul-end> msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , \"%sSession ID: 0x%04x, Serial: %u\" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : <vul-start> break ; <vul-end> <vul-start> case RPKI_RTR_CACHE_RESPONSE_PDU : <vul-end> ND_PRINT ( ( ndo , \"%sSession ID: 0x%04x\" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; <vul-start> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <vul-end> ND_PRINT ( ( ndo , \"%sIPv4 Prefix %s/%u-%u, origin-as %u, flags 0x%02x\" , indent_string ( indent + 2 ) ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start>     static u_int <vul-end> rpki_rtr_pdu_print ( netdissect_options <vul-start> * tptr , const u_int len , const u_char recurse , const <vul-start> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , \"%sRPKI-RTRv%u (unknown)\" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , \"(%u bytes is too few to decode)\" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <vul-start> length ) ; <vul-end> hexdump = FALSE <vul-start> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <vul-start> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <vul-start> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <vul-start> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <vul-start> encapsulated_pdu_length ) ; tlen += 4 <vul-end> ; error_code = <vul-start> ) ) ; <vul-end> if ( encapsulated_pdu_length <vul-start> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <vul-end> { ND_PRINT ( <vul-start> ) ) ; <vul-end> rpki_rtr_pdu_print ( ndo <vul-start> ndo , tptr + tlen , encapsulated_pdu_length , 0 <vul-start> + 2 ) ; } tlen <vul-end> += encapsulated_pdu_length ; <vul-start> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <vul-end> ; text_length = <vul-start> ; text_length = <vul-end> EXTRACT_32BITS ( tptr <vul-start> EXTRACT_32BITS ( tptr + tlen ) ; tlen <vul-end> += 4 ; <vul-start> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , \"%sError text: \" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <vul-end> ND_TCHECK2 ( * <vul-start> * tptr , pdu_len ) ; <vul-end> hexdump = TRUE <vul-start> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , \"%s\" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <vul-end> ; trunc : <vul-start> ; trunc : ND_PRINT ( ( ndo , \"\\\\n\\\\t%s\" , tstr ) ) ; return len <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int rpki_rtr_pdu_print ( const rpki_rtr_options * ndo, <vul-end> const u_char * <vul-start> * ) tptr, u_int indent ) { <vul-end> const rpki_tr_pdu * <vul-start> rpki_rtr_pdu * ) ndo -> buf <vul-start> ; ND_TCHECK2 ( pdu -> flags, <vul-end> pdu_len ) ; <vul-start> pdu_len ) ) ; if ( indent == 0 ) goto trunc <vul-start> case RPKI_RTR_END_OF_DATA_PDU : ND_TCHECK2 ( * tptr, pdu_len ) ; <vul-start> case RPKI_RPKI_RTR_CACHE_RESET_PDU : ND_TCHECK2 ( * tptr, encapsulated_pdu_length ) ; <vul-start> case RPKI_RPKI_RTR_CACHE_RESPONSE_PDU : ND_TCHECK2 ( * tptr, encapsulated_pdu_length ) ; <vul-start> ) ) ; if ( indent == 1 ) goto trunc ; <vul-start> += encapsulated_pdu_length ; text_length = 0 ; if ( ( tlen > pdu_len ) && ( encapsulated_pdu_length <= pdu_len ) ) ) goto trunc ; } ND_TCHECK2 ( * tptr, text_length ) ; if ( ( text_length <= tlen ) ) { ND_PRINT ( ( ndo, \"%sError text: \", indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo, tptr, text_length, ndo -> ndo_snapend ) ) goto trunc ; } if ( ( ndo -> ndo_vflag > 1 || ( ndo -> ndo_vflag && hexdump ) ) ) goto trunc ; <vul-start> += encapsulated_pdu_length ; text_length = 0 ; if ( ( tlen > 4 ) && ( text_length > pdu_len ) ) ) { ND_PRINT ( ( ndo, \"%sError text: \", indent_string ( indent + 2 ), EXTRACT_32BITS ( pdu -> u. text_length ) ) ) ; if ( fn_printn ( ndo, t"
  },
  {
    "id": 171,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <vul-start> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <vul-end> picomp -> numrlvls - rlvlno - 1 ) ) ; <vul-start> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <vul-end> picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <vul-start> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <vul-end> ( pirlvl -> <vul-start> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <vul-end> ( pirlvl -> <vul-start> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpx ) <vul-start> x % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpx ) <vul-start> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpy ) <vul-start> y % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpy )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <vul-start> hsamp * ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> ( pirlvl -> <vul-start> vsamp * ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> ( pirlvl -> <vul-start> ) % ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> rpx ) ) <vul-start> ||! ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> rpx ) ) <vul-start> ||! ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> rpy ) ) <vul-start> ||! ( JAS_CAST ( uint_fast32_t, 1 ) << <vul-end> rpy ) )\n"
  },
  {
    "id": 172,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void l2tp_packet_print ( const struct l2tp_packet_t * pack , void ( * print ) ( const char * fmt , ... ) ) { const struct l2tp_attr_t * attr ; const struct l2tp_dict_value_t * val ; <vul-start> if ( pack -> hdr . ver == 2 ) { <vul-end> print ( \"[L2TP tid=%u sid=%u\" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ; log_ppp_debug ( \" Ns=%u Nr=%u\" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <vul-start> } else { <vul-end> print ( \"[L2TP cid=%u\" , pack -> hdr . cid ) ; <vul-start> log_ppp_debug ( \" Ns=%u Nr=%u\" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <vul-end> } list_for_each_entry ( attr , & pack -> attrs , entry ) { print ( \" <%s\" , attr -> attr -> name ) ; val = l2tp_dict_find_value ( attr -> attr , attr -> val ) ; if ( val ) print ( \" %s\" , val -> name ) ; else if ( attr -> H ) print ( \" (hidden, %hu bytes)\" , attr -> length ) ; else { switch ( attr -> attr -> type ) { case ATTR_TYPE_INT16 : print ( \" %i\" , attr -> val . int16 ) ; break ; case ATTR_TYPE_INT32 : print ( \" %i\" , attr -> val . int32 ) ; break ; case ATTR_TYPE_STRING : print ( \"",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * val ; switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <vul-end> print ( \"[L2TP tid=%u sid=%u\" <vul-start> ) ) ; break ; case 3 : <vul-end> print ( \"[L2TP cid=%u\" <vul-start> Nr ) ) ; break ; default : print ( \"[L2TP unknown version]\\\\n\" ) ; return\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * val ; print ( \"[L2TP cid=%u]\", <vul-end> pack -> hdr <vul-start> hdr. ver ) ; if ( pack -> hdr. ver <vul-start> == 2 ) print ( \"[L2TP tid=%u sid=%u\", ntohs ( pack -> hdr. tid ), ntohs ( pack -> hdr. sid ) ) ; else <vul-end> print ( \"[L2TP tid=%u sid=%u\" <vul-start> ) ) ; log_ppp_debug ( \" Ns=%u Nr=%u\" <vul-end>, ntohs ( <vul-start> Nr ) ) ; <vul-end> list_for_each_entry ( attr\n"
  },
  {
    "id": 173,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"Principal does not belong",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <vul-end> st = krb5_add_ber_mem_ldap_mod <vul-start> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <vul-end> if ( !\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, \"krb5-ldap-put-principal\", LDAP_MOD_NOENTRY |\n"
  },
  {
    "id": 174,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <vul-start> if ( size_left && size_left < 4 ) { <vul-end> LogError ( \"Process_ipfix [%u] Template size error at %s line %u\" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( \"\\\\n[%u] Template ID: %u\\\\n\" , exporter -> info . id , table_id ) ; dbg_printf ( \"FieldCount: %u buffersize: %u\\\\n\" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; if ( <vul-end> size_left < 4\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> if ( size_left < sizeof ( struct ipfix_template_record_std_t ) <vul-end> ) { LogError\n"
  },
  {
    "id": 175,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) ( ( ( unsigned char ) existing ) <vul-end> | ( ( <vul-start> ( ( col & ( unsigned char ) <vul-end> mask ) <<\n"
  },
  {
    "id": 176,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ; <vul-start> MACROBLOCKD * xd = args -> xd ; <vul-end> TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ; <vul-start> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; <vul-end> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ; <vul-start> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <vul-end> const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <vul-start> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; <vul-end> unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = <vul-start> cpi -> common . counts . eob_branch [ tx_size",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> cpi ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <vul-end> ; TOKENEXTRA * <vul-start> p = & x -> <vul-end> plane [ plane <vul-start> plane_type ; const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <vul-end> ( * const <vul-start> common . fc -> <vul-end> coef_probs [ tx_size <vul-start> COEFF_CONTEXTS ] = td -> counts -> <vul-end> eob_branch [ tx_size <vul-start> tx_size ) ; int16_t token ; EXTRABIT extra ; <vul-start> ] ; } vp9_get_token_extra ( v , & token , & extra ) ; <vul-start> pt ] , <vul-end> extra , ( <vul-start> ( uint8_t ) <vul-end> token , ( <vul-start> = vp9_pt_energy_class [ <vul-end> token ] ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> args -> xd <vul-end> ; uint8_t token_cache <vul-start> & cpi -> td. <vul-start> plane_type ; const MB_MODE_INFO_EXT * mbmi_ext = & xd -> mi [ 0 ] -> mbmi_ext ; const <vul-start> UNCONSTRAINED_NODES ] = vp9_get_eob_counts ( cpi, tx_size, type, ref, mbmi_ext ) ; unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = vp9_get_eob_branch ( cpi, tx_size, type, ref, xd_ext ) ; const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common. seg, segment_id, tx_size ) ; const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff, block ) ; const int16_t * scan, * nb ; const scan_order * so ; unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = <vul-start>. eob_branch [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const eob_branch ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = vp9_get_eob_counts ( cpi, tx_size, type, ref, xd_ext ) ; const uint8_t * const token_cache = vp9_get_token_cache ( cpi, tx_size, type, ref, eob_branch ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_TOKENS ] = vp9_get_eob_branch ( cpi, tx_size, type, ref, eob_branch ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_TOKENS ] [ <vul-start> ( uint8_t ) <vul-end> skip_eob, counts <vul-start> ] ] = vp9_get_token_cache ( cpi, tx_size, type, ref, eob_branch ) [ COEFF_CONTEXTS ] [ pt ], vp9_get_eob_counts ( cpi, tx_"
  },
  {
    "id": 177,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; struct stat stb ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerr ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode )",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ( void ) <vul-end> utimes ( vect <vul-start> ] , tv <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if (! Tflag &&\n"
  },
  {
    "id": 178,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <vul-start> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <vul-end> restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m ,",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> exit ; } m -> msg_namelen = 0 ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> exit ; } m -> msg_namelen = 0 ;\n"
  },
  {
    "id": 179,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = \"Getting sb failed\" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = \"Error parsing options\" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , \"ecryptfs\" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = \"Reading sb failed\" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , \"kern_path() failed\\\\n\" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR \"Mount on filesystem",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( \"eCryptfs: maximum fs stacking depth exceeded\\\\n\" ) ; goto out_free ; }\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path. dentry -> d_inode -> i_sb -> s_stack_depth ;\n"
  },
  {
    "id": 180,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none\" ; <vul-start> } else if ( options . compression == COMP_DELAYED ) { <vul-end> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none,zlib@openssh.com\" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( \"kex_setup: %s\" , ssh_err ( r ) ) ; kex = active_state -> kex ; # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> \"none\" ; } <vul-end> if ( options\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> options. compression!= COMP_DELAYED ) <vul-end> { myproposal [\n"
  },
  {
    "id": 181,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( \"ALSA: seq: too many ports for client %d\\\\n\" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , \"port-%d\" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <vul-start> num = port >= 0 ? port : 0 ; <vul-end> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <vul-start> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <vul-end> <vul-start> mutex_unlock (",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <vul-start> = num ; sprintf ( new_port -> name , \"port-%d\" , num ) ; <vul-start> client -> ports_mutex <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> c_dest ) ; snd_use_lock ( & new_port -> use_lock ) ; <vul-start> = num ; spin_lock ( & client -> ports_lock ) ; <vul-start> client -> ports_mutex ) ; spin_unlock ( & client -> ports_lock\n"
  },
  {
    "id": 182,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , \"r\" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_column_idx = ( unsigned int * ) malloc ( sizeof (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_row_idx <vul-start> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_row_idx <vul-start> return ; } LIBXSMM_ASSERT ( 0!= l_row && 0!= l_column ) ;\n"
  },
  {
    "id": 183,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int cipso_v4_sock_setattr ( struct sock * sk , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <vul-start> struct ip_options * opt = NULL ; <vul-end> struct inet_sock * sk_inet ; struct inet_connection_sock * sk_conn ; if ( sk == NULL ) return 0 ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto socket_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto socket_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto socket_setattr_failure ; } <vul-start> memcpy ( opt -> __data , buf , buf_len ) ; <vul-end> <vul-start> opt -> optlen = opt_len ; <vul-end> <vul-start> opt -> cipso = sizeof ( struct iphdr ) ; <vul-end> kfree ( buf ) ; buf = NULL ; sk_inet = inet_sk ( sk ) ; <vul-start> if ( sk_inet -> is_icsk ) { <vul-end> sk_conn = inet_csk ( sk ) ; <vul-start> if ( sk_inet -> opt ) <vul-end> <vul-start> sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ; <vul-end> <vul-start> sk_conn -> icsk_ext_hdr_len += opt -> optlen ; <vul-end> sk_conn -> icsk_sync_mss ( sk",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> opt_len ; struct ip_options_rcu * old , <vul-end> * opt = <vul-start> ( opt -> opt . <vul-start> ; opt -> opt . <vul-start> ; opt -> opt . <vul-start> sk ) ; old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <vul-start> ; if ( old <vul-end> ) sk_conn -> <vul-start> -> icsk_ext_hdr_len -= old -> opt . <vul-end> optlen ; sk_conn <vul-start> += opt -> opt . <vul-start> ) ; } rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> opt_len ; struct ip_options_rcu <vul-end> * opt = <vul-start> ( opt -> opt. <vul-start> ; opt -> opt. <vul-start> ; opt -> opt. <vul-start> ; if ( sk_inet -> opt. <vul-end> ) sk_conn -> <vul-start> -= sk_inet -> opt. <vul-end> optlen ; sk_conn <vul-start> += opt -> opt. <vul-start> ) ; } rcu_assign_pointer ( sk_inet -> opt, opt ) ; kfree ( buf <vul-end> ) ; return\n"
  },
  {
    "id": 184,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , <vul-start> & len , & iovec , compat ) ; <vul-end> else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , <vul-start> len , iovec ) ; <vul-end> if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> iovec , compat , & iter <vul-start> len , iovec , & iter <vul-start> iter_op ) { ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <vul-end> nr_segs , req\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, & len <vul-end>, & iovec <vul-start>, nr_segs, req -> ki_pos <vul-end> ) ; ret\n"
  },
  {
    "id": 185,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ; <vul-start> unsigned char signature [ 256 ] ; <vul-end> <vul-start> unsigned int siglen = sizeof signature ; <vul-end> const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; <vul-start> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <vul-end> goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , \"Error verifying key: %s\\\\n\" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( \"Error verifying key\" ) ) ; goto err ; } ok = 1 ; <vul-start> err : <vul-end> if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; unsigned char * signature = NULL <vul-end> ; unsigned int <vul-start> unsigned int siglen <vul-end> ; const EVP_MD <vul-start> ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <vul-start> ; err : free ( signature ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char signature [ 512 <vul-end> ] ; unsigned <vul-start> siglen = sizeof signature ; char * signature_copy = NULL <vul-end> ; const EVP_MD <vul-start> ; if ( NULL!= signature ) { signature_copy = alloc_string ( sizeof signature, 1 ) ; if (! signature_copy ) goto err ; strncpy ( signature, signature_copy, sizeof signature ) ; free ( signature_copy ) ; } if ( <vul-start> = 1 ; free ( signature_copy ) ;\n"
  },
  {
    "id": 186,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( \"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\\\n\" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , \"ipmi_si.%d\" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( \"ipmi_si\" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( \"Unable to allocate platform device\\\\n\" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ;",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; out_err : if ( new_smi -> io. dev ) device_free ( new_smi -> io. dev ) ;\n"
  },
  {
    "id": 187,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void encode_loopfilter ( struct loopfilter * lf , <vul-start> struct vp9_write_bit_buffer * wb ) { <vul-end> int i ; <vul-start> vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ; <vul-end> <vul-start> vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ; <vul-end> if ( lf -> mode_ref_delta_enabled ) { <vul-start> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ; <vul-end> if ( lf -> mode_ref_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { const int delta = lf -> ref_deltas [ i ] ; const int changed = delta != lf -> last_ref_deltas [ i ] ; <vul-start> vp9_wb_write_bit ( wb , changed ) ; <vul-end> if ( changed ) { lf -> last_ref_deltas [ i ] = delta ; <vul-start> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , delta < 0 ) ; <vul-end> } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { const int delta = lf -> mode_deltas [ i ] ; const int changed = delta != lf -> last_mode_deltas [ i ] ; <vul-start> vp9_wb_write_bit ( wb , changed ) ; <vul-end> if ( changed ) { lf -> last_mode_deltas [ i ] = delta ; <vul-start> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , delta < 0 ) ; <vul-end> } } } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> lf , struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> int i ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 3 ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> mode_ref_delta_enabled ) { vpx_wb_write_bit <vul-end> ( wb , <vul-start> i ] ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> i ] ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> lf, struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> int i ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 3 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> mode_ref_delta_enabled ) { vpx_wb_write_bit <vul-end> ( wb, <vul-start> i ] ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> i ] ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> = delta ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> i ] ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb,\n"
  },
  {
    "id": 188,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; <vul-start> struct in6_addr * saddr = NULL , * final_p , final ; <vul-end> struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> final_p , final ; struct ipv6_txoptions * opt <vul-start> ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <vul-start> & fl6 , <vul-end> opt , & <vul-start> ; if ( opt <vul-end> ) icsk -> <vul-start> -> icsk_ext_hdr_len = <vul-end> opt -> opt_flen <vul-start> -> opt_flen + <vul-end> opt -> opt_nflen <vul-start> opt -> opt_nflen <vul-end> ; inet ->\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> final_p, final ; struct ipv6_txoptions * opt <vul-start> ) ) ; opt = rcu_dereference_protected ( np -> opt, sock_owned_by_user ( sk ) ) ; <vul-start> & fl6, <vul-end> opt, & <vul-start> ; if ( <vul-end> opt!= NULL <vul-start> -> icsk_ext_hdr_len = <vul-end> opt -> opt_flen <vul-start> -> opt_flen + <vul-end> opt -> opt_nflen <vul-start> opt -> opt_nflen <vul-end> ; inet ->\n"
  },
  {
    "id": 189,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , \"MPLS\" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , \"[|MPLS], length %u\" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , \"%s(label %u\" , ( label_stack_depth && ndo -> ndo_vflag ) ? \"\\\\n\\\\t\" : \" \" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , \" (%s)\" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , \", exp %u\" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , \", [S]\" ) ) ; ND_PRINT ( ( ndo , \", ttl %u)\" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt =",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> p , length <vul-end> ) ; break\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> p, length <vul-end> ) ; break\n"
  },
  {
    "id": 190,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { <vul-start> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <vul-end> } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , \"%s/%s\" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , \".dsn\" ) ) { strcat ( szFileName , \".dsn\" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , \"#;\" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , \"#;\" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , \"\" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , \"\" ) == INI_SUCCESS ) { iniPropertyDelete",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( szFileName , pszFileName , <vul-start> ) - 5 <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> '/' ) { strcpy <vul-end> ( szFileName,\n"
  },
  {
    "id": 191,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int requireDirective ( MaState * state , cchar * key , cchar * value ) { char * age , * type , * rest , * option , * ovalue , * tok ; int domains ; if ( ! maTokenize ( state , value , \"%S ?*\" , & type , & rest ) ) { return MPR_ERR_BAD_SYNTAX ; } if ( scaselesscmp ( type , \"ability\" ) == 0 ) { httpSetAuthRequiredAbilities ( state -> auth , rest ) ; } else if ( scaselesscmp ( type , \"group\" ) == 0 || scaselesscmp ( type , \"role\" ) == 0 ) { httpSetAuthRequiredAbilities ( state -> auth , rest ) ; } else if ( scaselesscmp ( type , \"secure\" ) == 0 ) { domains = 0 ; age = 0 ; for ( option = stok ( sclone ( rest ) , \" \\\\t\" , & tok ) ; option ; option = stok ( 0 , \" \\\\t\" , & tok ) ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"age\" ) ) { age = sfmt ( \"%lld\" , ( int64 ) httpGetTicks ( ovalue ) ) ; } else if ( smatch ( option , \"domains\" ) ) { domains = 1 ; } } if ( age ) { if ( domains ) { age = sjoin ( \"-1\" , age , NULL ) ; } } addCondition",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
  },
  {
    "id": 192,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <vul-start> WORD16 i2_level_arr [ 4 ] ; <vul-end> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <vul-end> ] ; tu_sblk4x4_coeff_data_t\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 16 ; WORD16 ai2_level_arr [ 3 <vul-end> ] ; tu_sblk4x4_coeff_data_t\n"
  },
  {
    "id": 193,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <vul-start> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <vul-end> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt =",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark <vul-end> = 0 ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark = 0 ; NAPI_GRO_CB ( skb ) ->\n"
  },
  {
    "id": 194,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <vul-start> if ( shmflg & SHM_RND ) <vul-end> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR (",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> shmflg & SHM_RND ) && addr >= shmlba\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> shmflg & SHM_RND ) && addr >= shmlba\n"
  },
  {
    "id": 195,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 void perf_pmu_migrate_context ( struct pmu * pmu , int src_cpu , int dst_cpu ) { struct perf_event_context * src_ctx ; struct perf_event_context * dst_ctx ; struct perf_event * event , * tmp ; LIST_HEAD ( events ) ; src_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , src_cpu ) -> ctx ; dst_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , dst_cpu ) -> ctx ; <vul-start> mutex_lock ( & src_ctx -> mutex ) ; <vul-end> list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) { perf_remove_from_context ( event , false ) ; unaccount_event_cpu ( event , src_cpu ) ; put_ctx ( src_ctx ) ; list_add ( & event -> migrate_entry , & events ) ; } <vul-start> mutex_unlock ( & src_ctx -> mutex ) ; <vul-end> synchronize_rcu ( ) ; mutex_lock ( & dst_ctx -> mutex ) ; list_for_each_entry_safe ( event , tmp , & events , migrate_entry ) { list_del ( & event -> migrate_entry ) ; if ( event -> state >= PERF_EVENT_STATE_OFF ) event -> state = PERF_EVENT_STATE_INACTIVE ; account_event_cpu ( event , dst_cpu ) ; perf_install_in_context ( dst_ctx , event , dst_cpu ) ; get_ctx ( dst_ctx ) ; } mutex_unlock ( & dst_ctx -> mutex ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> -> ctx ; mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <vul-end> -> mutex ) <vul-start> ) ; } synchronize_rcu ( <vul-end> ) ; list_for_each_entry_safe <vul-start> mutex ) ; mutex_unlock ( & src_ctx -> mutex ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> ctx ; mutex_lock_nested <vul-end> ( & src_ctx <vul-start> src_ctx -> mutex, SINGLE_DEPTH_NESTING <vul-start> ) ; } mutex_unlock_nested <vul-end> ( & dst_ctx <vul-start> mutex ) ; mutex_lock_nested ( & src_ctx -> mutex, SINGLE_DEPTH_NESTING ) ; list_for_each_entry_safe ( event, tmp, & src_ctx -> event_list, event_entry ) { perf_remove_from_context ( event, false ) ; unaccount_event_cpu ( event, src_cpu ) ; put_ctx ( src_ctx ) ; list_add ( & event -> migrate_entry, & events ) ; } mutex_unlock_nested ( & dst_ctx -> mutex, SINGLE_DEPTH_NESTING ) ;\n"
  },
  {
    "id": 196,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |=",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; if (! try_get_page ( page ) ) { err = - ENOMEM ; break ; }\n"
  },
  {
    "id": 197,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( \"Invalid strings size\\\\n\" ) ; return false ; } if ( bin ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> header . types_size <vul-end> ) { continue\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> header. types_size <vul-end> ) { continue\n"
  },
  {
    "id": 198,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int rpc_pack ( rpc_pkg * pkg , void * * data , uint32_t * size ) { static void * send_buf ; static size_t send_buf_size ; <vul-start> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <vul-end> if ( send_buf_size < pkg_size ) { if ( send_buf ) free ( send_buf ) ; send_buf_size = pkg_size * 2 ; send_buf = malloc ( send_buf_size ) ; <vul-start> assert ( send_buf != NULL ) ; <vul-end> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE ) ; if ( pkg -> ext_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE , pkg -> ext , pkg -> ext_size ) ; if ( pkg -> body_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE + pkg -> ext_size , pkg -> body , pkg -> body_size ) ; pkg = send_buf ; pkg -> magic = htole32 ( RPC_PKG_MAGIC ) ; pkg -> command = htole32 ( pkg -> command ) ; pkg -> pkg_type = htole16 ( pkg -> pkg_type ) ; pkg -> result = htole32 ( pkg -> result ) ; pkg -> sequence = htole32 ( pkg -> sequence ) ; pkg -> req_id = htole64 ( pkg -> req_id ) ; pkg -> body_size = htole32 ( pkg -> body_size ) ; pkg -> ext_size = htole16 ( pkg -> ext_size ) ; pkg -> crc32 = 0 ; pkg -> crc32 = htole32 ( generate_crc32c ( send_buf , pkg_size ) ) ; * data = send_buf ; * size = pkg_size ; return 0 ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <vul-start> send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; } <vul-end> } memcpy (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> uint32_t pkg_size = RPC_PKG_BODY_SIZE <vul-end> + pkg -> <vul-start> pkg -> body_size ; if ( pkg -> ext_size || pkg -> body_size ) return - 1 <vul-start> send_buf_size ) ; if ( send_buf == NULL ) return - 1 ;\n"
  },
  {
    "id": 199,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BOOL update_recv ( rdpUpdate * update , wStream * s ) { BOOL rc = FALSE ; UINT16 updateType ; rdpContext * context = update -> context ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"Stream_GetRemainingLength(s) < 2\" ) ; return FALSE ; } Stream_Read_UINT16 ( s , updateType ) ; WLog_Print ( update -> log , WLOG_TRACE , \"%s Update Data PDU\" , UPDATE_TYPE_STRINGS [ updateType ] ) ; if ( ! update_begin_paint ( update ) ) goto fail ; switch ( updateType ) { case UPDATE_TYPE_ORDERS : rc = update_recv_orders ( update , s ) ; break ; case UPDATE_TYPE_BITMAP : { BITMAP_UPDATE * bitmap_update = update_read_bitmap_update ( update , s ) ; if ( ! bitmap_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> BitmapUpdate , context , bitmap_update ) ; free_bitmap_update ( update -> context , bitmap_update ) ; } break ; case UPDATE_TYPE_PALETTE : { PALETTE_UPDATE * palette_update = update_read_palette ( update , s ) ; if ( ! palette_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_PALETTE - update_read_palette() failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> Palette , context , palette_update ) ; free_palette_update ( context , palette_update ) ; } break ; case UPDATE_TYPE_SYNCHRONIZE : <vul-start> update_read_synchronize ( update , s ) ; <vul-end> rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ; break ; default : break ; } fail : if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> case UPDATE_TYPE_SYNCHRONIZE : if ( ! <vul-start> , s ) ) goto fail\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case UPDATE_TYPE_SYNCHRONIZE : if (! <vul-start>, s ) ) goto fail\n"
  },
  {
    "id": 200,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ; <vul-start> struct mb_cache_entry * ce = NULL ; <vul-end> int error = 0 ; <vul-start> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <vul-end> # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) { <vul-start> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <vul-end> bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , \"get_write_access\" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <vul-start> if ( ce ) { <vul-end> mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , \"modifying in-place\" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; }",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> s ; struct mb2_cache_entry <vul-end> * ce = <vul-start> 0 ; struct mb2_cache <vul-end> * ext4_mb_cache = <vul-start> base ) { <vul-end> BUFFER_TRACE ( bs <vul-start> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <vul-end> ea_bdebug ( bs <vul-start> bh ) ; <vul-end> ea_bdebug ( bs <vul-start> new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <vul-start> cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <vul-end> ce ) ; <vul-start> ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <vul-end> ce ) ;\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> s ; struct mb2_cache <vul-end> * ext4_mb_cache = <vul-start> 0 ; struct mb2_cache <vul-end> * ext4_mb_cache = <vul-start> base ) { <vul-end> BUFFER_TRACE ( bs <vul-start> ) ) { <vul-end> ea_bdebug ( bs\n"
  },
  {
    "id": 201,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version !=",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <vul-end> == SSL3_MT_CLIENT_HELLO )\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == SSL3_RT_HANDSHAKE && rr -> length == SSL3_RT_HANDSHAKE_ABORT &&\n"
  },
  {
    "id": 202,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int decode_rt_routing_info ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_target [ 8 ] ; u_int plen ; <vul-start> ND_TCHECK ( pptr [ 0 ] ) ; <vul-end> plen = pptr [ 0 ] ; if ( 0 == plen ) { snprintf ( buf , buflen , \"default route target\" ) ; return 1 ; } if ( 32 > plen ) return - 1 ; <vul-start> plen -= 32 ; <vul-end> if ( 64 < plen ) return - 1 ; memset ( & route_target , 0 , sizeof ( route_target ) ) ; <vul-start> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <vul-end> <vul-start> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <vul-end> if ( plen % 8 ) { ( ( u_char * ) & route_target ) [ ( plen + 7 ) / 8 - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , buflen , \"origin AS: %s, route target %s\" , <vul-start> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <vul-end> bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ; return 5 + ( plen + 7 ) / 8 ; trunc : return - 2 ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <vul-start> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <vul-start> ( pptr [ 5 <vul-end> ] , ( <vul-start> & pptr [ 5 <vul-end> ] , ( <vul-start> , \"origin AS: %s, route target %s\" , asbuf <vul-end> , bgp_vpn_rd_print (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u_int plen ; if ( buflen < 4 ) return - 1 ; <vul-start> -= 32 ; if ( plen < 4 ) return - 1 ; <vul-start> ) ) ; if ( plen > buflen - 4 ) return - 1 ; <vul-start> / 8 ) ; if ( plen > buflen - 4 ) return - 1 <vul-start>, EXTRACT_32BITS ( ( u_char * ) & route_target [ 0 ] <vul-end> ) ),\n"
  },
  {
    "id": 203,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; <vul-start> cstate = 0 ; <vul-end> if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { <vul-start> return - 1 ; <vul-end> } <vul-start> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <vul-end> ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( \"all tiles are outside the image area\\\\n\" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> uint_fast8_t tmp ; siz -> comps = 0 ; <vul-start> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( \"reference grid cannot have zero area\\\\n\" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( \"tile cannot have zero area\\\\n\" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( \"number of components not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( \"XOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( \"YOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( \"XTOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( \"YTOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( \"invalid XRsiz value %d\\\\n\" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( \"invalid YRsiz value %d\\\\n\" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <vul-start> 1 ; } <vul-end>      \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> uint_fast8_t tmp ; jas_uint16_t tmp2 ; <vul-start> ) ) { goto error <vul-end> ; } if <vul-start> siz -> tilewidth ||! siz -> tileheight\n"
  },
  {
    "id": 204,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( \"kadm5_get_strings\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle ->",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 205,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <vul-start> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <vul-end> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> data ) ; <vul-end> } } if <vul-start> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <vul-start> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( \"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\\\n\" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <vul-end> chunk ; }\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; if ( skb_is_gso ( chunk -> skb ) && <vul-start> ) ) { sctp_chunk_free_add ( chunk ) ;\n"
  },
  {
    "id": 206,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int squidclamav_check_preview_handler ( char * preview_data , int preview_data_len , ci_request_t * req ) { ci_headers_list_t * req_header ; struct http_info httpinf ; av_req_data_t * data = ci_service_data ( req ) ; char * clientip ; struct hostent * clientname ; unsigned long ip ; char * username ; char * content_type ; ci_off_t content_length ; char * chain_ret = NULL ; char * ret = NULL ; int chkipdone = 0 ; ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: processing preview header.\\\\n\" ) ; if ( preview_data_len ) ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\\\n\" , preview_data_len ) ; if ( ( req_header = ci_http_request_headers ( req ) ) == NULL ) { ci_debug_printf ( 0 , \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\\\n\" ) ; return CI_ERROR ; } if ( ( username = ci_headers_value ( req -> request_header , \"X-Authenticated-User\" ) ) != NULL ) { ci_debug_printf ( 2 , \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\\\n\" , username ) ; if ( simple_pattern_compare ( username , TRUSTUSER ) == 1 ) { ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\\\n\" , username ) ; return CI_MOD_ALLOW204 ; } } else { username = ( char * ) malloc ( sizeof ( char ) * 2 ) ; strcpy ( username , \"-\" ) ; } if ( ( clientip = ci_headers_value ( req -> request_header , \"X-Client-IP\" ) ) != NULL ) { ci_debug_printf ( 2 , \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\\\n\" , clientip ) ; ip = inet_addr ( clientip ) ; chkipdone =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 1 ) { char * rbuff = NULL ; <vul-start> method ) ; rbuff = replace ( httpinf . url , \"%\" , \"%25\" ) ; <vul-start> , \"%s %s %s %s\\\\n\" , rbuff <vul-end> , clientip , <vul-start> fflush ( sgfpw ) ; xfree ( rbuff\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) { char * chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ; if ( chain_ret == NULL ) { ci_debug_printf ( 1, \"ERROR squidclamav_check_preview_handler: Could not allocate chain data.\\\\n\" ) ; return CI_MOD_ALLOW204 ; } <vul-start> method ) ; if ( simple_pattern_compare ( httpinf. method, \"CONNECT\" ) == 0 ) { <vul-start> fflush ( sgfpw ) ; } free ( chain_ret\n"
  },
  {
    "id": 207,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void r_bin_dwarf_dump_debug_info ( FILE * f , const RBinDwarfDebugInfo * inf ) { size_t i , j , k ; RBinDwarfDIE * dies ; RBinDwarfAttrValue * values ; if ( ! inf || ! f ) { return ; } for ( i = 0 ; i < inf -> length ; i ++ ) { fprintf ( f , \" Compilation Unit @ offset 0x%\" PFMT64x \":\\\\n\" , inf -> comp_units [ i ] . offset ) ; fprintf ( f , \" Length: 0x%x\\\\n\" , inf -> comp_units [ i ] . hdr . length ) ; fprintf ( f , \" Version: %d\\\\n\" , inf -> comp_units [ i ] . hdr . version ) ; fprintf ( f , \" Abbrev Offset: 0x%x\\\\n\" , inf -> comp_units [ i ] . hdr . abbrev_offset ) ; fprintf ( f , \" Pointer Size: %d\\\\n\" , inf -> comp_units [ i ] . hdr . pointer_size ) ; dies = inf -> comp_units [ i ] . dies ; for ( j = 0 ; j < inf -> comp_units [ i ] . length ; j ++ ) { fprintf ( f , \" Abbrev Number: %\" PFMT64u \" \" , dies [ j ] . abbrev_code ) ; if ( dies [ j ] . tag && dies [ j ] . tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings [ dies [ j ] . tag ] ) { fprintf ( f , \"(%s)\\\\n\" , dwarf_tag_name_encodings [ dies [ j ] . tag ] ) ; } else { fprintf (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> . name ) { continue ; } <vul-end> if ( values\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ]. name || values [ k ]. name >= DW_AT_vtable_elem_location\n"
  },
  {
    "id": 208,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , \"%s()\\\\n\" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = -",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> noblock ) ; <vul-end> do { int\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> noblock ) ; <vul-end> do { int\n"
  },
  {
    "id": 209,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 PHP_FUNCTION ( imagecrop ) { zval * IM ; gdImagePtr im ; gdImagePtr im_crop ; gdRect rect ; zval * z_rect ; zval * * tmp ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"ra\" , & IM , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , \"Image\" , le_gd ) ; if ( zend_hash_find ( HASH_OF ( z_rect ) , \"x\" , sizeof ( \"x\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . x = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing x position\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"y\" , sizeof ( \"x\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . y = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing y position\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"width\" , sizeof ( \"width\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . width = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing width\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"height\" , sizeof ( \"height\" ) , ( void * * ) & tmp ) != FAILURE )",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . x = Z_LVAL ( lval ) ; } else { rect . x = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . y = Z_LVAL ( lval ) ; } else { rect . y = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . width = Z_LVAL ( lval ) ; } else { rect . width = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . height = Z_LVAL ( lval ) ; } else { rect . height = <vul-start> tmp ) ; }\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>. x = Z_LVAL <vul-end> ( tmp ) <vul-start>. y = Z_LVAL <vul-end> ( tmp ) <vul-start>. width = Z_LVAL <vul-end> ( tmp ) <vul-start>. height = Z_LVAL <vul-end> ( tmp )\n"
  },
  {
    "id": 210,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { PicContext * s = avctx -> priv_data ; AVFrame * frame = data ; uint32_t * palette ; int bits_per_plane , bpp , etype , esize , npal , pos_after_pal ; int i , x , y , plane , tmp , ret , val ; bytestream2_init ( & s -> g , avpkt -> data , avpkt -> size ) ; if ( bytestream2_get_bytes_left ( & s -> g ) < 11 ) return AVERROR_INVALIDDATA ; if ( bytestream2_get_le16u ( & s -> g ) != 0x1234 ) return AVERROR_INVALIDDATA ; s -> width = bytestream2_get_le16u ( & s -> g ) ; s -> height = bytestream2_get_le16u ( & s -> g ) ; bytestream2_skip ( & s -> g , 4 ) ; tmp = bytestream2_get_byteu ( & s -> g ) ; bits_per_plane = tmp & 0xF ; s -> nb_planes = ( tmp >> 4 ) + 1 ; bpp = bits_per_plane * s -> nb_planes ; if ( bits_per_plane > 8 || bpp < 1 || bpp > 32 ) { avpriv_request_sample ( avctx , \"Unsupported bit depth\" ) ; return AVERROR_PATCHWELCOME ; } if ( bytestream2_peek_byte ( & s -> g ) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8 ) { bytestream2_skip ( & s -> g , 2 ) ; etype = bytestream2_get_le16 ( & s -> g ) ; esize = bytestream2_get_le16 ( & s -> g )",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> avctx -> width || <vul-end> s -> height\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; if ( ( <vul-start> avctx -> height ) || ( s -> width && s -> height )\n"
  },
  {
    "id": 211,
    "question": "CWE-444 Code Input Vulnerable Code Is: CWE-444 static void add_header_value ( VALUE hh , const char * key , int klen , const char * val , int vlen ) { <vul-start> if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) { <vul-end> <vul-start> rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ; <vul-end> } else if ( sizeof ( content_length ) - 1 == klen && 0 == strncasecmp ( key , content_length , sizeof ( content_length ) - 1 ) ) { <vul-start> rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ; <vul-end> } else { char hkey [ 1024 ] ; char * k = hkey ; volatile VALUE sval = rb_str_new ( val , vlen ) ; <vul-start> strcpy ( hkey , \"HTTP_\" ) ; <vul-end> k = hkey + 5 ; if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) { klen = sizeof ( hkey ) - 6 ; } strncpy ( k , key , klen ) ; hkey [ klen + 5 ] = '\\\\0' ; for ( k = hkey + 5 ; '\\\\0' != * k ; k ++ ) { if ( '-' == * k ) { * k = '_' ; } else { * k = toupper ( * k ) ; } } <vul-start> rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ; <vul-end> <vul-start>",
    "golden_answers": [
      "CWE-444 Fixed Code Lines are: <vul-start> vlen ) { VALUE v ; <vul-start> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) { <vul-start> ) ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , rb_str_new ( val , vlen ) ) ; rb_hash_aset ( hh , content_type_val , a ) ; } <vul-start> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_length_val , Qnil ) ) ) { <vul-start> ) ) ; } else { rb_raise ( rb_eArgError , \"Multiple Content-Length headers.\" ) ; } <vul-start> vlen ) ; volatile VALUE kval ; <vul-start> ; } } kval = <vul-end> rb_str_new ( hkey <vul-start> + 5 ) ; if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) { rb_hash_aset ( hh , kval <vul-start> ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , sval ) ; rb_hash_aset ( hh , kval , a ) ; } }\n"
    ],
    "generated_answer": "CWE-444 Fixed Code Lines are: <vul-start> vlen ) { VALUE sval ; const char * hkey ; const char * sval ; <vul-start> ) ) { sval = rb_str_new ( val, vlen ) ; if (! sval ) { rb_raise ( rb_eArgError, \"rb_hash_aset\" ) ; return ; } hkey = hkey + 5 ; if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) { klen = sizeof ( hkey ) - 6 ; } strncpy ( k, key, klen ) ; hkey [ klen + 5 ] = '\\\\0' ; for ( k = hkey + 5 ; '\\\\0'!= * k ; k ++ ) { if ( '-' == * k ) { * k = '_' ; } else { * k ='' ; } } <vul-start>, content_type_val, sval ) ; } else if ( sizeof ( content_length ) - 1 == klen && 0 == strncasecmp ( key, content_length, sizeof ( content_length ) - 1 ) ) { rb_hash_aset ( hh, content_length_val, sval ) ; } else { char hkey [ 1024 ] ; char * k = hkey ; volatile VALUE sval ; if (! sval ) { rb_raise ( rb_eArgError, \"rb_hash_aset\" ) ; return ; } sval = rb_str_new ( val, vlen ) ; <vul-end> char hkey [ <vul-start> ( hkey, sval ) ; } sval = rb_str_new ( val, vlen ) ; <vul-end> rb_hash_aset ( hh <vul-start> ( hh, sval <vul-end> ) ; } <vul-start> ) ; } rb_hash_aset ( hh, rb_str_new ( hkey, klen + 5 ), sval ) ;\n"
  },
  {
    "id": 212,
    "question": "CWE-908 Code Input Vulnerable Code Is: CWE-908 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <vul-end> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ;",
    "golden_answers": [
      "CWE-908 Fixed Code Lines are: <vul-start> , tag ) \\\\\\n{ <vul-end> if ( palette <vul-start> tag ) ; \\\\\\n} <vul-end> Image * image <vul-start> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;\n"
    ],
    "generated_answer": "CWE-908 Fixed Code Lines are: <vul-start>, tag ) \\\\\\n{ <vul-end> if ( palette <vul-start> tag ) ; \\\\\\n} <vul-end> Image * image <vul-start> goto NoMemory ; ( void ) memset ( BImgBuff, 0, ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;\n"
  },
  {
    "id": 213,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( 0 == u2_width || 0 == u2_height ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR ; return e_error ; } if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; <vul-start> if ( 0 == ps_dec -> u4_frm_buf_stride ) <vul-end> { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( 0 == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } <vul-start> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <vul-end> <vul-start> || ( u2_height > ps_dec -> u2_create_max_height ) ) <vul-end> { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec ->",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> = u2_height ; } else { <vul-start> == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <vul-end> ; } else <vul-start> if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH <vul-end> ) || ( <vul-start> ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <vul-end> ; } else <vul-start> ; return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = u2_height ; <vul-end> } else { <vul-start> else if ( <vul-end> u2_width > ps_dec <vul-start> ps_dec -> u2_create_max_width || <vul-end> u2_height > ps_dec <vul-start> -> u2_horizontal_size ; <vul-end> } ps_dec ->\n"
  },
  {
    "id": 214,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int StreamTcpPacketStateSynSent ( ThreadVars * tv , Packet * p , StreamTcpThread * stt , TcpSession * ssn , PacketQueue * pq ) { if ( ssn == NULL ) return - 1 ; SCLogDebug ( \"ssn %p: pkt received: %s\" , ssn , PKT_IS_TOCLIENT ( p ) ? \"toclient\" : \"toserver\" ) ; <vul-start> if ( p -> tcph -> th_flags & TH_RST ) { <vul-end> if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ; if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_EQ ( TCP_GET_SEQ ( p ) , ssn -> client . isn ) && SEQ_EQ ( TCP_GET_WINDOW ( p ) , 0 ) && SEQ_EQ ( TCP_GET_ACK ( p ) , ( ssn -> client . isn + 1 ) ) ) { SCLogDebug ( \"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\" ) ; ssn -> server . flags |= STREAMTCP_STREAM_FLAG_RST_RECV ; StreamTcpPacketSetState ( p , ssn , TCP_CLOSED ) ; SCLogDebug ( \"ssn %p: Reset received and state changed to \" \"TCP_CLOSED\" , ssn ) ; } } else { ssn -> client . flags |= STREAMTCP_STREAM_FLAG_RST_RECV ; SCLogDebug ( \"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\" ) ; StreamTcpPacketSetState ( p , ssn , TCP_CLOSED ) ; SCLogDebug ( \"ssn %p: Reset received and state changed to \" \"TCP_CLOSED\" , ssn ) ; } } else if ( p -> tcph -> th_flags & TH_FIN ) { } else if ( ( p -> tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) { if ( ( ssn -> flags &",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ; if (\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if (! StreamTcpPacketIsValid ( p ) ) return - 1 ; if (\n"
  },
  {
    "id": 215,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int pad_basic ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t pad = 0 ; <vul-start> int result = RLC_OK ; <vul-end> bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_DEC : case RSA_VER : case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <vul-start> if ( ! bn_is_zero ( t ) ) { <vul-end> <vul-start> result = RLC_ERR ; <vul-end> } * p_len = 1 ; do { ( * p_len ) ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == 0 && m_len > 0 ) ; <vul-start> if ( pad != RSA_PAD ) { <vul-end> <vul-start> result = RLC_ERR ; <vul-end> } bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ; <vul-start> break ; <vul-end> } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> int result = RLC_ERR ; bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK <vul-end> ; break ; <vul-start> ; if ( <vul-end> bn_is_zero ( t <vul-start> ) ) { <vul-end> * p_len = <vul-start> if ( pad == <vul-end> RSA_PAD ) { <vul-start> { result = RLC_OK <vul-end> ; } bn_mod_2b <vul-start> 8 ) ; }\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> int result = RLC_ERR <vul-end> ; bn_t t <vul-start> ; if ( <vul-end> bn_is_zero ( t <vul-start> ) ) { <vul-end> * p_len = <vul-start> 0 ) ; break ; } } RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : result = RLC_OK ; break ; case RSA_VER : result = RLC_OK ; break ; case RSA_VER_HASH : result = RLC_OK ; break ; default : result = RLC_ERR ; break ; } } RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : result = RLC_OK ; break ; case RSA_DEC : case RSA_VER : result = RLC_OK ; break ; case RSA_VER_HASH : result = RLC_OK ; break ; } } RLC_FINALLY { bn_free ( t ) ; } return result <vul-end> ; }  \n"
  },
  {
    "id": 216,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ; <vul-start> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <vul-end> const char * prop_name = ( const char * ) xIter -> name ; <vul-start> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <vul-end> continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( \"Creation of %s=%s is allowed\" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else { <vul-start> char * path = xml_get_path ( xml ) ; <vul-end> crm_trace ( \"Cannot add new node %s at %s\" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } } <vul-start> } <vul-end> while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> = NULL ; char * path = xml_get_path ( xml ) ; <vul-start> ) == 0 && strstr ( path , \"/\" XML_CIB_TAG_ACLS \"/\" ) == NULL <vul-start> } else { <vul-end> crm_trace ( \"Cannot add new node %s at %s\" <vul-start> ; } } free ( path ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( xIter = xml -> _private ; xIter!= NULL ; xIter = xIter -> next ) { const char * child_name = ( const char * ) xIter -> name ; xmlNode * child = xml_get_child ( xml ) ; if ( child!= NULL ) { child = child -> _private ; } if ( child -> _private!= NULL ) { if ( child -> _private -> _state == _XPATH_DELETING ) { if ( child -> _state == _XPATH_DELETING ) { if ( child -> _state == _XPATH_DELETING ) { if ( child -> _state == _XPATH_DELETING ) { child -> _state = _XPATH_DELETING ; } } } } } else <vul-end> { const char <vul-start> ; if ( child == xml -> _private ) { if ( <vul-start> xml_get_path ( xml ) ; crm_trace ( \"Cannot add new node %s at %s\", crm_element_name ( xml ), child -> _name ) ; if ( xml!= xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( child -> _name ) ; return ; } } } while ( cIter!= NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; if ( child == NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; } } if ( cIter!= NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; } } else { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; if ( child == NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; } } } else { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; if ( cIter!= NULL ) { child = cIter ; cIter = __xml_next ( cIter ) ; } } } else { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; } } } else { xmlNode * child = cIter ; c"
  },
  {
    "id": 217,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static rfbBool rfbSetClientColourMapBGR233 ( rfbClientPtr cl ) { <vul-start> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <vul-end> <vul-start> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <vul-end> <vul-start> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <vul-end> int i , len ; int r , g , b ; if ( cl -> format . bitsPerPixel != 8 ) { rfbErr ( \"%s: client not 8 bits per pixel\\\\n\" , \"rfbSetClientColourMapBGR233\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } scme -> type = rfbSetColourMapEntries ; scme -> firstColour = Swap16IfLE ( 0 ) ; scme -> nColours = Swap16IfLE ( 256 ) ; len = sz_rfbSetColourMapEntriesMsg ; i = 0 ; for ( b = 0 ; b < 4 ; b ++ ) { for ( g = 0 ; g < 8 ; g ++ ) { for ( r = 0 ; r < 8 ; r ++ ) { rgb [ i ++ ] = Swap16IfLE ( r * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( g * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( b * 65535 / 3 ) ; } } } len += 256 * 3 * 2 ; <vul-start> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <vul-end> rfbLogPerror ( \"rfbSetClientColourMapBGR233: write\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } return TRUE ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> cl ) { union { char bytes <vul-end> [ sz_rfbSetColourMapEntriesMsg + <vul-start> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <vul-end> ; uint16_t * <vul-start> ( & buf . bytes <vul-start> cl , buf . bytes\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> cl ) { rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) malloc ( <vul-end> 256 * 3 <vul-start> 3 * 2 ) <vul-end> ; uint16_t * <vul-start> uint16_t * ) malloc ( <vul-end> sz_rfbSetColourMapEntriesMsg ] ) <vul-start> * 2 ; rfbWrite ( cl, buf, len ) < 0 ) { rfbLogPerror ( \"rfbSetClientColourMapBGR233: write\" ) ; rfbCloseClient ( cl ) ; return FALSE ; }\n"
  },
  {
    "id": 218,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning: Cannot allocate memory (Check Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info ,",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> + i ; size_t vstart_off = i ; <vul-start> < 1 || shdr -> sh_size - vstart_off < vdaux <vul-end> ) { sdb_free <vul-start> ; } vstart += vdaux ; vstart_off <vul-start> . vda_next ; vstart_off += aux . vda_next ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> char key [ 64 <vul-end> ] = { <vul-start> out_error ; } st32 vdaux_to_free = vstart - vstart ; char * key = malloc ( sizeof ( char ) ) ; if ( key == NULL ) { sdb_free ( sdb_verdef ) ; goto out_error ; } memcpy ( key, key, sizeof ( key ) ) ; memcpy ( key + vdaux_to_free, vstart, sizeof ( key ) ) ; <vul-start> ; if ( key >= end || memcpy ( key + vdaux_to_free, vstart, sizeof ( key ) ) > end - vstart <vul-end> ) { sdb_free <vul-start> ; if ( key >= end - vdaux <vul-end> ) { sdb_free\n"
  },
  {
    "id": 219,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; <vul-start> if ( current -> active_mm != mm ) <vul-end> <vul-start> goto out ; <vul-end> if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; <vul-start> goto out ; <vul-end> } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> != mm ) { smp_mb ( ) ; <vul-start> goto out ; } <vul-start> ) ) ; smp_mb ( ) ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>!= mm ) { if (! current -> mm ) goto out ; <vul-start> goto out ; } <vul-start> ) ; goto out2 <vul-end> ; } if\n"
  },
  {
    "id": 220,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <vul-start> spin_lock_bh ( & g_cdev . lock ) ; <vul-end> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx ; if ( count > OZ_SSIZE_MAX ) { count = 0 ; goto out ; }\n"
  },
  {
    "id": 221,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , \"%s: couldn\\'t enqueue request: %d\\\\n\" , midi -> out_ep -> name , err ) ; <vul-start> free_ep_req ( midi -> out_ep , req ) ; <vul-end> return err ; } } return 0 ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> err ) ; if ( req -> buf != NULL )\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> err ) ; <vul-end> return err ;\n"
  },
  {
    "id": 222,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void server_real_connect ( SERVER_REC * server , IPADDR * ip , const char * unix_socket ) { GIOChannel * handle ; IPADDR * own_ip = NULL ; const char * errmsg ; char * errmsg2 ; char ipaddr [ MAX_IP_LEN ] ; int port ; g_return_if_fail ( ip != NULL || unix_socket != NULL ) ; signal_emit ( \"server connecting\" , 2 , server , ip ) ; if ( server -> connrec -> no_connect ) return ; if ( ip != NULL ) { own_ip = ip == NULL ? NULL : ( IPADDR_IS_V6 ( ip ) ? server -> connrec -> own_ip6 : server -> connrec -> own_ip4 ) ; port = server -> connrec -> proxy != NULL ? server -> connrec -> proxy_port : server -> connrec -> port ; handle = server -> connrec -> use_ssl ? <vul-start> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <vul-end> server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ; } else { handle = net_connect_unix ( unix_socket ) ; } if ( handle == NULL ) { errmsg = g_strerror ( errno ) ; errmsg2 = NULL ; if ( errno == EADDRNOTAVAIL ) { if ( own_ip != NULL ) { net_ip2host ( own_ip , ipaddr ) ; errmsg2 = g_strconcat ( errmsg , \": \" , ipaddr , NULL ) ; } server -> no_reconnect = TRUE ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> , port , server -> connrec -> address ,\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> use_ssl? net_connect_ip_ssl <vul-end> ( ip,\n"
  },
  {
    "id": 223,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int rc_pick_q_and_bounds_one_pass_cbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; int active_best_quality ; int active_worst_quality = calc_active_worst_quality_one_pass_cbr ( cpi ) ; int q ; <vul-start> if ( frame_is_intra_only ( cm ) ) { <vul-end> active_best_quality = rc -> best_quality ; if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <vul-start> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <vul-end> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <vul-start> ( last_boosted_q * 0.75 ) ) ; <vul-end> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; } else if ( cm -> current_video_frame > 0 ) { double q_adj_factor = 1.0 ; double q_val ; <vul-start> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <vul-end> <vul-start> rc -> kf_boost , <vul-end> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <vul-start> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <vul-end> active_best_quality += vp9_compute_qdelta ( rc , q_val , <vul-start> q_val * q_adj_factor ) ; <vul-end> } } else if ( ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int q ; int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <vul-start> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <vul-start> * 0.75 ) , cm -> bit_depth <vul-start> ; active_best_quality = get_kf_active_quality ( rc , <vul-end> rc -> avg_frame_qindex <vul-start> KEY_FRAME ] , cm -> bit_depth <vul-end> ) ; if <vul-start> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <vul-start> q_val * q_adj_factor , cm -> bit_depth <vul-start> } active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <vul-end> ) ; } <vul-start> ) active_best_quality = rtc_minq <vul-end> [ rc -> <vul-start> else active_best_quality = rtc_minq <vul-end> [ active_worst_quality ] <vul-start> ) active_best_quality = rtc_minq <vul-end> [ rc -> <vul-start> else active_best_quality = rtc_minq <vul-end> [ active_worst_quality ] <vul-start> rc -> this_key_frame_forced && <vul-end> ! ( cm <vul-start> 0 ) ) { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <vul-end> ; } #\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( rc -> is_src_frame_alt_ref && <vul-start> double last_boosted_q = vpx_convert_qindex_to_q <vul-end> ( qindex ) <vul-start> int delta_qindex = vpx_compute_qdelta <vul-end> ( rc, <vul-start> ; active_best_quality = get_active_quality <vul-end> ( rc -> <vul-start> KEY_FRAME ], cm -> bit_depth, <vul-start> } q_val = vpx_convert_qindex_to_q <vul-end> ( active_best_quality ) <vul-start> active_best_quality += get_active_quality <vul-end> ( rc, <vul-start> int last_boosted_q = vpx_convert_qindex_to_q <vul-end> ( rc, <vul-start> int delta_qindex = vpx_compute_qdelta <vul-end> ( rc, <vul-start> ; active_best_quality = get_active_quality <vul-end> ( rc -> <vul-start> KEY_FRAME ], cm -> bit_depth, <vul-start> } q_val = vpx_convert_qindex_to_q <vul-end> ( rc, <vul-start> q_val * q_adj_factor ) ; active_worst_quality = clamp ( active_best_quality, rc -> best_quality, rc -> worst_quality\n"
  },
  {
    "id": 224,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <vul-start> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <vul-end> CORE_MMU_USER_PARAM_SIZE ) ; <vul-start> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <vul-end> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <vul-start> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <vul-end> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> uaddr_t a ; uaddr_t end_addr = 0 ; <vul-start> len , & end_addr <vul-end> ) ) return <vul-start> ( a = ROUNDDOWN ( uaddr , addr_incr ) <vul-end> ; a < <vul-start> ; a < end_addr <vul-end> ; a +=\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> uaddr_t a ; <vul-end> if ( ADD_OVERFLOW <vul-start>, & a ) ) return TEE_ERROR_ACCESS_DENIED ; assert ( len!= CORE_MMU_USER_CODE_SIZE + CORE_MMU_USER_PARAM_SIZE + len <vul-start> len ) ; ) { size_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc, ( void * ) a, NULL, & attr ) ; if ( res!= TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) &&! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_READ ) &&! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; }\n"
  },
  {
    "id": 225,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_slice ( void * _o ) { slice_ty o = ( slice_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } switch ( o -> kind ) { case Slice_kind : result = PyType_GenericNew ( Slice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Slice . lower ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lower , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . upper ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_upper , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . step ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_step , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ExtSlice_kind : result = PyType_GenericNew ( ExtSlice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . ExtSlice . dims , ast2obj_slice ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_dims , value ) ==",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
  },
  {
    "id": 226,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , \"BitmapUpdate: %\" PRIu32 \"\" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) { <vul-start> UINT16 count ; <vul-end> BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ; <vul-start> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <vul-end> sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> count ) { UINT32 <vul-end> count = bitmapUpdate <vul-start> * 2 ; BITMAP_DATA *\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> count ) { UINT32 <vul-end> count ; BITMAP_DATA <vul-start> ; newdata = <vul-end> realloc ( bitmapUpdate\n"
  },
  {
    "id": 227,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 grub_err_t grub_disk_read ( grub_disk_t disk , grub_disk_addr_t sector , grub_off_t offset , grub_size_t size , void * buf ) { char * tmp_buf ; unsigned real_offset ; if ( grub_disk_adjust_range ( disk , & sector , & offset , size ) != GRUB_ERR_NONE ) { grub_error_push ( ) ; grub_dprintf ( \"disk\" , \"Read out of range: sector 0x%llx (%s).\\\\n\" , ( unsigned long long ) sector , grub_errmsg ) ; grub_error_pop ( ) ; return grub_errno ; } real_offset = offset ; tmp_buf = grub_malloc ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) ; if ( ! tmp_buf ) return grub_errno ; while ( size ) { char * data ; grub_disk_addr_t start_sector ; grub_size_t len ; grub_size_t pos ; start_sector = sector & ~ ( GRUB_DISK_CACHE_SIZE - 1 ) ; pos = ( sector - start_sector ) << GRUB_DISK_SECTOR_BITS ; len = ( ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) - pos - real_offset ) ; if ( len > size ) len = size ; data = grub_disk_cache_fetch ( disk -> dev -> id , disk -> id , start_sector ) ; if ( data ) { <vul-start> if ( buf ) <vul-end> <vul-start> grub_memcpy ( buf , data + pos + real_offset , len ) ; <vul-end> grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ; } else { if ( start_sector + GRUB_DISK_CACHE_SIZE > disk -> total_sectors || ( disk -> dev -> read ) ( disk , start_sector , GRUB_DISK_CACHE_SIZE , tmp_buf ) != GRUB_ERR_NONE ) { unsigned num ; char * p ; grub_errno = GRUB_ERR_NONE ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <vul-start> len ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( buf ) { <vul-start> len ) ; }\n"
  },
  {
    "id": 228,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 TpktState CotpConnection_readToTpktBuffer ( CotpConnection * self ) { uint8_t * buffer = self -> readBuffer -> buffer ; int bufferSize = self -> readBuffer -> maxSize ; int bufPos = self -> readBuffer -> size ; assert ( bufferSize > 4 ) ; int readBytes ; if ( bufPos < 4 ) { readBytes = readFromSocket ( self , buffer + bufPos , 4 - bufPos ) ; if ( readBytes < 0 ) goto exit_closed ; if ( DEBUG_COTP ) { if ( readBytes > 0 ) printf ( \"TPKT: read %i bytes from socket\\\\n\" , readBytes ) ; } bufPos += readBytes ; if ( bufPos == 4 ) { if ( ( buffer [ 0 ] == 3 ) && ( buffer [ 1 ] == 0 ) ) { self -> packetSize = ( buffer [ 2 ] * 0x100 ) + buffer [ 3 ] ; if ( DEBUG_COTP ) printf ( \"TPKT: header complete (msg size = %i)\\\\n\" , self -> packetSize ) ; if ( self -> packetSize > bufferSize ) { if ( DEBUG_COTP ) printf ( \"TPKT: packet too large\\\\n\" ) ; goto exit_error ; } } else { if ( DEBUG_COTP ) printf ( \"TPKT: failed to decode TPKT header.\\\\n\" ) ; goto exit_error ; } } else goto exit_waiting ; } <vul-start> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <vul-end> if ( readBytes < 0 ) goto exit_closed ; bufPos += readBytes ; if ( bufPos < self -> packetSize ) goto exit_waiting ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> exit_waiting ; } if ( self -> packetSize <= bufPos ) goto exit_error ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> exit_waiting ; } if ( self -> packetSize < bufPos ) goto exit_closed ;\n"
  },
  {
    "id": 229,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <vul-start> void * dllhandle ; <vul-end> if ( useSystemLib ) Com_Printf ( \"Trying to load \\\\\"%s\\\\\"...\\\\n\" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = \".\" ; Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( \"fs_basepath\" ) ; if ( ! basePath || ! * basePath ) basePath = \".\" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( \"Loading \\\\\"%s\\\\\" failed\\\\n\" , name ) ; } } return dllhandle ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> * dllhandle ; if ( COM_CompareExtension ( name , \".pk3\" ) ) { Com_Printf ( \"Rejecting DLL named \\\\\"%s\\\\\"\" , name ) ; return NULL ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> useSystemLib ) { return Sys_LoadLibrary_0 ( name, useSystemLib, 0 ) <vul-end> ; }  \n"
  },
  {
    "id": 230,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = \"<html>\" ; char framestring [ ] = \"</frameset></html>\" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( \"pixHtmlViewer\" ) ; if ( ! dirin ) return ERROR_INT ( \"dirin not defined\" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( \"dirout not defined\" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( \"rootname not defined\" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( \"thumbwidth too small; using min value\\\\n\" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( \"viewwidth too small; using min value\\\\n\" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , \"mkdir -p %s\" , dirout",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s/%s.html\" , <vul-start> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s/%s-links.html\" , <vul-start> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s_thumb_%03d\" ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s_thumb_%03d\", <vul-start> charbuf ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s/%s-links.html\",\n"
  },
  {
    "id": 231,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; <vul-start> if ( chunk_num > chm -> num_chunks ) return NULL ; <vul-end> if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( !",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> if ( chunk_num >= <vul-end> chm -> num_chunks\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> if ( chunk_num >= <vul-end> chm -> num_chunks\n"
  },
  {
    "id": 232,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Client using the %s protocol\\\\n\" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Realign input buffer\\\\n\" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == ' ' ) { ++ ptr ; } if ( strcmp ( ptr , \"get \" ) && strcmp ( ptr , \"gets \" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <vul-end> cont = el\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> (! el || ( el + c -> rbytes ) >= c -> rbuf + c -> rsize\n"
  },
  {
    "id": 233,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_arg ( PyObject * obj , arg_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty annotation ; string type_comment ; int lineno ; int col_offset ; <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_identifier ( tmp , & arg , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_annotation ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_expr ( tmp , & annotation , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> annotation = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_string ( tmp , & type_comment , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } if ( _PyObject_HasAttrId (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <vul-end> , arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"lineno\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <vul-end> , arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"col_offset\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) <vul-end> ; } *\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_arg, & arg, arena ) < 0 ) { return 1 ; } else <vul-end> { int res <vul-start> goto failed ; <vul-end> Py_CLEAR ( tmp <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_annotation, & annotation, arena ) < 0 ) { return 1 ; } else { annotation = NULL ; } if ( lookup_attr_id ( obj, & PyId_type_comment, & type_comment, arena ) < 0 ) { return 1 ; } else { type_comment = NULL ; } if ( lookup_attr_id ( obj, & PyId_arg, & arg, arena ) < 0 ) { return 1 ; } else { int res ; <vul-start> tmp, & arg <vul-end>, arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_annotation, & annotation, arena ) < 0 ) { return 1 ; } else { int res ; <vul-end> res = obj2ast_expr <vul-start> tmp, & annotation <vul-end>, arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_type_comment, & type_comment, arena ) <vul-end>!= 0 ) <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_type_comment, & type_comment, arena ) < 0 ) { return 1 ; } else { int res ; res = obj2ast_string ( tmp, & type_comment, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj, & PyId_arg, & arg, arena ) < 0 ) { return 1 ; } else { int res ; res = obj2ast_identifier ( tmp, & arg, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj, & PyId_annotation, & annotation, arena ) < 0 ) { return 1 ; } else { int res ; res = obj2ast_expr ( tmp, & annotation, arena ) ; if ( res!= 0 ) goto failed ; Py_CLE"
  },
  {
    "id": 234,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <vul-start> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <vul-end> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <vul-start> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, flags ) ; fq -> flush_pending_idx ^= 1\n"
  },
  {
    "id": 235,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ; <vul-start> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <vul-end> if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> , e -> elems , e ->\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, e -> elems, e ->\n"
  },
  {
    "id": 236,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , \"rb\" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } <vul-start> stat ( options -> in_file , & filestats ) ; <vul-end> plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , \"bplist00\" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , \"wb\" ) ; if ( ! oplist ) { free",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> filestats ) ; if ( filestats . st_size < 8 ) { printf ( \"ERROR: Input file is too small to contain valid plist data.\\\\n\" ) ; return - 1 ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 1 ; } if ( <vul-start> & filestats )!= 0 ) { free ( options ) ; return 1 ; } <vul-end> plist_entire = (\n"
  },
  {
    "id": 237,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; <vul-start> if ( client -> priv -> protocol_timeout ) { <vul-end> g_source_remove ( client -> priv -> protocol_timeout ) ; client -> priv -> protocol_timeout = 0 ; } g_debug ( \"GsmXSMPClient: Initializing client %s\" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeletePropertiesProcMask ; callbacks_ret -> delete_properties . callback = delete_properties_callback ; callbacks_ret -> delete_properties . manager_data = client ;",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> = conn ; <vul-end> g_debug ( \"GsmXSMPClient: Initializing client %s\"\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> = conn ; <vul-end> g_debug ( \"GsmXSMPClient: Initializing client %s\"\n"
  },
  {
    "id": 238,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_pick_intra_sub_8x8_y_mode ( VP9_COMP * cpi , MACROBLOCK * mb , int * rate , int * rate_y , int64_t * distortion , int64_t best_rd ) { int i , j ; const MACROBLOCKD * const xd = & mb -> e_mbd ; MODE_INFO * const mic = xd -> mi [ 0 ] ; <vul-start> const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; <vul-end> <vul-start> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <vul-end> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; int cost = 0 ; int64_t total_distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT t_above [ 4 ] , t_left [ 4 ] ; <vul-start> const int * bmode_costs = mb -> mbmode_cost ; <vul-end> <vul-start> vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ; <vul-end> <vul-start> vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ; <vul-end> for ( idy = 0 ; idy < 2 ; idy += num_4x4_blocks_high ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_blocks_wide ) { <vul-start> MB_PREDICTION_MODE best_mode = DC_PRED ; <vul-end> int r = INT_MAX , ry = INT_MAX ; int64_t d =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = xd -> above_mi <vul-end> ; const MODE_INFO <vul-start> = xd -> left_mi <vul-end> ; const BLOCK_SIZE <vul-start> * bmode_costs = cpi <vul-end> -> mbmode_cost ; <vul-start> -> mbmode_cost ; memcpy <vul-end> ( t_above , <vul-start> ) ) ; memcpy <vul-end> ( t_left , <vul-start> num_4x4_blocks_wide ) { PREDICTION_MODE <vul-end> best_mode = DC_PRED <vul-start> ) { const PREDICTION_MODE <vul-end> A = vp9_above_block_mode <vul-start> ) ; const PREDICTION_MODE <vul-end> L = vp9_left_block_mode <vul-start> ; bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ; } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <vul-end> , & best_mode\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> const MODE_INFO * above_mi = xd -> mi_stride ; const MODE_INFO * left_mi = xd -> left_available ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi. sb_type ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; const int idx, idy ; int cost = 0 ; int64_t total_distortion = 0 ; int64_t best_rd = 0 ; ENTROPY_CONTEXT * t_above [ 4 ], t_left [ 4 ] ; ENTROPY_CONTEXT * t_left [ 4 ] ; const ENTROPY_CONTEXT * t_above_costs [ 4 ] ; int64_t total_costs [ 4 ] ; ENTROPY_CONTEXT * t_left_costs [ 4 ] ; MB_PREDICTION_MODE best_mode = DC_PRED ; int r = INT_MAX, ry = INT_MAX ; int64_t d = INT64_MAX, this_rd = INT64_MAX ; i = idy * 2 + idx ; if ( cpi -> oxcf. pass == 2 <vul-end> ) { const <vul-start> KEY_FRAME ) { <vul-end> for ( A <vul-start> ) ) ; <vul-end> bmode_costs = mb <vul-start> num_4x4_blocks_wide ) { const PREDICTION_MODE <vul-end> best_mode = DC_PRED <vul-start> best_mode = DC_PRED ; for ( j = 1 ; j < num_4x4_blocks_high ; ++ j ) { mic -> bmi [ i + j * 2 ]. as_mode = best_mode ; for ( j = 1 ; j < num_4x4_blocks_wide ; ++ j ) { mic -> bmi [ i + j * 2 ]. as_mode = best_mode ; for ( j = 1 ; j < num_4x4_blocks_wide ; ++ j ) { mic -> bmi [ i + j * 2 ]. as_mode = best_mode ; for ( j = 1 ; j < num_4"
  },
  {
    "id": 239,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Client using the %s protocol\\\\n\" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Realign input buffer\\\\n\" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> } if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , \"get \" , 4 ) && strncmp <vul-end> ( ptr , <vul-start> ptr , \"gets \" , 5 )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> } if ( ( c -> rbytes == 1024 ) && <vul-start> \"get \" ) && ( c -> rbytes == 1024 ) &&\n"
  },
  {
    "id": 240,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , \"itime:0x%\" PRIx64 \", pct:%d, ict:%d\\\\n\" , itime , pct , ict ) ; for ( i = 0 ; i < ict ;",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> int64_t index_pts = <vul-end> av_rescale ( itime <vul-start>, 10000 ) <vul-end> - asf -> <vul-start> hdr. preroll <vul-end> ; if (\n"
  },
  {
    "id": 241,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 void bpf_int_jit_compile ( struct bpf_prog * prog ) { struct bpf_binary_header * header = NULL ; int proglen , oldproglen = 0 ; struct jit_context ctx = { } ; u8 * image = NULL ; int * addrs ; int pass ; int i ; if ( ! bpf_jit_enable ) return ; if ( ! prog || ! prog -> len ) return ; addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( ! addrs ) return ; for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } ctx . cleanup_addr = proglen ; <vul-start> for ( pass = 0 ; pass < 10 ; pass ++ ) { <vul-end> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; if ( proglen <= 0 ) { image = NULL ; if ( header ) bpf_jit_binary_free ( header ) ; goto out ; } if ( image ) { if ( proglen != oldproglen ) { pr_err ( \"bpf_jit: proglen=%d != oldproglen=%d\\\\n\" , proglen , oldproglen ) ; goto out ; } break ; } if ( proglen == oldproglen ) { header = bpf_jit_binary_alloc ( proglen , & image , 1 , jit_fill_hole ) ; if ( ! header ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) bpf_jit_dump ( prog -> len , proglen , 0 ,",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> pass < 10 || image\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> = proglen ; ctx. jit_func = NULL ;\n"
  },
  {
    "id": 242,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ; const unsigned char * old_name ; struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ; <vul-start> if ( source == target ) <vul-end> return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename && ! old_dir -> i_op -> rename2 ) return - EPERM ; if ( flags && ! old_dir -> i_op -> rename2 ) return - EINVAL ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error )",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <vul-end> ) return 0\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; if (! is_dir &&\n"
  },
  {
    "id": 243,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; <vul-start> bool tsonly ; <vul-end> if ( ! sk ) return ; tsonly = sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && <vul-start> sk -> sk_type == SOCK_STREAM ) <vul-end> skb = tcp_get_timestamping_opt_stats ( sk ) ; <vul-start> else <vul-end> # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ; } else { skb = skb_clone ( orig_skb , GFP_ATOMIC ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; <vul-start> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <vul-end> }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; bool tsonly , opt_stats = false <vul-start> == SOCK_STREAM ) { <vul-start> sk ) ; opt_stats = true ; } <vul-start> sk , tstype , opt_stats\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; bool tsonly ; int err <vul-start> == SOCK_STREAM ) { err = TCP_SKB_CB ( skb ) -> err ; if ( err ) goto out ; <vul-start> sk ) ; } else { err = TCP_SKB_CB ( skb ) -> err ; if ( err ) goto out ; } <vul-start> ( ) ; out :\n"
  },
  {
    "id": 244,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = \"PredictorEncodeTile\" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"PredictorEncodeTile\" , \"%s\" , \"(cc0%rowsize)!=0\" ) ; <vul-start> return 0 ; <vul-end> } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> \"(cc0%rowsize)!=0\" ) ; _TIFFfree ( working_copy ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"(cc0%rowsize)!=0\" ) ; _TIFFfree ( working_copy ) ;\n"
  },
  {
    "id": 245,
    "question": "CWE-704 Code Input Vulnerable Code Is: CWE-704 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , \"params = \" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , \"\\\\n\" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( \"value\" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , \"arguments\" , sizeof ( \"arguments\" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args",
    "golden_answers": [
      "CWE-704 Fixed Code Lines are: <vul-start> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY\n"
    ],
    "generated_answer": "CWE-704 Fixed Code Lines are: <vul-start> { if ( Z_TYPE_PP <vul-end> ( test_ptr )\n"
  },
  {
    "id": 246,
    "question": "CWE-436 Code Input Vulnerable Code Is: CWE-436 bgp_attr_parse_ret_t bgp_attr_parse ( struct peer * peer , struct attr * attr , bgp_size_t size , struct bgp_nlri * mp_update , struct bgp_nlri * mp_withdraw ) { bgp_attr_parse_ret_t ret ; uint8_t flag = 0 ; uint8_t type = 0 ; bgp_size_t length ; uint8_t * startp , * endp ; uint8_t * attr_endp ; uint8_t seen [ BGP_ATTR_BITMAP_SIZE ] ; struct aspath * as4_path = NULL ; as_t as4_aggregator = 0 ; struct in_addr as4_aggregator_addr = { . s_addr = 0 } ; memset ( seen , 0 , BGP_ATTR_BITMAP_SIZE ) ; endp = BGP_INPUT_PNT ( peer ) + size ; while ( BGP_INPUT_PNT ( peer ) < endp ) { if ( endp - BGP_INPUT_PNT ( peer ) < BGP_ATTR_MIN_LEN ) { flog_warn ( EC_BGP_ATTRIBUTE_TOO_SMALL , \"%s: error BGP attribute length %lu is smaller than min len\" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; return BGP_ATTR_PARSE_ERROR ; } startp = BGP_INPUT_PNT ( peer ) ; flag = 0xF0 & stream_getc ( BGP_INPUT ( peer ) ) ; type = stream_getc ( BGP_INPUT ( peer ) ) ; if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) && ( ( endp - startp ) < ( BGP_ATTR_MIN_LEN + 1 ) ) ) { flog_warn ( EC_BGP_EXT_ATTRIBUTE_TOO_SMALL , \"%s: Extended length set, but just %lu bytes of attr header\" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send (",
    "golden_answers": [
      "CWE-436 Fixed Code Lines are: <vul-start> ; # if ENABLE_BGP_VNC_ATTR <vul-end> case BGP_ATTR_VNC :\n"
    ],
    "generated_answer": "CWE-436 Fixed Code Lines are: <vul-start> ; break ; case BGP_ATTR_VNC_ATTR : <vul-end> case BGP_ATTR_ENCAP :\n"
  },
  {
    "id": 247,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) { <vul-start> char buffer [ 80 ] ; <vul-end> int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , \"Error parsing header; not a YUV2MPEG2 file?\\\\n\" ) ; return - 1 ; } buffer [ i ] = '\\\\0' ; if ( memcmp ( buffer , \"YUV4MPEG\" , 8 ) ) { fprintf ( stderr , \"Incomplete magic for YUV4MPEG file.\\\\n\" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , \"Incorrect YUV input file version; YUV4MPEG2 required.\\\\n\" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , \"Error parsing YUV4MPEG2 header.\\\\n\" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , \"Warning: Input video interlacing format unknown; \" \"assuming progressive scan.\\\\n\" ) ; } else if ( _y4m -> interlace != 'p' ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> [ 80 ] = { 0 } <vul-start> ; _y4m -> bps <vul-end> = 12 ; <vul-start> = 12 ; _y4m -> bit_depth = 8 ; <vul-start> -> chroma_type , \"420p10\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 420p10 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"420p12\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 420p12 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <vul-start> ; _y4m -> bps <vul-end> = 16 ; <vul-start> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , \"422p10\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 422p10 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"422p12\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 422p12 to 420jpeg\\\\n\" ) ; return - 1 <vul-start> ; _y4m -> bps <vul-end> = 24 ; <vul-start> -> chroma_type , \"444p10\" <vul-end> ) == 0 <vul-start> = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <vul-start> only_420 ) { <vul-end> fprintf ( stderr <vul-start> ( stderr , \"Unsupported conversion from 444p10 to 420jpeg\\\\n\" <vul-end> ) ; return <vul-start> 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"444p12\" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 444p12 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"444alpha\" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , \"mono\" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , \"Unknown chroma sampling type: %s\\\\n\" , _y4m -> chroma_type ) ; return - 1 ; } <vul-start> dst_c_dec_v ) ; if ( _y4m -> bit_depth == 8 ) <vul-start> dst_buf_sz ) ; else _y4m -> dst_buf <vul-end> = ( unsigned <vul-start> ) malloc ( 2 * _y4m -> dst_buf_sz ) ; if ( <vul-start> _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> only_420 ) { return y4m_input_open_ext ( _y4m, _fin, _skip, _nskip, only_420 <vul-end> ) ; } <vul-start> ) ; } <vul-end> }    \n"
  },
  {
    "id": 248,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <vul-start> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <vul-end> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_negative ( key <vul-end> ) ) return\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_negative ( key <vul-end> ) ) return\n"
  },
  {
    "id": 249,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <vul-start> for",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> plane < 4 <vul-start> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; if ( inpic -> data [ plane ] && plane < 4 ) { h = plane == 0? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h, kerndeint -> vsub ) ; bwidth = kerndeint -> tmp_bwidth [ plane ] ; srcp = srcp_saved = inpic -> data [ plane ] ; src_linesize = inpic -> linesize [ plane ] ; psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; srcp4p = srcp + ( 1 - order ) * src_linesize ; srcp4n = srcp + ( 3 - order ) * src_linesize ; dstp = dstp_saved + ( 1 - order ) * dst_linesize, srcp_saved + ( 2 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( 1 - order ) * dst_linesize, srcp_saved + ( 3 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( 2 + order ) * dst_linesize, srcp_saved + ( 3 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( h - 4 + order ) * dst_linesize, srcp_saved + ( h - 3 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( h - 4 + order ) * dst_linesize, srcp_saved + ( h - 3 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( h - 4 + order ) * dst_linesize, srcp_saved + ( h - 3 - order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( h - 4 + order ) * dst_linesize, srcp_saved + ( h - 3 + order ) * src_linesize, bwidth ) ; memcpy ( dstp + ( h - 4 + order ) * dst_linesize, srcp_saved + ( h - 3 + order ) * src_linesize, srcp_saved + ( h - 3 - order ) * src_linesize, bwidth ) ; memcpy ( dst"
  },
  {
    "id": 250,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * <vul-start> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <vul-end> { int totlen ; uint32_t t ; <vul-start> if ( p [ 0 ] & 0x80 ) <vul-end> totlen = 4 ; <vul-start> else <vul-end> totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ; <vul-start> if ( ep < p + totlen ) { <vul-end> ND_PRINT ( ( ndo , \"[|attr]\" ) ) ; <vul-start> return ep + 1 ; <vul-end> <vul-start> } <vul-end> ND_PRINT ( ( ndo , \"(\" ) ) ; t = EXTRACT_16BITS ( & p [ 0 ] ) & 0x7fff ; ND_PRINT ( ( ndo , \"type=#%d \" , t ) ) ; if ( p [ 0 ] & 0x80 ) { ND_PRINT ( ( ndo , \"value=\" ) ) ; t = p [ 2 ] ; <vul-start> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <vul-end> } else { <vul-start> ND_PRINT ( ( ndo , \"len=%d value=\" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <vul-end> <vul-start> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <vul-end> } ND_PRINT ( ( ndo , \")\" ) ) ; <vul-start> return p + totlen ; <vul-end> <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> const u_char * ep2 <vul-end> ) { int <vul-start> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-start> ] ) ; } if ( ep2 <vul-end> < p + <vul-start> ) ; return ep2 <vul-end> + 1 ; <vul-start> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <vul-start> 2 ] ; if ( ! <vul-start> , 2 ) ) { ND_PRINT ( ( ndo , \")\" ) ) ; goto trunc ; } <vul-end> } else { <vul-start> , \"len=%d value=\" , totlen - 4 ) ) ; if ( ! <vul-end> rawprint ( ndo <vul-start> 4 ] , totlen - 4 ) ) { <vul-end> ND_PRINT ( ( <vul-start> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , \")\" ) ) ; <vul-start> + totlen ; trunc : return NULL ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> const u_char * ep0, const u_char * ep1 <vul-end> ) { int <vul-start> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> ] & 0x80 ) { ND_TCHECK_16BITS ( & p [ 4 ] ) ; <vul-end> totlen = 4 <vul-start> = 4 ; } else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-end> totlen = 4 <vul-start> ] ) ; } if ( ep0 <vul-end> < p + <vul-start> ) ; return ep0 <vul-end> + 1 ; <vul-start> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <vul-start> 2 ] ; ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-start>, \"len=%d value=\", totlen ) ) ; ND_TCHECK_16BITS ( & p [ 4 ] ) ; ND_TCHECK_16BITS ( & p [ 2 ] ) ; } else { ND_TCHECK_16BITS ( & p [ 4 ] ) ; ND_TCHECK_16BITS ( & p [ 2 ] ) ; } ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-start> ) ) ; if ( ep0 < p + totlen ) { ND_PRINT ( ( ndo, \"[|attr]\" ) ) ; return ep0 <vul-end> + totlen ; <vul-start> totlen ; } ND_PRINT ( ( ndo, \")\" ) ) ; return NULL ; }\n"
  },
  {
    "id": 251,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <vul-start> inl = i2d ( data , NULL ) ; <vul-end> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup (",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> err ; } if ( strlen ( type )!= signature -> length ) { ASN1err ( ASN1_F_ASN1_VERIFY, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; }\n"
  },
  {
    "id": 252,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , \"overread %d, state:%X next:%d index:%d o_index:%d\\\\n\" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , \"%X %X %X %X\\\\n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <vul-start> if ( ! new_buffer ) <vul-end> <vul-start> return AVERROR ( ENOMEM ) ; <vul-end> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ! new_buffer ) { pc -> index = 0 ; <vul-start> ENOMEM ) ; } <vul-start> ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; <vul-start> ENOMEM ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>! new_buffer ) { * buf_size = 0 ; <vul-start> ENOMEM ) ; }\n"
  },
  {
    "id": 253,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <vul-end> ; aux = <vul-start> if ( ! aux -> alu_state <vul-end> ) continue ; <vul-start> ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <vul-end> ; new_prog = <vul-start> } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <vul-end> aux = & <vul-start> ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <vul-start> aux ) ) { verbose ( env , \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } <vul-end> map_ptr = BPF_MAP_PTR <vul-start> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <vul-end> ( map_ptr , <vul-start> ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <vul-end> new_prog = bpf_patch_insn_data <vul-start> continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , \"bpf verifier is misconfigured\\\\n\" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> } if ( is_jump_insn ( insn ) ) { verbose ( env, \"bpf verifier is misconfigured\\\\n\" ) ; return - EINVAL ; } if ( <vul-start> aux ) ) { <vul-start> goto patch_call_imm ; } <vul-start> map_state ) ; if ( ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr, insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env, \"bpf verifier is misconfigured\\\\n\" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env, i + delta, insn_buf, cnt ) ; if (! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; } if ( <vul-start> BPF_FUNC_map_lookup_elem && ops -> <vul-end> map_gen_lookup ) { <vul-start> = ops -> <vul-end> map_gen_lookup ( map_ptr <vul-start> continue ; } <vul-end> if (! <vul-start>! __same_type ( <vul-end> ( void * <vul-start> ) ) continue <vul-end> ; if ( <vul-start> ; if ( bpf_map_ptr_poisoned ( aux ) ) { verbose ( env, \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; if ( <vul-start>! bpf_map_ptr_unpriv ( map_ptr ) ) { verbose ( env, \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } if ( <vul-start> aux ) ) { verbose ( env, \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } if ( <vul-start> aux ) ) { verbose ( env, \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } if ( ops -> map_gen_lookup ( map_ptr, insn_buf, cnt ) ) { verbose ( env, \"tail_call abusing map_ptr\\\\n\" ) ; return - E"
  },
  {
    "id": 254,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <vul-start> if ( skb_headroom",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb -> mac_header <vul-end> < ( tnl_hlen\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb_mac_header <vul-end> ( skb ) <vul-start> ( skb ) + frag_hdr_sz <= skb -> head + skb -> head + unfrag_hdr_sz ) { struct frag_hdr * fptr ; fptr = ( struct frag_hdr * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset\n"
  },
  {
    "id": 255,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int tap_if_up ( const char * devname , const bt_bdaddr_t * addr ) { struct ifreq ifr ; int sk , err ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; <vul-start> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <vul-end> if ( err < 0 ) { BTIF_TRACE_ERROR ( \"Could not get network hardware for interface:%s, errno:%s\" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; memcpy ( ifr . ifr_hwaddr . sa_data , addr -> address , 6 ) ; if ( ifr . ifr_hwaddr . sa_data [ 0 ] & 0x01 ) { BTIF_TRACE_WARNING ( \"Not a unicast MAC address, force multicast bit flipping\" ) ; ifr . ifr_hwaddr . sa_data [ 0 ] &= ~ 0x01 ; } <vul-start> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <vul-end> if ( err < 0 ) { BTIF_TRACE_ERROR ( \"Could not set bt address for interface:%s, errno:%s\" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE -",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start> , & ifr ) <vul-start> } err = TEMP_FAILURE_RETRY ( <vul-start> ) & ifr ) <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start> & ifr ) )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start>, & ifr ) <vul-start> } err = TEMP_FAILURE_RETRY ( <vul-start> ) & ifr )\n"
  },
  {
    "id": 256,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void parse_hid_report_descriptor ( struct gtco * device , char * report , int length ) { struct device * ddev = & device -> intf -> dev ; int x , i = 0 ; __u8 prefix ; __u8 size ; __u8 tag ; __u8 type ; __u8 data = 0 ; __u16 data16 = 0 ; __u32 data32 = 0 ; int inputnum = 0 ; __u32 usage = 0 ; __u32 globalval [ TAG_GLOB_MAX ] ; __u32 oldval [ TAG_GLOB_MAX ] ; char maintype = 'x' ; char globtype [ 12 ] ; int indent = 0 ; char indentstr [ 10 ] = \"\" ; dev_dbg ( ddev , \"======>>>>>>PARSE<<<<<<======\\\\n\" ) ; while ( i < length ) { <vul-start> prefix = report [ i ] ; <vul-end> i ++ ; size = PREF_SIZE ( prefix ) ; switch ( size ) { case 1 : data = report [ i ] ; break ; case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ; break ; <vul-start> case 3 : <vul-end> size = 4 ; data32 = get_unaligned_le32 ( & report [ i ] ) ; break ; } i += size ; tag = PREF_TAG ( prefix ) ; type = PREF_TYPE ( prefix ) ; switch ( type ) { case TYPE_MAIN : strcpy ( globtype , \"\" ) ; switch ( tag ) { case TAG_MAIN_INPUT : maintype = 'I' ; if ( data == 2 ) strcpy ( globtype , \"Variable\" ) ; else if ( data == 3 ) strcpy (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , \"Not enough data (need %d, have %d)\\\\n\" , i + size , length ) ; break ; } <vul-end> switch ( size <vul-start> break ; case 4 : <vul-end> data32 = get_unaligned_le32\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i >= length ) break ; <vul-start> case 3 : if ( i >= length ) break ;\n"
  },
  {
    "id": 257,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <vul-start> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <vul-end> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , \"Composite Document File V2 Document\" ) == - 1 ) return - 1 ; if ( file_printf ( ms , \", %s Endian\" , si . si_byte_order == 0xfffe ? \"Little\" : \"Big\" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , \", Os: Windows, Version %d.%d\" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , \", Os: MacOS, Version %d.%d\" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , \", Os %d, Version: %d.%d\" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <vul-start> str = cdf_clsid_to_mime ( clsid",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> sst , const cdf_directory_t * root_storage <vul-end> ) { cdf_summary_info_header_t <vul-start> break ; } if ( root_storage ) { <vul-start> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <vul-end> , clsid2desc ) <vul-start> - 2 ; } <vul-start> , count , root_storage <vul-end> ) ; free\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> sst, const cdf_directory_t * root_storage, const <vul-start> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <vul-end>, clsid2desc ) <vul-start>, count, root_storage -> d_storage_uuid <vul-end> ) ; free\n"
  },
  {
    "id": 258,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; <vul-start> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <vul-end> atomic_inc ( & key -> user -> nikeys ) ; <vul-start> key -> reject_error = - error ; <vul-end> smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; if ( keyring && link_ret == 0 ) __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key -> state == KEY_IS_UNINSTANTIATED <vul-end> ) { atomic_inc <vul-start> nikeys ) ; mark_key_instantiated ( key , - error <vul-end> ) ; now\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> nikeys ) ; smp_wmb ( ) ; <vul-start> = - error <vul-end> ; now =\n"
  },
  {
    "id": 259,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t * * info , size_t * count ) { <vul-start> size_t i , maxcount ; <vul-end> const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ; const cdf_section_declaration_t * sd = CAST ( const cdf_section_declaration_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + CDF_SECTION_DECLARATION_OFFSET ) ) ; if ( cdf_check_stream_offset ( sst , h , si , sizeof ( * si ) , __LINE__ ) == - 1 || cdf_check_stream_offset ( sst , h , sd , sizeof ( * sd ) , __LINE__ ) == - 1 ) return - 1 ; ssi -> si_byte_order = CDF_TOLE2 ( si -> si_byte_order ) ; ssi -> si_os_version = CDF_TOLE2 ( si -> si_os_version ) ; ssi -> si_os = CDF_TOLE2 ( si -> si_os ) ; ssi -> si_class = si -> si_class ; cdf_swap_class ( & ssi -> si_class ) ; <vul-start> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <vul-end> * count = 0 ; maxcount = 0 ; * info = NULL ; <vul-start> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <vul-end> if ( i >= CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Unpack summary info loop limit\" ) ) ; errno = EFTYPE ; return - 1 ; } if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ) { size_t <vul-end> maxcount ; const <vul-start> -> si_count = CDF_TOLE4 <vul-end> ( si -> <vul-start> = NULL ; if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <vul-end> sd -> sd_offset <vul-start> - 1 ) <vul-end> return - 1 <vul-start> - 1 ; <vul-end> return 0 ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> i, maxcount, count_copy <vul-start> si -> si_count ) ; count_copy = CDF_TOLE4 ( si -> si_count <vul-start> ; i < count_copy <vul-end> ; i ++ <vul-start> - 1 ) <vul-end> return - 1 <vul-start> - 1 ; <vul-end> } return 0\n"
  },
  {
    "id": 260,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int nfs4_do_close ( struct path * path , struct nfs4_state * state , int wait ) { struct nfs_server * server = NFS_SERVER ( state -> inode ) ; struct nfs4_closedata * calldata ; struct nfs4_state_owner * sp = state -> owner ; struct rpc_task * task ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_CLOSE ] , . rpc_cred = state -> owner -> so_cred , } ; struct rpc_task_setup task_setup_data = { . rpc_client = server -> client , . rpc_message = & msg , . callback_ops = & nfs4_close_ops , . workqueue = nfsiod_workqueue , . flags = RPC_TASK_ASYNC , } ; int status = - ENOMEM ; calldata = kmalloc ( sizeof ( * calldata ) , GFP_KERNEL ) ; if ( calldata == NULL ) goto out ; calldata -> inode = state -> inode ; calldata -> state = state ; calldata -> arg . fh = NFS_FH ( state -> inode ) ; calldata -> arg . stateid = & state -> open_stateid ; calldata -> arg . seqid = nfs_alloc_seqid ( & state -> owner -> so_seqid ) ; if ( calldata -> arg . seqid == NULL ) goto out_free_calldata ; <vul-start> calldata -> arg . open_flags = 0 ; <vul-end> calldata -> arg . bitmask = server -> attr_bitmask ; calldata -> res . fattr = & calldata -> fattr ; calldata -> res . seqid = calldata -> arg . seqid ; calldata -> res . server = server ; calldata -> path . mnt = mntget ( path ->",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> = 0 ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> arg. fattr = & calldata -> fattr ; calldata -> arg.\n"
  },
  {
    "id": 261,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( \"Usage: %s mj2filename output_location\\\\n\" , argv [ 0 ] ) ; printf ( \"Example: %s foreman.mj2 output/foreman\\\\n\" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , \"rb\" ) ; if ( ! file ) { fprintf ( stderr , \"failed to open %s for reading\\\\n\" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> file ) ; { int num = snprintf <vul-end> ( outfilename , <vul-start> ( outfilename , sizeof ( outfilename ) , <vul-start> 2 ] , snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , \"maximum length of output prefix exceeded\\\\n\" ) ; free ( frame_codestream ) ; return 1 ; } } <vul-end> outfile = fopen <vul-start> \"failed to open %s for writing\\\\n\" , outfilename ) ; free ( frame_codestream\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, \"%s_%05d.j2k\", mj2_get_key ( argv [ 2 ] ) <vul-end>, snum ) <vul-start> ( stderr, \"failed to open %s for writing\\\\n\" <vul-end>, outfilename )\n"
  },
  {
    "id": 262,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_setup_in_frame_q_adj ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; struct segmentation * const seg = & cm -> seg ; <vul-start> vp9_clear_system_state ( ) ; <vul-end> if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { int segment ; <vul-start> vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; <vul-end> vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; for ( segment = 1 ; segment < 2 ; segment ++ ) { const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , <vul-start> in_frame_q_adj_ratio [ segment ] ) ; <vul-end> vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; vp9_set_segdata ( seg , segment , SEG_LVL_ALT_Q , qindex_delta ) ; } } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; vpx_clear_system_state <vul-end> ( ) ; <vul-start> int segment ; const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <vul-end> qindex_delta = vp9_compute_qdelta_by_rate <vul-start> -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <vul-end> vp9_enable_segfeature ( seg <vul-start> } } } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; int segment ; memset ( cpi -> segmentation_map, 0, cm -> mi_rows * cm -> mi_cols ) ; memset ( cpi -> complexity_map, 0, cm -> mi_rows * cm -> mi_cols ) ; vp9_disable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; seg -> segfeature = 0, SEG_LVL_ALT_Q ) ; seg -> segdata = 0, SEG_LVL_ALT_Q, qindex_delta ) ; seg -> segfeature = 1, SEG_LVL_ALT_Q ) ; seg -> abs_delta = SEGMENT_DELTADATA ; seg -> base_qindex = VPX_DEFAULT_QINDEX ; seg -> segfeature = 0, SEG_LVL_ALT_Q ) ; seg -> segdata = VPX_DEFAULT_QDATA ; seg -> segfeature_flags = 0 ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags = VPX_DEFAULT_SEGFEATURE ; seg -> segfeature_flags"
  },
  {
    "id": 263,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { <vul-start> if ( l_strnstart ( \"MSG\" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP MSG\" ) ) ; <vul-start> else if ( l_strnstart ( \"RPY \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP RPY\" ) ) ; <vul-start> else if ( l_strnstart ( \"ERR \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP ERR\" ) ) ; <vul-start> else if ( l_strnstart ( \"ANS \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP ANS\" ) ) ; <vul-start> else if ( l_strnstart ( \"NUL \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP NUL\" ) ) ; <vul-start> else if ( l_strnstart ( \"SEQ \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP SEQ\" ) ) ; <vul-start> else if ( l_strnstart ( \"END\" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP END\" ) ) ; else ND_PRINT ( ( ndo , \" BEEP (payload or undecoded)\" ) ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> { if ( l_strnstart <vul-end> ( \"MSG\", <vul-start> else if ( l_strnstart <vul-end> ( \"RPY \", <vul-start> else if ( l_strnstart <vul-end> ( \"ERR \", <vul-start> else if ( l_strnstart <vul-end> ( \"ANS \", <vul-start> else if ( l_strnstart <vul-end> ( \"NUL \", <vul-start> else if ( l_strnstart <vul-end> ( \"SEQ \", <vul-start> else if ( l_strnstart <vul-end> ( \"END\",\n"
  },
  {
    "id": 264,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , \"rb\" ) ; if ( ! f ) { fprintf ( stderr , \"Failed to open %s for reading !!\\\\n\" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } <vul-start> subsampling_dx = parameters -> subsampling_dx ; <vul-end> subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) {",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> OPJ_CLRSPS_SRGB ; } if ( numcomps < 0 || numcomps >= 4 ) { fclose ( f ) ; return NULL ; }\n"
  },
  {
    "id": 265,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( \"mod\" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; <vul-start> Module_type = make_type ( \"Module\" , mod_type , Module_fields , 1 ) ; <vul-end> <vul-start> if ( ! Module_type ) return 0 ; <vul-end> <vul-start> Interactive_type = make_type ( \"Interactive\" , mod_type , Interactive_fields , <vul-end> 1 ) ; <vul-start> if ( ! Interactive_type ) return 0 ; <vul-end> <vul-start> Expression_type = make_type ( \"Expression\" , mod_type , Expression_fields , 1 ) ; <vul-end> if ( ! Expression_type ) return 0 ; Suite_type = make_type ( \"Suite\" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( \"stmt\" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( \"FunctionDef\" , stmt_type , FunctionDef_fields , <vul-start> 5 ) ; <vul-end> <vul-start> if ( ! FunctionDef_type ) return 0 ; <vul-end> AsyncFunctionDef_type = make_type ( \"AsyncFunctionDef\" , stmt_type , <vul-start> AsyncFunctionDef_fields , 5 ) ; <vul-end> <vul-start> if ( ! AsyncFunctionDef_type ) return 0 ; <vul-end> <vul-start> ClassDef_type = make_type ( \"ClassDef\" , stmt_type , ClassDef_fields , 5 ) ; <vul-end> <vul-start> if (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( \"Interactive\" , mod_type , Interactive_fields , <vul-start> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( \"Expression\" <vul-end> , mod_type , <vul-start> , mod_type , Expression_fields , <vul-end> 1 ) ; <vul-start> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( \"FunctionType\" <vul-end> , mod_type , <vul-start> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <vul-end> ) return 0 <vul-start> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( \"AsyncFunctionDef\" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( \"ClassDef\" , stmt_type , ClassDef_fields , <vul-start> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( \"Return\" <vul-end> , stmt_type , <vul-start> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( \"Delete\" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( \"Assign\" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( \"AugAssign\" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( \"AnnAssign\" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( \"For\" , stmt_type , For_fields <vul-end> , 5 ) <vul-start> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( \"AsyncFor\" <vul-end> , stmt_type , <vul-start> , stmt_type , AsyncFor_fields <vul-end> , 5 ) <vul-start> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( \"While\" <vul-end> , stmt_type , <vul-start> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( \"If\" <vul-end> , stmt_type , <vul-start> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( \"With\" <vul-end> , stmt_type , <vul-start> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( \"AsyncWith\" <vul-end> , stmt_type , <vul-start> , stmt_type , AsyncWith_fields , 3 <vul-end> ) ; if <vul-start> , arg_fields , 3 <vul-end> ) ; if <vul-start> return 0 ; type_ignore_type = make_type ( \"type_ignore\" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( \"TypeIgnore\" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, Module_fields, 0 <vul-end> ) ; if <vul-start>! Module_type ) { return 0 ; } <vul-end> Interactive_type = make_type <vul-start>, Interactive_fields, 0 <vul-end> ) ; if <vul-start>! Interactive_type ) { return 0 ; } <vul-end> Expression_type = make_type <vul-start>, Expression_fields, 0 <vul-end> ) ; if <vul-start>! FunctionDef_type ) { <vul-start> return 0 ; } <vul-start>, AsyncFunctionDef_fields, 0 <vul-end> ) ; if <vul-start>! AsyncFunctionDef_type ) { <vul-start> return 0 ; } <vul-start>, ClassDef_fields, 0 <vul-end> ) ; if <vul-start>! ClassDef_type ) { return 0 ; } <vul-start> return 0 ; <vul-end> Return_type = make_type <vul-start>, Return_fields, 0 <vul-end> ) ; if <vul-start>! Return_type ) { return 0 ; } <vul-end> Suite_type = make_type <vul-start>, Delete_fields, 0 <vul-end> ) ; if <vul-start>, Suite_fields, 0 <vul-end> ) ; if <vul-start>, FunctionDef_fields, 0 <vul-end> ) ; if <vul-start>, AsyncFunctionDef_fields, 0 <vul-end> ) ; if <vul-start>, AsyncFunctionDef_fields, 0 <vul-end> ) ; if <vul-start>, ClassDef_fields, 0 <vul-end> ) ; if <vul-start>! ClassDef_type ) { return 0 ; } <vul-end> FunctionDef_type = make_type <vul-start>, Delete_fields, 0 <vul-end> ) ; if <vul-start>, ClassDef_fields, 0 <vul-end> ) ; if <vul-start>! ClassDef_type ) { return 0 ; } <vul-end> Return_type = make_type <vul-start>, Return_fields, 0 <vul-end> ) ; if <vul-start>! Return_type ) { return 0 ; } <vul-end> Expression_type = make_type <vul-start>, Delete_fields, 0 <vul-end> ) ; if <vul-start> return 0 ; Suite_type = make_type ( \"Suite\", mod_type, Suite_fields, 1 ) ; if (! Suite_type ) return 0 ; FunctionDef_type = make_type ( \"FunctionDef\", stmt_type, FunctionDef_fields, 1 ) ; if (! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( \"AsyncFunction"
  },
  {
    "id": 266,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <vul-start> var = vp8_variance16x16 <vul-end> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; var = vpx_variance16x16 <vul-end> ( * (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; var = vpx_variance16x16 <vul-end> ( * (\n"
  },
  {
    "id": 267,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , \"ptr\" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , \"byte\" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"word\" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"dword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"qword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"oword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <vul-start> = temp ; } <vul-start> += temp ; if ( reg_index < 2 ) { <vul-start> = X86R_UNDEFINED ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> X86R_UNDEFINED ) { if ( reg_index >= 64 ) { return pos ; } <vul-start> = temp ; <vul-end> } else { <vul-start> -> offset += ( st64 ) <vul-start> -> regs [ reg_index <vul-end> ] = X86R_UNDEFINED <vul-start> X86R_UNDEFINED ) { if ( reg_index >= 64 ) { return pos ; } <vul-start> -> scale [ reg_index <vul-end> ] = temp <vul-start> temp ; ++ reg_index ; } else { op -> regs [ reg_index ] = X86R_UNDEFINED ; } <vul-end> } else { <vul-start> -> offset += ( st64 ) <vul-start> -> regs [ reg_index <vul-end> ] = X86R_UNDEFINED\n"
  },
  {
    "id": 268,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , \"%s.%llu\" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( \"%s unable to rename \\'%s\\' to \\'%s\\': %s\" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; } <vul-start> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <vul-end> if ( logfile_fd == INVALID_FD ) { LOG_ERROR ( \"%s unable to open \\'%s\\': %s\" , __func__ , log_path , strerror ( errno ) ) ; is_logging = false ; return ; } <vul-start> write ( logfile_fd , \"btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea\" , 16 ) ; <vul-end> } else { if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> } logfile_fd = TEMP_FAILURE_RETRY ( <vul-start> S_IWGRP | S_IROTH ) <vul-start> return ; } TEMP_FAILURE_RETRY ( <vul-start> \"btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea\" , 16 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> O_CREAT | O_CREAT | O_NOFOLLOW | O_NOFOLLOW <vul-start> return ; } TEMP_FAILURE_RETRY ( <vul-start>, 16 ) )\n"
  },
  {
    "id": 269,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <vul-start> char added ; <vul-end> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <vul-start> pair -> added = 0 ; <vul-end> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair ->",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> * key ; <vul-end> } * pair <vul-start> it ) ; <vul-end> for ( it\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> * key ; <vul-end> } * pair <vul-start> it ) ; <vul-end> for ( it\n"
  },
  {
    "id": 270,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } if ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { context -> pass ++ ; context -> curY = i -> posY + 4 ;\n"
  },
  {
    "id": 271,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <vul-start> value [ n ] >= min && value [ n ] <= max && <vul-end> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <vul-start> && field -> usage [",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ] <= max && value [ n ] - min < field -> maxusage <vul-start> && field -> value [ n ] - min < field -> maxusage && field -> <vul-start> <= max && value [ n ] - min < field -> maxusage &&\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> HID_MAIN_ITEM_VARIABLE ) && ( <vul-start> ] <= max ) && ( field -> flags & HID_MAIN_ITEM_INCOMPLETE ) <vul-start> <= max && ( field -> flags & HID_MAIN_ITEM_INCOMPLETE ) && <vul-start> <= max && ( field -> flags & HID_MAIN_ITEM_INCOMPLETE ) &&\n"
  },
  {
    "id": 272,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , \"Failed to get gpio io resource.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , \"Failed to get gpio IRQ.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <vul-end> & amd_pinctrl_desc , <vul-start> & amd_pinctrl_desc , <vul-end> gpio_dev ) ; <vul-start> ( ret ) return ret <vul-end> ; ret = <vul-start> gc ) ; <vul-end> return ret ;\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> dev ) ; if (! gpio_dev -> base ) { dev_err ( & pdev -> dev, \"Failed to allocate pinctrl device.\\\\n\" ) ; return - ENOMEM ; } <vul-start> gc ) ; <vul-end> pinctrl_unregister ( gpio_dev\n"
  },
  {
    "id": 273,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <vul-start> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <vul-end> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = get_flc ( 12 <vul-end>, stream )\n"
  },
  {
    "id": 274,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <vul-start> if ( nbytes < sizeof ( * hwrpb ) ) <vul-end> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> if ( nbytes > <vul-end> sizeof ( *\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * hwrpb ) ||! access_ok ( VERIFY_WRITE, buffer, nbytes )\n"
  },
  {
    "id": 275,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <vul-start> list_del ( & key -> graveyard_link ) ; <vul-end> kdebug ( \"- %u\" , key -> serial ) ; key_check ( key ) ; <vul-start> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <vul-end> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <vul-start> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <vul-end> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> graveyard_link ) ; short state = key -> state ; <vul-start> ; if ( state == KEY_IS_POSITIVE && <vul-end> key -> type <vul-start> ; if ( state != KEY_IS_UNINSTANTIATED <vul-end> ) atomic_dec (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> graveyard_link ) ; short state = list_empty ( & key -> state ) ; <vul-start> ; if ( state < 0 && key -> state!= KEY_IS_UNINSTANTIATED <vul-end> && key -> <vul-start> ; if ( state < 0 && key -> state!= KEY_IS_UNINSTANTIATED <vul-end> ) atomic_dec (\n"
  },
  {
    "id": 276,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <vul-start> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <vul-end> if ( ! newscratch ) { failf ( data , \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } <vul-start> } <vul-end> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( 2 * UPLOAD_BUFSIZE <vul-end> ) ; if <vul-start> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = scratch ; if ( data -> set. buffer_size > 0 ) { <vul-start> ; } } else { failf ( data, \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } }\n"
  },
  {
    "id": 277,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_decode ( struct stream_state * stream , enum TestDecodeFatality fatal , const VpxInterface * codec ) { vpx_image_t enc_img , dec_img ; if ( stream -> mismatch_seen ) return ; if ( strcmp ( codec -> name , \"vp8\" ) == 0 ) { struct vpx_ref_frame ref_enc , ref_dec ; int width , height ; width = ( stream -> config . cfg . g_w + 15 ) & ~ 15 ; height = ( stream -> config . cfg . g_h + 15 ) & ~ 15 ; vpx_img_alloc ( & ref_enc . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; enc_img = ref_enc . img ; vpx_img_alloc ( & ref_dec . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; dec_img = ref_dec . img ; ref_enc . frame_type = VP8_LAST_FRAME ; ref_dec . frame_type = VP8_LAST_FRAME ; vpx_codec_control ( & stream -> encoder , VP8_COPY_REFERENCE , & ref_enc ) ; vpx_codec_control ( & stream -> decoder , VP8_COPY_REFERENCE , & ref_dec ) ; } else { <vul-start> struct vp9_ref_frame ref ; <vul-end> ref . idx = 0 ; <vul-start> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ; <vul-end> enc_img = ref . img ; <vul-start> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ; <vul-end> dec_img = ref . img ; } ctx_exit_on_error ( & stream -> encoder , \"Failed to get encoder reference frame\" ) ; ctx_exit_on_error ( & stream -> decoder , \"Failed to get decoder reference frame\" ) ; if ( ! compare_img",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { struct vp9_ref_frame ref_enc , ref_dec ; ref_enc <vul-end> . idx = <vul-start> = 0 ; ref_dec . idx = 0 ; <vul-start> VP9_GET_REFERENCE , & ref_enc ) ; enc_img = ref_enc <vul-end> . img ; <vul-start> VP9_GET_REFERENCE , & ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <vul-end> } ctx_exit_on_error ( <vul-start> 4 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <vul-start> v ) ; } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> else { struct vpx_ref_frame <vul-end> ref ; ref <vul-start> -> encoder, VP9_GET_ENTITIES, & ref, enc_img, dec_img <vul-end> ) ; enc_img <vul-start>. img ; dec_img = ref. img ; } ctx_exit_on_error ( & stream -> encoder, \"Failed to get encoder reference frame\" ) ; ctx_exit_on_error ( & stream -> decoder, \"Failed to get decoder reference frame\" ) ; if (! compare_img ( & enc_img, & dec_img ) ) { int res ; res = vpx_image_read ( stream -> decoder. img, enc_img, enc_img ) ; if ( res < 0 ) { ctx_exit_on_error ( & stream -> encoder, \"Failed to get encoder reference frame\" ) ; ctx_exit_on_error ( & stream -> decoder, \"Failed to get decoder reference frame\" ) ; } <vul-start> -> decoder, VP9_GET_ENTITIES, & ref, enc_img, dec_img <vul-end> ) ; stream\n"
  },
  {
    "id": 278,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <vul-end> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <vul-start> number_threads ; <vul-end> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <vul-start> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <vul-end> { <vul-start> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <vul-end> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <vul-start> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <vul-end> <vul-start> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <vul-end> } return ( pixels ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> const Image * images ) { const Image * next ; <vul-end> MagickPixelPacket * * <vul-start> j ; size_t columns , <vul-start> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <vul-end> i = 0 <vul-start> ) AcquireQuantumMemory ( <vul-end> columns , sizeof <vul-start> ( ssize_t ) <vul-end> columns ; j <vul-start> ) GetMagickPixelPacket ( images <vul-end> , & pixels\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> const Image * images ) { const ImagePacket * packet ; <vul-end> MagickPixelPacket * * <vul-start> ; size_t number_threads ; const ssize_t columns = images -> columns <vul-start> ) ) ; packet = ( MagickPixelPacket * * ) AcquireQuantumMemory ( columns, sizeof ( * * pixels ) ) ; if ( packet == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <vul-start> ) AcquireQuantumMemory ( packet. <vul-end> columns, sizeof <vul-start> ( ssize_t ) packet. <vul-end> columns ; j <vul-start> j ++ ) { if ( <vul-start> j ] ) == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; } <vul-end> } return (\n"
  },
  {
    "id": 279,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) { struct frag * f ; struct list_head * item ; int rec , num , group ; BUG_ON ( ! data || ! frags ) ; if ( size < 2 * VBLK_SIZE_HEAD ) { ldm_error ( \"Value of size is to small.\" ) ; return false ; } group = get_unaligned_be32 ( data + 0x08 ) ; rec = get_unaligned_be16 ( data + 0x0C ) ; num = get_unaligned_be16 ( data + 0x0E ) ; if ( ( num < 1 ) || ( num > 4 ) ) { ldm_error ( \"A VBLK claims to have %d parts.\" , num ) ; return false ; } if ( rec >= num ) { ldm_error ( \"REC value (%d) exceeds NUM value (%d)\" , rec , num ) ; return false ; } list_for_each ( item , frags ) { f = list_entry ( item , struct frag , list ) ; if ( f -> group == group ) goto found ; } f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; if ( ! f ) { ldm_crit ( \"Out of memory.\" ) ; return false ; } f -> group = group ; f -> num = num ; f -> rec = rec ; f -> map = 0xFF << num ; list_add_tail ( & f -> list , frags ) ; found : <vul-start> if ( f -> map & ( 1 <<",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> : if ( rec >= f -> num ) { ldm_error ( \"REC value (%d) exceeds NUM value (%d)\" , rec , f -> num ) ; return false ; } if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> : if ( rec >= VBLK_SIZE_HEAD && <vul-start> -> map & 1 << rec ) ) { ldm_error ( \"Duplicate VBLK, part %d.\", rec ) ; f -> map &= 0x7F ; return false ; } f -> map |=\n"
  },
  {
    "id": 280,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id , <vul-end> unsigned int * ref_costs_single , unsigned int * ref_costs_comp , <vul-start> vp9_prob * comp_mode_p ) { <vul-end> <vul-start> VP9_COMMON * const cm = & cpi -> common ; <vul-end> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int seg_ref_active = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { vpx_memset ( ref_costs_single , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_single ) ) ; <vul-start> vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ; <vul-end> * comp_mode_p = 128 ; } else { <vul-start> vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; <vul-end> <vul-start> vp9_prob comp_inter_p = 128 ; <vul-end> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { comp_inter_p = vp9_get_reference_mode_prob ( cm , xd ) ; * comp_mode_p = comp_inter_p ; } else { * comp_mode_p = 128 ; } ref_costs_single [ INTRA_FRAME ] = vp9_cost_bit ( intra_inter_p , 0 ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) { <vul-start> vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <vul-end> <vul-start> vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <vul-end> unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) base_cost += vp9_cost_bit ( comp_inter_p , 0 ) ; ref_costs_single [ LAST_FRAME ] = ref_costs_single [ GOLDEN_FRAME ] = ref_costs_single [ ALTREF_FRAME ] = base_cost ; ref_costs_single [ LAST_FRAME ] += vp9_cost_bit ( ref_single_p1 , 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> void estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <vul-end> int segment_id , <vul-start> * ref_costs_comp , vpx_prob <vul-end> * comp_mode_p ) <vul-start> comp_mode_p ) { int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <vul-end> ( ref_costs_single , <vul-start> ) ) ; memset <vul-end> ( ref_costs_comp , <vul-start> } else { vpx_prob <vul-end> intra_inter_p = vp9_get_intra_inter_prob <vul-start> xd ) ; vpx_prob <vul-end> comp_inter_p = 128 <vul-start> COMPOUND_REFERENCE ) { vpx_prob <vul-end> ref_single_p1 = vp9_get_pred_prob_single_ref_p1 <vul-start> xd ) ; vpx_prob <vul-end> ref_single_p2 = vp9_get_pred_prob_single_ref_p2 <vul-start> SINGLE_REFERENCE ) { vpx_prob <vul-end> ref_comp_p = vp9_get_pred_prob_comp_ref_p\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void estimate_ref_frame_costs ( const VP9_COMMON * const cm, MACROBLOCKD * const xd, <vul-end> int segment_id, <vul-start> * ref_costs_comp, vpx_prob <vul-end> * comp_mode_p ) <vul-start> cpi -> common <vul-end> ; int seg_ref_active <vul-start> } else { vpx_prob intra_inter_p = vp9_get_intra_inter_prob ( cm, xd ) ; vpx_prob <vul-end> comp_inter_p = 128 <vul-start> COMPOUND_REFERENCE ) { vpx_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 <vul-end> ( cm, <vul-start> xd ) ; vpx_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 <vul-end> ( cm, <vul-start> SINGLE_REFERENCE ) { vpx_prob ref_comp_p = vp9_get_pred_prob_comp_ref_p <vul-end> ( cm,\n"
  },
  {
    "id": 281,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int http_receive_data ( HTTPContext * c ) { HTTPContext * c1 ; int len , loop_run = 0 ; while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , 1 , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; return 0 ; } else if ( len == 0 ) { goto fail ; } else if ( c -> buffer_ptr - c -> buffer >= 2 && ! memcmp ( c -> buffer_ptr - 1 , \"\\\\r\\\\n\" , 2 ) ) { c -> chunk_size = strtol ( c -> buffer , 0 , 16 ) ; <vul-start> if ( c -> chunk_size == 0 ) <vul-end> goto fail ; c -> buffer_ptr = c -> buffer ; break ; } else if ( ++ loop_run > 10 ) goto fail ; else c -> buffer_ptr ++ ; } if ( c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , FFMIN ( c -> chunk_size , c -> buffer_end - c -> buffer_ptr ) , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; } else if ( len ==",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <vul-end> c -> buffer_ptr <vul-start> ; else { av_assert0 ( len <= c -> chunk_size ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> c -> chunk_size < 0 || c -> chunk_size > c -> buffer_end <vul-end> ) goto fail <vul-start> ; else { if ( c -> chunk_size < 0 || c -> chunk_size > c -> buffer_end - c -> buffer_ptr ) goto fail ;\n"
  },
  {
    "id": 282,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , \" %s\" , tok2str ( nfsproc_str , \"proc-%u\" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \" post dattr:\" ) ) ; dp = parse_post_op_attr",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ! er ) { ND_TCHECK ( <vul-end> dp [ 0 <vul-start> 0 ] ) ; ND_PRINT ( ( ndo , \" c %04x\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <vul-end> return ; case\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, EXTRACT_32BITS ( dp <vul-end> ) ) )\n"
  },
  {
    "id": 283,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <vul-start> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <vul-end> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != (",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ( n ) \\\\\\n{ <vul-end> sum = ( <vul-start> ++ ; } \\\\\\n} <vul-end> typedef struct PCDTable <vul-start> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <vul-start> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> char * ) RelinquishMagickMemory ( buffer ) ; buffer = ( unsigned char * )\n"
  },
  {
    "id": 284,
    "question": "CWE-706 Code Input Vulnerable Code Is: CWE-706 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for (",
    "golden_answers": [
      "CWE-706 Fixed Code Lines are: <vul-start> ; if ( * cp == '\\\\0' || <vul-end> strchr ( cp <vul-start> ) != NULL || <vul-end> strcmp ( cp <vul-start> ( cp , \".\" ) == 0 || strcmp ( cp , <vul-start> ) == 0 <vul-end> ) { run_err\n"
    ],
    "generated_answer": "CWE-706 Fixed Code Lines are: <vul-start> if ( ( ( <vul-start>!= NULL ) && ( <vul-end> ( strcmp ( <vul-start> == 0 ) )\n"
  },
  {
    "id": 285,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int DoOneObject ( char * cinput ) { <vul-start> int num , i , num1 , num2 ; <vul-end> <vul-start> char * s , * t , * StartClean ; <vul-end> <vul-start> double * argbuf = 0 ; <vul-end> SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == ' ' || * t == '\\\\t' || * t == '\\\\n' ) t ++ ; <vul-start> outpos = outputbuffer ; <vul-end> <vul-start> outpos += sprintf ( outpos , \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" , s , t , TERMCHAR ) ; <vul-end> <vul-start> if ( * s == '0' && s [ 1 ] == ']' ) { <vul-end> if ( strcmp ( nameobject , \"AxodrawWantsPDF\" ) == 0 ) { identification = 1 ; <vul-start> outpos += sprintf ( outpos , \"Axohelp version %d.%d. PDF output.}\" , VERSION , SUBVERSION ) ; <vul-end> <vul-start> fprintf ( outfile , \"%s\" , outputbuffer ) ; <vul-end> return ( 0 ) ; } else { fprintf ( stderr , \"%s: Illegal request in identification string [0]: %s\\\\n\" , axohelp , nameobject ) ; <vul-start> if ( argbuf ) free ( argbuf ) ; <vul-end> return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != ' ' && * t != '\\\\t' && * t != '\\\\n' && * t ) t ++ ; *",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> num1 , num2 , retcode <vul-start> , * t <vul-end> ; double * <vul-start> argbuf = 0 ; retcode = - 1 <vul-start> t ++ ; fprintf ( outfile , \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" , s , t , TERMCHAR ) ; <vul-start> = outputbuffer ; nameobject = t ; while ( * t != ' ' && * t != '\\\\t' && * t != '\\\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == ' ' || * t == '\\\\t' || * t == '\\\\n' ) t ++ <vul-end> ; if ( <vul-start> 1 ] == 0 <vul-end> ) { if <vul-start> = 1 ; fprintf ( outfile , \"Axohelp version %d.%d. PDF output.\" <vul-end> , VERSION , <vul-start> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <vul-end> stderr , \"%s: Illegal request in identification string [0]: %s\\\\n\" <vul-start> nameobject ) ; goto EXIT ; } } <vul-end> if ( ( <vul-start> == 0 ) goto EXIT <vul-end> ; if ( <vul-start> inname ) ; goto EXIT <vul-end> ; } else <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> == 0 ) goto EXIT <vul-end> ; if ( <vul-start> inname ) ; goto EXIT <vul-end> ; } else <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> == 0 ) goto EXIT <vul-end> ; for ( <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> inname ) ; goto EXIT <vul-end> ; } } <vul-start> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <vul-start> argbuf ) ; } fprintf ( outfile , \"}\\\\n\" ) ; return ( retcode <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> cinput ) { SetDefaults ( ) ; <vul-start> num1, num2, numlen <vul-start>, * StartClean <vul-end> ; s = <vul-start> t ++ ; <vul-end> outpos += sprintf <vul-start> ( outpos, \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" <vul-end>, s, <vul-start>, s, t, TERMCHAR ) ; numlen = sizeof ( argbuf ) / sizeof ( KEYWORD ) ; if ( strcmp ( nameobject, \"Curve\" ) == 0 ) { if ( identification == 1 ) { fprintf ( outfile, \"AxodrawWantsPDF\" ) ; return ( 0 ) ; } else if ( strcmp ( nameobject, \"Polygon\" ) == 0 ) { Polygon ( argbuf, num1, 0 ) ; } else if ( strcmp ( nameobject, \"FilledPolygon\" ) == 0 ) { Polygon ( argbuf, num1, 1 ) ; } else { fprintf ( outfile, \"%s\", outputbuffer ) ; return ( 0 ) ; } } else { fprintf ( stderr, \"%s: Illegal request in identification string [0]: %s\\\\n\", axohelp, nameobject ) ; return ( - 1 ) ; } } else if ( strcmp ( nameobject, \"DashCurve\" ) == 0 ) { if ( ReadArray ( t, & num1, & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2!= 2 ) { fprintf ( stderr, \"%s: Command %s should have no extra numbers in %s.\\\\n\", axohelp, nameobject, inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { if ( num2 - 1!= 0 ) { fprintf ( stderr, \"%s: Command %s should have no extra numbers in %s.\\\\n\", axohelp, nameobject, inname ) ; free ( argbuf ) ; return ( - 1 ) ; } else { axolinewidth = argbuf [ 2 * num1 + num2 - 1 ] ; SetLineWidth ( axolinewidth ) ; if ( strcmp ( nameobject, \"Curve\" ) == 0 ) { if ( strcmp ( nameobject, \"Polygon\" ) == 0 ) { if ( strcmp ( nameobject, \"FilledPolygon\" ) == 0 ) {"
  },
  {
    "id": 286,
    "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <vul-start> int is_udplite = IS_UDPLITE ( sk ) ; <vul-end> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <vul-start> if ( udp_lib_checksum_complete ( skb ) ) <vul-end> goto csum_copy_err ; } <vul-start> if ( skb_csum_unnecessary ( skb ) ) <vul-end> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) )",
    "golden_answers": [
      "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid = ! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if ( ! checksum_valid <vul-start> } if ( checksum_valid ||\n"
    ],
    "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid =! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if (! checksum_valid <vul-start> } if ( checksum_valid ||\n"
  },
  {
    "id": 287,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t decoder_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , int * is_intra_only , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { int intra_only_flag = 0 ; <vul-start> uint8_t clear_buffer [ 9 ] ; <vul-end> if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ; si -> is_kf = 0 ; si -> w = si -> h = 0 ; if ( decrypt_cb ) { data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ; data = clear_buffer ; <vul-start> } <vul-end> { int show_frame ; int error_resilient ; struct vpx_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ; const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ; if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-start> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) <vul-end> return VPX_CODEC_UNSUP_BITSTREAM ; if ( vpx_rb_read_bit ( & rb ) ) { vpx_rb_read_literal ( & rb , 3 ) ; return VPX_CODEC_OK ; } <vul-start> if ( data_sz <= 8 ) <vul-end> return VPX_CODEC_UNSUP_BITSTREAM ; si -> is_kf = ! vpx_rb_read_bit ( & rb ) ; show_frame = vpx_rb_read_bit ( & rb ) ; error_resilient = vpx_rb_read_bit ( & rb ) ; if ( si -> is_kf ) { if ( ! vp9_read_sync_code ( & rb ) )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> uint8_t clear_buffer [ 10 <vul-end> ] ; if <vul-start> clear_buffer ; } if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-start> ; if ( vpx_rb_read_bit ( & rb ) ) { if ( profile > <vul-end> 2 && data_sz <vul-start> 2 && data_sz < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-end> vpx_rb_read_literal ( & <vul-start> if ( data_sz < 10 <vul-end> ) return VPX_CODEC_UNSUP_BITSTREAM\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint8_t clear_buffer [ 10 <vul-end> ] ; if <vul-start> = clear_buffer ; <vul-end> { int show_frame <vul-start> } if ( data + data_sz <= data <vul-end> ) return VPX_CODEC_UNSUP_BITSTREAM <vul-start> } if ( data + data_sz <= data <vul-end> ) return VPX_CODEC_UNSUP_BITSTREAM\n"
  },
  {
    "id": 288,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; <vul-start> # endif <vul-end> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , \"Parent process\" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , \"Unable to get uname() information - error %d\" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , \"Unable to parse kernel version %s\" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; # endif umask ( 022 ) ; <vul-start> ( ) ; global_data -> umask = umask_val ; <vul-start> ) ; } <vul-end> # ifdef _MEM_CHECK_\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; # endif # ifdef _WITH_SECURE_SECURE_ __set_bit ( DAEMON_SECURE_, & daemon_mode ) ; # endif <vul-start> ; # endif # ifdef _WITH_SECURE_SECURE_ __set_bit ( DAEMON_SECURE_SECURE, & daemon_mode ) ; # endif\n"
  },
  {
    "id": 289,
    "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 int msPostGISLayerSetTimeFilter ( layerObj * lp , const char * timestring , const char * timefield ) { char * * atimes , * * aranges = NULL ; int numtimes = 0 , i = 0 , numranges = 0 ; size_t buffer_size = 512 ; char buffer [ 512 ] , bufferTmp [ 512 ] ; buffer [ 0 ] = '\\\\0' ; bufferTmp [ 0 ] = '\\\\0' ; if ( ! lp || ! timestring || ! timefield ) <vul-start> return MS_FALSE ; <vul-end> if ( strstr ( timestring , \",\" ) == NULL && strstr ( timestring , \"/\" ) == NULL ) { createPostgresTimeCompareSimple ( timefield , timestring , buffer , buffer_size ) ; } else { atimes = msStringSplit ( timestring , ',' , & numtimes ) ; if ( atimes == NULL || numtimes < 1 ) return MS_FALSE ; strlcat ( buffer , \"(\" , buffer_size ) ; for ( i = 0 ; i < numtimes ; i ++ ) { if ( i != 0 ) { strlcat ( buffer , \" OR \" , buffer_size ) ; } strlcat ( buffer , \"(\" , buffer_size ) ; aranges = msStringSplit ( atimes [ i ] , '/' , & numranges ) ; if ( ! aranges ) return MS_FALSE ; if ( numranges == 1 ) { createPostgresTimeCompareSimple ( timefield , atimes [ i ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else if ( numranges == 2 ) { createPostgresTimeCompareRange ( timefield ,",
    "golden_answers": [
      "CWE-89 Fixed Code Lines are: <vul-start> return MS_FALSE ; if ( strchr ( timestring , '\\\\'' ) || strchr ( timestring , '\\\\\\\\' ) ) { msSetError ( MS_MISCERR , \"Invalid time filter.\" , \"msPostGISLayerSetTimeFilter()\" ) ; return MS_FALSE ; }\n"
    ],
    "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start> return MS_FALSE ; if ( strlen ( timestring ) + buffer_size > 512 ) { return MS_FALSE ; }\n"
  },
  {
    "id": 290,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void start_daemon ( ) { struct usb_sock_t * usb_sock ; if ( g_options . noprinter_mode == 0 ) { usb_sock = usb_open ( ) ; if ( usb_sock == NULL ) goto cleanup_usb ; } else usb_sock = NULL ; uint16_t desired_port = g_options . desired_port ; <vul-start> struct tcp_sock_t * tcp_socket ; <vul-end> <vul-start> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <vul-end> <vul-start> g_options . only_desired_port == 0 ) { <vul-end> desired_port ++ ; if ( desired_port == 1 || desired_port == 0 ) desired_port = 49152 ; <vul-start> } <vul-end> if ( tcp_socket == NULL ) goto cleanup_tcp ; <vul-start> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <vul-end> if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) { ERR ( \"Received port number did not match requested port number.\" \" The requested port number may be too high.\" ) ; goto cleanup_tcp ; } printf ( \"%u|\" , real_port ) ; fflush ( stdout ) ; <vul-start> uint16_t pid ; <vul-end> if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) { printf ( \"%u|\" , pid ) ; exit ( 0 ) ; } if ( usb_can_callback ( usb_sock ) ) usb_register_callback ( usb_sock ) ; for ( ; ; ) { struct service_thread_param * args = calloc ( 1 , sizeof ( * args ) ) ; if ( args == NULL ) { ERR ( \"Failed to alloc space for thread args\" ) ; goto cleanup_thread ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <vul-end> tcp_socket = tcp_open <vul-start> ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <vul-end> g_options . only_desired_port <vul-start> g_options . only_desired_port ) break ; <vul-end> desired_port ++ ; <vul-start> = 49152 ; NOTE ( \"Access to desired port failed, trying alternative port %d\" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <vul-end> == NULL ) <vul-start> ; uint16_t real_port ; if ( tcp_socket ) real_port <vul-start> tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <vul-start> stdout ) ; NOTE ( \"Port: %d, IPv4 %savailable, IPv6 %savailable\" , real_port , tcp_socket ? \"\" : \"not \" , tcp6_socket ? \"\" : \"not \" ) ; <vul-start> -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <vul-end> ) ; if <vul-start> tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>. desired_port ; int16_t <vul-end> tcp_socket ; while <vul-start> while ( ( tcp_socket = tcp_open_safe <vul-end> ( desired_port ) <vul-start> g_options. only_desired_port ) <vul-start> = 49152 ; if ( desired_port!= 0 && g_options. only_desired_port == 1 && desired_port!= real_port ) { ERR ( \"Received port number did not match requested port number.\" \" The requested port number may be too high.\" ) ; goto cleanup_tcp ; } <vul-start> ( tcp_socket ) ; args -> tcp = tcp_conn_accept ( tcp_socket ) <vul-start> stdout ) ; <vul-end> if ( usb_can_callback\n"
  },
  {
    "id": 291,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; <vul-start> if ( exists_not_none ( obj , & PyId_lower ) ) { <vul-end> int res ; <vul-start> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <vul-end> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <vul-end> { int res <vul-start> int res ; <vul-end> res = obj2ast_expr <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"dims\\\\\" missing from ExtSlice\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ; Py_ssize_t i <vul-end> ; if ( <vul-start> ) { slice_ty val <vul-end> ; res = <vul-start> ) , & val <vul-end> , arena ) <vul-start> , i , val <vul-end> ) ; } <vul-start> ( tmp ) <vul-end> ; } * <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from Index\" ) ; return 1 ; } else <vul-end> { int res <vul-start> int res ; <vul-end> res = obj2ast_expr <vul-start> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <vul-end> ( PyExc_TypeError , <vul-start> ( PyExc_TypeError , <vul-end> \"expected some sort of slice, but got %R\" , obj\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; Py_ssize_t i ; slice_ty value <vul-start> ++ ) { <vul-end> res = obj2ast_slice <vul-start> ) ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; goto failed ; } else { int res ; <vul-start> ) ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; } else { upper = NULL ; } <vul-start>, & PyId_lower, & value <vul-start> ) ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; goto failed ; } else { int res ; res = obj2ast_slice ( tmp, & lower, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { int res ; res = obj2ast_slice ( tmp, & upper, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { int res ; <vul-end> res = obj2ast_slice <vul-start> ) ; } if ( tmp == NULL ) { Py_CLEAR ( tmp ) ; } else { int res ; res = obj2ast_slice ( tmp, & step, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { int res ; tmp = _PyObject_GetAttrId ( obj, & PyId_value, & value ) ; if ( tmp == NULL ) goto failed ; Py_CLEAR ( tmp ) ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"value\\\\\" missing from Index\" ) ; return 1 ; } * out = ExtSlice ( dims, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"dims\\\\\" missing from ExtSlice\" ) ; return 1 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value"
  },
  {
    "id": 292,
    "question": "CWE-255 Code Input Vulnerable Code Is: CWE-255 kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <vul-start> int ret , last_pwd ; <vul-end> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle ->",
    "golden_answers": [
      "CWE-255 Fixed Code Lines are: <vul-start> ret , last_pwd , n_new_keys <vul-start> keyblocks ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <vul-start> -> context , n_new_keys <vul-end> , kdb ->\n"
    ],
    "generated_answer": "CWE-255 Fixed Code Lines are: <vul-start> ret, last_pwd, act_n_ks_tuple <vul-start> keyblocks ) { act_n_ks_tuple = min ( kdb -> n_key_data, kdb -> key_data ) ; act_n_ks_tuple = max ( kdb -> n_key_data, act_n_ks_tuple ) ; <vul-start> -> context, act_n_ks_tuple, act_n_ks_tuple <vul-end>, keyblocks,\n"
  },
  {
    "id": 293,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; <vul-start> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <vul-end> if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; <vul-start> vpx_memset ( frame_stats -> mb_stats , 0 , <vul-end> cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; } <vul-start> vp9_clear_system_state ( ) ; <vul-end> separate_arf_mbs ( cpi ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cpi , GOLDEN_FRAME ) ; assert ( golden_ref != NULL <vul-start> i ] ; memset <vul-end> ( frame_stats -> <vul-start> ) ; } vpx_clear_system_state <vul-end> ( ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * golden_ref = get_ref_frame <vul-end> ( cpi, <vul-start> i ] ; memset <vul-end> ( frame_stats -> <vul-start> ) ; } clear_ref_frame ( cpi, golden_ref ) ;\n"
  },
  {
    "id": 294,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , \"Out of memory\\\\n\" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ; <vul-start> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <vul-end> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , \"Invalid number of endpoints\\\\n\" ) ; retval = - EINVAL ; goto error ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> idProduct ) ; if ( dev -> product_id > USB_MAX_DEVICE_ID ) { dev_err ( & interface -> dev, \"Invalid product id\\\\n\" ) ; goto error ; }\n"
  },
  {
    "id": 295,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , \"%sERROR: object header size %u not a multiple of 4\" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , \"%sERROR: object header too short %u < %lu\" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , \"%s%s Object (%u) Flags: [%s\" , ident , tok2str ( rsvp_obj_values , \"Unknown\" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <vul-start> bandwidth ) ; <vul-end> ND_PRINT ( ( <vul-start> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; ND_TCHECK_32BITS ( obj_ptr. rsvp_obj_frr -> bandwidth ) ; <vul-start> ; switch ( obj_ptr. rsvp_obj_frr -> <vul-start> ) ) ; ND_TCHECK_32BITS ( obj_ptr. rsvp_obj_frr -> bandwidth ) ;\n"
  },
  {
    "id": 296,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; <vul-start> struct sock * sk = sock -> sk ; <vul-end> struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\\\n\" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; <vul-start> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <vul-end> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> sock -> sk <vul-end> ; int copied <vul-start> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <vul-end> msg -> msg_name <vul-start> 0xFF ; } <vul-end> msg -> msg_namelen <vul-start> msg -> msg_namelen = sizeof ( * maddr ) <vul-end> ; } copied\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> sock -> sk ; struct sockaddr_mISDN * maddr ; size_t len_copy <vul-start> return err ; msg -> msg_namelen = 0 ; <vul-start> } else { <vul-end> msg -> msg_namelen <vul-start> msg -> msg_namelen = 0 ; copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue, skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb, MISDN_HEADER_LEN, mISDN_HEAD_P ( skb ), MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb, 0, msg -> msg_iov, copied ) ; mISDN_sock_cmsg ( sk, skb ) ; return err? : copied ; } memcpy ( skb_push ( skb, MISDN_HEADER_LEN ), mISDN_HEAD_P ( skb ), MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb, 0, msg -> msg_iov, copied ) ; mISDN_sock_cmsg ( sk, skb ) ; return err? : copied ; <vul-end> }    \n"
  },
  {
    "id": 297,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <vul-start> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <vul-end> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt ) , & final ) ; rcu_read_unlock ( <vul-end> ) ; dst\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt )\n"
  },
  {
    "id": 298,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Option (0x%02x), length %u (length bogus, should be >= 2)\" , tok2str ( bacconfopts_values , \"Unknown\" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Option (0x%02x), length %u\" , tok2str ( bacconfopts_values , \"Unknown\" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , \" (length bogus, should be = 6)\" ) ) ; return len ; } <vul-start> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <vul-end> ND_PRINT ( ( ndo , \": Magic-Num 0x%08x\" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , \"\\\\n\\\\t \" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , \"\\\\n\\\\t \" , len - 2 ) ; return len ; trunc : ND_PRINT (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> len ; } ND_TCHECK_32BITS <vul-end> ( p + <vul-start> p + 2 <vul-end> ) ; ND_PRINT\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> len ; } ND_TCHECK_32BITS ( p + 2 <vul-end> ) ; ND_PRINT\n"
  },
  {
    "id": 299,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <vul-start> if ( radiotap_header -> it_version ) <vul-end> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <vul-start> ( unsigned long ) iterator -> _rtheader > <vul-end> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <vul-start> iterator -> _rtheader + sizeof ( uint32_t )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> radiotap_header -> it_version || max_length < 0 || ( unsigned long ) iterator -> _max_length > get_unaligned_le16 ( & radiotap_header -> it_len ) <vul-start> iterator -> _rtheader + <vul-end> ( unsigned long\n"
  },
  {
    "id": 300,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; <vul-start> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <vul-end> <vul-start> goto err_delete ; <vul-end> tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , \"conflict with already offloaded filter\" ) ; <vul-start> goto err_delete ; <vul-end> } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) <vul-start> return - ENOMEM ; <vul-end> <vul-start> list_add ( & match -> list , & alink -> dscp_map ) ; <vul-end> } match -> handle = knode -> handle ; match -> band =",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> extack ) ) { err = - EOPNOTSUPP ; <vul-start> goto err_delete ; } <vul-start> \"conflict with already offloaded filter\" ) ; err = - EOPNOTSUPP ; <vul-start> ! match ) { err = <vul-end> - ENOMEM ; <vul-start> - ENOMEM ; goto err_delete ; } <vul-start> ) ; return err <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> extack ) ) return - EINVAL <vul-end> ; tos_off = <vul-start> ) ; goto err_put <vul-end> ; } } <vul-start>! match ) { err = <vul-end> - ENOMEM ; <vul-start> -> dscp_map ) ; if ( err ) goto err_put <vul-start> knode ) ; err_put : kfree ( match ) ;\n"
  },
  {
    "id": 301,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; <vul-start> bool slow ; <vul-end> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; bool slow <vul-end> ; if ( <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; bool slow <vul-end> ; if ( <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ;\n"
  },
  {
    "id": 302,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <vul-start> case 0 : <vul-end> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported ZIP compression method (%s)\" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac metadata is too large: %jd > 4M bytes\" , <vul-start> ( intmax_t ) rsrc -> uncompressed_size ) ; <vul-end> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t allocate memory for Mac metadata\" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Malformed OS X metadata entry: inconsistent size\" ) ; return ( ARCHIVE_FATAL ) ; } <vul-start> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac metadata is too large: %jd > 4M bytes\" , ( intmax_t ) rsrc -> compressed_size <vul-start> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case 0 : if ( bytes_avail > ARCHIVE_DEF_ZLIB_H ) { archive_set_error ( & a -> archive, ARCHIVE_ERRNO_FILE_FORMAT, \"Truncated ZIP file header\" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } <vul-start>, p, ( size_t )\n"
  },
  {
    "id": 303,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_layer_contexts ( VP8_COMP * cpi ) { VP8_CONFIG * oxcf = & cpi -> oxcf ; if ( oxcf -> number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <vul-start> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <vul-end> { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / oxcf -> rate_decimator [ i ] ; lc -> target_bandwidth = oxcf -> target_bitrate [ i ] * 1000 ; lc -> starting_buffer_level = rescale ( ( int ) oxcf -> starting_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> optimal_buffer_level == 0 ) lc -> optimal_buffer_level = lc -> target_bandwidth / 8 ; else lc -> optimal_buffer_level = rescale ( ( int ) oxcf -> optimal_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> maximum_buffer_size == 0 ) lc -> maximum_buffer_size = lc -> target_bandwidth / 8 ; else lc -> maximum_buffer_size = rescale ( ( int ) oxcf -> maximum_buffer_size_in_ms , lc -> target_bandwidth , 1000 ) ; if ( i > 0 ) lc -> avg_frame_size_for_layer = ( int ) ( ( oxcf -> target_bitrate [ i ] - oxcf -> target_bitrate [ i - 1 ] ) * 1000 / ( lc -> framerate - prev_layer_framerate ) ) ; prev_layer_framerate = lc -> framerate ; } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <vul-end> ) { LAYER_CONTEXT\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> VX_TS_MAX_LAYERS ) ; assert ( cpi -> rate_decimator == NULL ) ;\n"
  },
  {
    "id": 304,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , \" \" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , \"current\" ) == 0 ) { if ( strcmp ( command , \"changehat\" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , \"permhat\" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , \"changeprofile\" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , \"permprofile\" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> - EINVAL ; if (! error ) error = aa_get_proc ( task, name ) ; if (! error )\n"
  },
  {
    "id": 305,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Subtype (%u)\" , tok2str ( lldp_8023_subtype_values , \"unknown\" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t autonegotiation [%s] (0x%02x)\" , bittok2str ( lldp_8023_autonegotiation_values , \"none\" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t PMD autoneg capability [%s] (0x%04x)\" , bittok2str ( lldp_pmd_capability_values , \"unknown\" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t MAU type %s (0x%04x)\" , tok2str ( lldp_mau_types_values , \"unknown\" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t MDI power support [%s], power pair %s, power class %s\" , bittok2str ( lldp_mdi_values , \"none\" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , \"unknown\" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , \"unknown\" , * ( tptr + 6 ) ) ) ) ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case LLDP_PRIVATE_8023_SUBTYPE_MTU : ND_TCHECK_16BITS ( tptr + 4 ) ;\n"
  },
  {
    "id": 306,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <vul-start> int res , ret ; <vul-end> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> res, ret ; if ( match_futex ( & key2, & key3 ) ) return - EINVAL\n"
  },
  {
    "id": 307,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version !=",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> if ( n <vul-end> != i )\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> <= 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <vul-end> if ( n\n"
  },
  {
    "id": 308,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; <vul-start> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <vul-end> atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> icsk_ack. rcv_mss = 0 ;\n"
  },
  {
    "id": 309,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( \"%s: asoc:%p, timeo:%ld, msg_len:%zu\\\\n\" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <vul-start> BUG_ON ( sk != asoc -> base . sk ) ; <vul-end> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> current_timeo ) ; if <vul-end> ( sk != <vul-start> . sk ) goto do_error\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> current_timeo ) ; if <vul-end> ( sk!= <vul-start> base. sk ) goto do_error\n"
  },
  {
    "id": 310,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , \"INVALID-PAYLOAD-TYPE\" , \"DOI-NOT-SUPPORTED\" , \"SITUATION-NOT-SUPPORTED\" , \"INVALID-COOKIE\" , \"INVALID-MAJOR-VERSION\" , \"INVALID-MINOR-VERSION\" , \"INVALID-EXCHANGE-TYPE\" , \"INVALID-FLAGS\" , \"INVALID-MESSAGE-ID\" , \"INVALID-PROTOCOL-ID\" , \"INVALID-SPI\" , \"INVALID-TRANSFORM-ID\" , \"ATTRIBUTES-NOT-SUPPORTED\" , \"NO-PROPOSAL-CHOSEN\" , \"BAD-PROPOSAL-SYNTAX\" , \"PAYLOAD-MALFORMED\" , \"INVALID-KEY-INFORMATION\" , \"INVALID-ID-INFORMATION\" , \"INVALID-CERT-ENCODING\" , \"INVALID-CERTIFICATE\" , \"CERT-TYPE-UNSUPPORTED\" , \"INVALID-CERT-AUTHORITY\" , \"INVALID-HASH-INFORMATION\" , \"AUTHENTICATION-FAILED\" , \"INVALID-SIGNATURE\" , \"ADDRESS-NOTIFICATION\" , \"NOTIFY-SA-LIFETIME\" , \"CERTIFICATE-UNAVAILABLE\" , \"UNSUPPORTED-EXCHANGE-TYPE\" , \"UNEQUAL-PAYLOAD-LENGTHS\" , } ; static const char * ipsec_notify_error_str [ ] = { \"RESERVED\" , } ; static const char * notify_status_str [ ] = { \"CONNECTED\" , } ; static const char * ipsec_notify_status_str [ ] = { \"RESPONDER-LIFETIME\" , \"REPLAY-STATUS\" , \"INITIAL-CONTACT\" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , cp , ep2 <vul-end> , map , <vul-start> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , \")\" ) ) ; goto trunc ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, cp, <vul-end> ep2, map\n"
  },
  {
    "id": 311,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , \"MLTI with multiple (%d) MDPR\" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <vul-start> size2 , mime ) ; <vul-end> if ( ret < 0 ) return ret ; } return 0 ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> , size2 , NULL <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> size2, mime, 0\n"
  },
  {
    "id": 312,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int xfs_attr3_leaf_flipflags ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf1 ; struct xfs_attr_leafblock * leaf2 ; struct xfs_attr_leaf_entry * entry1 ; struct xfs_attr_leaf_entry * entry2 ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp1 ; struct xfs_buf * bp2 ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr1 ; struct xfs_attr3_icleaf_hdr ichdr2 ; xfs_attr_leaf_name_local_t * name_loc ; int namelen1 , namelen2 ; char * name1 , * name2 ; # endif trace_xfs_attr_leaf_flipflags ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ; if ( error ) return error ; if ( args -> blkno2 != args -> blkno ) { error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ; if ( error ) return error ; } else { bp2 = bp1 ; } leaf1 = bp1 -> b_addr ; entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ; leaf2 = bp2 -> b_addr ; entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ; ASSERT ( args -> index < ichdr1 . count ) ; ASSERT ( args -> index >= 0 ) ; xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ; ASSERT ( args -> index2 < ichdr2 . count ) ; ASSERT ( args -> index2 >= 0 ) ; if ( entry1 -> flags & XFS_ATTR_LOCAL )",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> ( args -> rmtvaluelen <vul-end> ) ; xfs_trans_log_buf\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ( args -> rmtvaluelen ) ; ASSERT ( args -> valuelen == args -> valuelen1 <vul-end> ) ; xfs_trans_log_buf\n"
  },
  {
    "id": 313,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-start> int mi_row , int mi_col , vp9_reader * r ) { <vul-end> MODE_INFO * const mi = xd -> mi [ 0 ] ; MB_MODE_INFO * const mbmi = & mi -> mbmi ; <vul-start> const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; <vul-end> <vul-start> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <vul-end> const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ; <vul-start> mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; <vul-end> mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ; <vul-start> mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; <vul-end> mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi ,",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int mi_col , vpx_reader <vul-end> * r ) <vul-start> = xd -> above_mi <vul-end> ; const MODE_INFO <vul-start> = xd -> left_mi <vul-end> ; const BLOCK_SIZE <vul-start> int i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , r ) <vul-start> cm , xd <vul-end> , 1 ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_reader * r, vpx_reader * r_raw <vul-start> const mi_col, vpx_reader * r_raw <vul-end> ) { MODE_INFO <vul-start> -> mi [ xd -> mi_stride <vul-end> ] ; const <vul-start> = xd -> left_available? xd -> mi [ - 1 ] : NULL ; const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ; mbmi -> segment_id = read_intra_segment_id ( cm, xd, mi_row, mi_col, r ) ; mbmi -> skip = read_skip <vul-end> ( cm, <vul-start> cm -> tx_mode <vul-end>, bsize, <vul-start> 1, r, r_raw\n"
  },
  {
    "id": 314,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <vul-start> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; if ( bytes > len ) bytes = len ; if ( <vul-start> ) break ; <vul-end> offset = 0\n"
  },
  {
    "id": 315,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <vul-start> length ; <vul-end> ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic !=",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , extent , height , <vul-start> \"UnableToReadImageData\" ) ; <vul-end> height = sun_info <vul-start> \"MemoryAllocationFailed\" ) ; if ( sun_info . type == RT_ENCODED ) <vul-start> sun_data ) ; <vul-end> p = sun_pixels\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> extent, length, bytes_per_pixel <vul-start> \"MemoryAllocationFailed\" ) ; bytes_per_pixel = sun_info. width * sun_info. depth ; <vul-start> ( ssize_t ) MagickMax ( <vul-start> image -> columns, bytes_per_pixel )\n"
  },
  {
    "id": 316,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ; <vul-start> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <vul-end> error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 )",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> , args -> rmtvaluelen <vul-end> ) ; error <vul-start> = args -> rmtvaluelen <vul-end> ; while (\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> args -> valuelen ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) <vul-start> args -> rmtblkcnt ; args -> rmtvaluelen = args -> valuelen\n"
  },
  {
    "id": 317,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; <vul-start> set_exception_intercept ( svm , AC_VECTOR ) ; <vul-end> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> svm, AC_VECTOR ) ; set_exception_intercept ( svm, AC_VECTOR\n"
  },
  {
    "id": 318,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ps_dec -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_dpb_mgr -> ps_"
  },
  {
    "id": 319,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( \"usage: condump <filename>\\\\n\" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <vul-start> COM_DefaultExtension ( filename , sizeof ( filename ) , \".txt\" ) ; <vul-end> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( \"ERROR: couldn\\'t open %s.\\\\n\" , filename ) ; return ; } Com_Printf ( \"Dumped console text to %s.\\\\n\" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != ' ' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> \".txt\" ) ; if ( ! COM_CompareExtension ( filename , \".txt\" ) ) { Com_Printf ( \"Con_Dump_f: Only the \\\\\".txt\\\\\" extension is supported by this command!\\\\n\" ) ; return ; }\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> \".txt\" ) ; if (! COM_CompareExtension ( filename, \".txt\" ) ) { Com_Printf ( \"Con_Dump_f: Only the \\\\\".txt\\\\\" extension is supported by this command!\\\\n\" ) ; return ; }\n"
  },
  {
    "id": 320,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; pwp_image = AcquireImage ( image_info , exception ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , \"SFW95\" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> read_info ) ; <vul-end> if ( EOFBlob\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> read_info ) ; <vul-end> if ( EOFBlob\n"
  },
  {
    "id": 321,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , \"s\" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <vul-start> count = Z_LVAL_P ( pcount ) ; <vul-end> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <vul-start> if ( Z_TYPE ( entry ) != IS_OBJECT ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <vul-start> } if ( <vul-end> * p == <vul-start> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <vul-end> ; } hash\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; count = Z_LVAL <vul-end> ( pcount ) <vul-start> } if (! Z_ISUNDEF ( entry ) ) { goto outexcept ; } if ( <vul-start> } if (! Z_ISUNDEF ( entry ) ) { goto outexcept ; } if (\n"
  },
  {
    "id": 322,
    "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( \"export-desktop-XXXXXX\" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , \".service\" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree",
    "golden_answers": [
      "CWE-74 Fixed Code Lines are: <vul-start> ) ; else if ( strcmp ( arg , \"@@\" ) == 0 || strcmp ( arg , \"@@u\" ) == 0 ) g_print ( _ ( \"Skipping invalid Exec argument %s\\\\n\" ) , arg ) ; else\n"
    ],
    "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> arg ) ; else if ( g_str_has_prefix ( arg, \"/bin/sh\" ) ) g_string_append_printf ( new_exec, \" %s\", arg ) ; else { <vul-end> g_string_append_printf ( new_exec <vul-start> arg ) ; }\n"
  },
  {
    "id": 323,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const uint8_t * decode_tiles ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; int tile_row , tile_col ; <vul-start> const uint8_t * end = NULL ; <vul-end> <vul-start> vp9_reader r ; <vul-end> assert ( tile_rows <= 4 ) ; assert ( tile_cols <= ( 1 << 6 ) ) ; <vul-start> vpx_memset ( cm -> above_context , 0 , <vul-end> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; <vul-start> vpx_memset ( cm -> above_seg_context , 0 , <vul-end> <vul-start> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; <vul-end> for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { <vul-start> const int last_tile = tile_row == tile_rows - 1 && <vul-end> tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row <",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <vul-start> , tile_col ; int mi_row , mi_col ; TileData * tile_data <vul-end> = NULL ; <vul-start> = NULL ; if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , \"Loop filter thread creation failed\" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <vul-end> assert ( tile_rows <vul-start> ) ) ; memset <vul-end> ( cm -> <vul-start> aligned_cols ) ; memset <vul-end> ( cm -> <vul-start> aligned_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <vul-start> ) { const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Failed to decode tile data\" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <vul-end> tile_rows - 1 <vul-start> tile_rows - 1 ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data_end ) { const TileBuffer_CONFIG * const tile_buffers_config = & pbi -> common. tile_buffers [ 0 ] ; const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_rows = 1 << cm -> log2_tile_rows ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; const uint8_t * end = NULL ; vp9_reader r ; assert ( tile_rows <= 4 ) ; assert ( tile_cols <= ( 1 << 6 ) ) ; vpx_memset ( cm -> above_context, 0, sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; vpx_memset ( cm -> above_seg_context, 0, sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int last_tile = tile_row == tile_rows - 1 && tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end, last_tile, & cm -> error, & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { for ( tile_row = 0 ; tile_col < tile_rows ; ++ tile_col ) { const int last_tile = tile_row == tile_rows - 1 && tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end, last_tile, & cm -> error, & r, & data ) ; TileBuffer * const buf = & tile_buffers [ tile"
  },
  {
    "id": 324,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <vul-start> unsigned long tpgt ; <vul-end> int ret ; if ( strstr ( name , \"tpgt_\" ) != name ) return ERR_PTR ( - EINVAL ) ; <vul-start> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <vul-end> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( \"Unable to allocate struct vhost_scsi_tpg\" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * tpg ; u16 <vul-end> tpgt ; int <vul-start> ; if ( kstrtou16 <vul-end> ( name + <vul-start> ) || tpgt >= VHOST_SCSI_MAX_TARGET <vul-end> ) return ERR_PTR\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * tpg ; int ret ; tpg = kstrtoul ( name, 10, & tpgt ) ; if (! tpg ) { pr_err ( \"Unable to allocate struct vhost_scsi_tpg\" ) ; return ERR_PTR ( - EINVAL ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops, wwn, & tpg -> se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL, tpg, TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list, & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; <vul-end> }    \n"
  },
  {
    "id": 325,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; <vul-start> context . Xtogo = i -> width ; <vul-end> context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY *",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** ERROR *** Image bigger than global GIF canvas !\\\\n\" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** WARNING *** Adjusting X position\\\\n\" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** WARNING *** Adjusting Y position\\\\n\" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> parent ) ; memset ( & context, 0, sizeof ( context ) ) ;\n"
  },
  {
    "id": 326,
    "question": "CWE-345 Code Input Vulnerable Code Is: CWE-345 static <vul-start> void headerMergeLegacySigs ( Header h , Header sigh ) <vul-end> { HeaderIterator hi ; struct rpmtd_s td ; <vul-start> hi = headerInitIterator ( sigh ) ; <vul-end> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <vul-start> td . tag = RPMTAG_SIGSIZE ; <vul-end> break ; case RPMSIGTAG_PGP : <vul-start> td . tag = RPMTAG_SIGPGP ; <vul-end> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <vul-start> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <vul-end> continue ; break ; } <vul-start> if ( ! headerIsEntry ( h , td . tag ) ) { <vul-end> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 )",
    "golden_answers": [
      "CWE-345 Fixed Code Lines are: <vul-start>     static rpmTagVal <vul-end> headerMergeLegacySigs ( Header <vul-start> , Header sigh , char * * msg ) { const struct taglate_s * xl <vul-end> ; struct rpmtd_s <vul-start> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <vul-end> td . tag <vul-start> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <vul-end> td . tag <vul-start> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <vul-end> if ( ! <vul-start> if ( ! headerPut <vul-end> ( h , <vul-start> ( h , <vul-end> & td , <vul-start> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , \"invalid signature tag %s (%d)\" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-345 Fixed Code Lines are: <vul-start> void headerMergeLegacySigs ( struct header_sigh * sigh, int tag ) { HeaderIterator hi ; struct rpmtd_s td ; <vul-end> switch ( td <vul-start>. tag = tag <vul-end> ; break ; <vul-start>. tag = tag <vul-end> ; break ; <vul-start> : default : td. tag = RPMTAG_SIGSIZE ; break ; case RPMSIGTAG_PGP : td. tag = tag ; break ; case RPMSIGTAG_MD5 : td. tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td. tag = RPMTAG_SIGGPGP ; break ; case RPMSIGTAG_PGP5 : td. tag = RPMTAG_SIGGP5 ; break ; case RPMSIGTAG_RSA : td. tag = RPMTAG_RSA ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_ARCHIVESIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_ARCHIVESIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATURES : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_RSA : td. tag = RPMTAG_RSA ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ; case RPMSIGTAG_VERITYSIGNATUREALGO : td. tag = RPMTAG_VERITYSIGNATUREALGO ; break ;"
  },
  {
    "id": 327,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { \"date-time-at-completed\" , \"date-time-at-creation\" , \"date-time-at-processing\" , \"job-detailed-status-messages\" , \"job-document-access-errors\" , \"job-id\" , \"job-impressions-completed\" , \"job-k-octets-completed\" , \"job-media-sheets-completed\" , \"job-pages-completed\" , \"job-printer-up-time\" , \"job-printer-uri\" , \"job-state\" , \"job-state-message\" , \"job-state-reasons\" , \"job-uri\" , \"number-of-documents\" , \"number-of-intervening-jobs\" , \"output-device-assigned\" , \"time-at-completed\" , \"time-at-creation\" , \"time-at-processing\" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , \"add_job(%p[%d], %p(%s), %p(%s/%s))\" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : \"none\" , filetype ? filetype -> type : \"none\" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , \"localhost\" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( \"The printer or class is not shared.\" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , \"auth-info\" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) ; } attr = ippFindAttribute ( con -> request , \"requesting-user-name\" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( \"Bad requesting-user-name value: %s\" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <vul-start> printer , job <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) == NULL && con -> is_custom_debug_stream\n"
  },
  {
    "id": 328,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 rfbBool InitialiseRFBConnection ( rfbClient * client ) { rfbProtocolVersionMsg pv ; int major , minor ; uint32_t authScheme ; uint32_t subAuthScheme ; rfbClientInitMsg ci ; if ( client -> listenSpecified ) errorMessageOnReadFailure = FALSE ; if ( ! ReadFromRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; errorMessageOnReadFailure = TRUE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; if ( sscanf ( pv , rfbProtocolVersionFormat , & major , & minor ) != 2 ) { rfbClientLog ( \"Not a valid VNC server (%s)\\\\n\" , pv ) ; return FALSE ; } DefaultSupportedMessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbProtocolMajorVersion ) && ( minor > rfbProtocolMinorVersion ) ) client -> minor = rfbProtocolMinorVersion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbClientLog ( \"UltraVNC server detected, enabling UltraVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbClientLog ( \"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && minor == 5 ) { rfbClientLog ( \"TightVNC server detected, enabling TightVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesTightVNC ( client ) ; } if ( ( major == 3 && minor > 8",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( \"Too big desktop name length sent by server: %u B > 1 MB\\\\n\" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <vul-start> = malloc ( <vul-end> client -> si\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> nameLength ) ; if ( client -> desktopName ) free ( client -> desktopName ) ;\n"
  },
  {
    "id": 329,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , \"(pad1)\" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , \"(padn: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(padn)\" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , \"(refresh: trunc)\" ) ) ; goto trunc ; } <vul-start> ND_PRINT ( ( ndo , \"(refresh: %u)\" , <vul-end> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , \"(altcoa: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(alt-CoA: %s)\" , ip6addr_string",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;\n"
  },
  {
    "id": 330,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <vul-start> if ( ! ext4_handle_valid ( handle ) ) <vul-end> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , \"get_write_access\" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> if ( ! EXT4_SB ( sb ) -> s_journal <vul-end> ) return 0\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( handle ) ) return 0 ; if (! ext4_should_dioread_nolock ( inode\n"
  },
  {
    "id": 331,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static ssize_t fuse_fill_write_pages ( struct fuse_req * req , struct address_space * mapping , struct iov_iter * ii , loff_t pos ) { struct fuse_conn * fc = get_fuse_conn ( mapping -> host ) ; unsigned offset = pos & ( PAGE_CACHE_SIZE - 1 ) ; size_t count = 0 ; int err ; req -> in . argpages = 1 ; req -> page_descs [ 0 ] . offset = offset ; do { size_t tmp ; struct page * page ; pgoff_t index = pos >> PAGE_CACHE_SHIFT ; size_t bytes = min_t ( size_t , PAGE_CACHE_SIZE - offset , iov_iter_count ( ii ) ) ; bytes = min_t ( size_t , bytes , fc -> max_write - count ) ; again : err = - EFAULT ; if ( iov_iter_fault_in_readable ( ii , bytes ) ) break ; err = - ENOMEM ; page = grab_cache_page_write_begin ( mapping , index , 0 ) ; if ( ! page ) break ; if ( mapping_writably_mapped ( mapping ) ) flush_dcache_page ( page ) ; tmp = iov_iter_copy_from_user_atomic ( page , ii , offset , bytes ) ; <vul-start> flush_dcache_page ( page ) ; <vul-end> if ( ! tmp ) { unlock_page ( page ) ; page_cache_release ( page ) ; bytes = min ( bytes , iov_iter_single_seg_count ( ii ) ) ; goto again ; } err = 0 ; req -> pages [ req -> num_pages ] = page ; req -> page_descs [ req -> num_pages ] . length = tmp ; req -> num_pages ++ ; <vul-start> iov_iter_advance ( ii ,",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <vul-start> num_pages ++ ; <vul-end> count += tmp\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> bytes ) ; <vul-end> if (! <vul-start> num_pages ++ ; flush_dcache_page ( page ) ;\n"
  },
  {
    "id": 332,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { \"invalid\" , \"rsasig\" , \"shared-secret\" , \"dsssig\" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <vul-start> ND_TCHECK ( * ext ) ; <vul-end> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , \" len=%u method=%s\" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \" authdata=(\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , \") \" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , \" [|%s]\"",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <vul-end> ) ; UNALIGNED_MEMCPY\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ND_TCHECK ( * ep <vul-end> ) ; UNALIGNED_MEMCPY\n"
  },
  {
    "id": 333,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( \"lxc.lxcpath\" ) ; if ( ! lxcpath ) { ERROR ( \"Out of memory\" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , \"%s/%s/rootfs\" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( \"ignoring mount point \\'%s\\'\" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , \"%s/%s\" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( \"pathnme too long for \\'%s\\'\" , mntent -> mnt_dir ) ; return - 1 ; } <vul-start> return mount_entry_on_generic ( mntent , path ) ; <vul-end> }",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> mntent , path , rootfs -> mount\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> mntent, path, rootfs\n"
  },
  {
    "id": 334,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( \"Downmix_Command command %\" PRIu32 \" cmdSize %\" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : <vul-start> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <vul-end> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <vul-start> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <vul-end> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( \"Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %\" PRIu32 \", pReplyData: %p\" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <vul-start> pReplyData == NULL || <vul-end> * replySize < ( int ) sizeof (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> == NULL || replySize == NULL || <vul-start> ) || pReplyData == NULL || replySize <vul-start> ) || pReplyData == NULL || replySize <vul-start> == NULL || replySize == NULL || <vul-start> == NULL || replySize == NULL || <vul-start> if ( pReplyData == NULL || replySize\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * replySize!= ( uint32_t ) <vul-start> effect_config_t ) || ( void * ) pCmdData ) == NULL || ( void * ) pReplyData == NULL || ( void * ) <vul-end> replySize!= sizeof <vul-start> ) ) || ( void * ) pReplyData == NULL || ( void * ) <vul-start> ( int32_t ) )\n"
  },
  {
    "id": 335,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> skb = skb_recv_datagram\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> skb = skb_recv_datagram\n"
  },
  {
    "id": 336,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <vul-start> if ( debug ) { <vul-end> printk ( KERN_INFO \"cx24116: %s(\" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO \"0x%02x\" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO \", \" ) ; } printk ( \") toneburst=%d\\\\n\" , toneburst ) ; } <vul-start> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <vul-end> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( \"%s burst=%d\\\\n\" , __func__",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <vul-start> ) ; } <vul-end> for ( i\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, ret ; u32 val ; <vul-start> ) ; } val = d -> msg [ 3 ] ; if ( val == 0 ) return - EINVAL ; <vul-start> - EINVAL ; if ( state -> dsec_cmd. args [ i ]!= val ) { pr_err ( \"%s: invalid DISEQ cmd length %u\\\\n\", __func__, state -> dsec_cmd. args [ i ] ) ; return - EINVAL ; }\n"
  },
  {
    "id": 337,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , \"EIGRP version %u packet not supported\" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"EIGRP %s, length: %u\" , tok2str ( eigrp_opcode_values , \"unknown (%u)\" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <vul-start> tlen = len - sizeof ( struct eigrp_common_header ) ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\\\\n\\\\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u\" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , \"unknown, type: %u\" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , \"none\" , EXTRACT_32BITS ( & eigrp_com_header",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , \"EIGRP %s, length: %u (too short, < %u)\" , tok2str ( eigrp_opcode_values , \"unknown (%u)\" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <vul-start> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) tlv_tptr ; ND_TCHECK_32BITS ( & tlv_ptr. eigrp_tlv_ext -> flags ) ; <vul-start> eigrp_tlv_ip_int -> plen ; ND_TCHECK_32BITS ( & tlv_ptr. eigrp_tlv_ip_int -> flags )\n"
  },
  {
    "id": 338,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <vul-start> if ( size_bmp > BMP_HEADER_SIZE ) { <vul-end> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( size_bmp >= <vul-end> BMP_HEADER_SIZE ) {\n"
  },
  {
    "id": 339,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <vul-start> switch ( pc -> componentType ) { <vul-end> case 1 : if ( pc -> lengthComponentIdent > 0 ) <vul-start> break ; <vul-end> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , \"../\" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , \"./\" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <vul-start> case 5 : <vul-end> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <vul-start> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <vul-end> } if ( p > to + 1 ) p [ -",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> elen ) ; elen += sizeof ( struct pathComponent ) ; <vul-start> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <vul-end> case 2 : <vul-start> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <vul-start> break ; } <vul-end> } if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> elen ) ; if ( tolen == 0 ) return - ENAMETOOLONG ; <vul-start> > 0 ) { if ( tolen == 1 ) return - ENAMETOOLONG ; memcpy ( p, \"../\", 3 ) ; p += 3 ; tolen -= 3 ; break ; } <vul-end> case 2 : <vul-start> case 5 : if ( tolen == 0 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 2 ) ; p += 2 ; tolen -= 2 ; break ; } elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; if ( p > to + 1 ) p [ - 1 ] = '\\\\0' ; else p [ 0 ] = '\\\\0' ; return 0 <vul-end> ; }  \n"
  },
  {
    "id": 340,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) { <vul-start> if ( refill_pi_state_cache ( ) ) <vul-end> return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) <vul-start> goto out_put_key1 ; <vul-end> hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <vul-start> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> { if ( <vul-end> nr_wake!= 1 <vul-start> ) goto out_put_key1 ; if ( refill_pi_state_cache ( ) ) return - ENOMEM\n"
  },
  {
    "id": 341,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 Datum hstore_from_record ( PG_FUNCTION_ARGS ) { HeapTupleHeader rec ; int32 buflen ; HStore * out ; Pairs * pairs ; Oid tupType ; int32 tupTypmod ; TupleDesc tupdesc ; HeapTupleData tuple ; RecordIOData * my_extra ; int ncolumns ; int i , j ; Datum * values ; bool * nulls ; if ( PG_ARGISNULL ( 0 ) ) { Oid argtype = get_fn_expr_argtype ( fcinfo -> flinfo , 0 ) ; tupType = argtype ; tupTypmod = - 1 ; rec = NULL ; } else { rec = PG_GETARG_HEAPTUPLEHEADER ( 0 ) ; tupType = HeapTupleHeaderGetTypeId ( rec ) ; tupTypmod = HeapTupleHeaderGetTypMod ( rec ) ; } tupdesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ; ncolumns = tupdesc -> natts ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; if ( my_extra == NULL || my_extra -> ncolumns != ncolumns ) { fcinfo -> flinfo -> fn_extra = MemoryContextAlloc ( fcinfo -> flinfo -> fn_mcxt , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; my_extra -> record_type = InvalidOid ; my_extra -> record_typmod = 0 ; } if ( my_extra -> record_type != tupType || my_extra -> record_typmod != tupTypmod ) { MemSet ( my_extra , 0 , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra -> record_type = tupType ; my_extra -> record_typmod = tupTypmod ; my_extra -> ncolumns = ncolumns ; }",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ncolumns ; } my_extra -> nextra = ncolumns ;\n"
  },
  {
    "id": 342,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc28j60ReceivePacket ( NetInterface * interface ) { error_t error ; <vul-start> uint16_t n ; <vul-end> uint16_t status ; <vul-start> Enc28j60Context * context ; <vul-end> context = ( Enc28j60Context * ) interface -> nicContext ; <vul-start> if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) ) <vul-end> { enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTL , LSB ( context -> nextPacket ) ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ; <vul-end> <vul-start> enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <vul-end> enc28j60ReadBuffer ( interface , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; enc28j60ReadBuffer ( interface , ( uint8_t * ) & status , sizeof ( uint16_t ) ) ; <vul-start> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <vul-end> { <vul-start> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <vul-end> <vul-start> enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ; <vul-end> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC28J60_RX_BUFFER_START ) { <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <vul-end> } else { <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ; <vul-end> } <vul-start> enc28j60SetBit ( interface , ENC28J60_REG_ECON2 ,",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> error ; uint16_t length <vul-end> ; uint16_t status <vul-start> uint16_t status ; uint8_t header [ 6 ] ; <vul-start> ( interface , ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERDPTH <vul-end> , MSB ( <vul-start> ( interface , header <vul-end> , sizeof ( <vul-start> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4 <vul-end> ) ; if <vul-start> ( status & ENC28J60_RSV_RECEIVED_OK <vul-end> ) != 0 <vul-start> 0 ) { length <vul-end> = MIN ( <vul-start> = MIN ( length <vul-end> , ETH_MAX_FRAME_SIZE ) <vul-start> -> rxBuffer , length <vul-end> ) ; error <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC <vul-end> ) ; } <vul-start> -> rxBuffer , length <vul-end> , & ancillary\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> error ; uint16_t next ; uint16_t <vul-start> Enc28j60Context * context ; uint16_t status ; uint16_t * data <vul-start> ( interface, ENC28J60_EPKTCNT ) ) { enc28j60WriteReg ( interface, ENC28J60_ERDPTL <vul-end>, LSB ( <vul-start> ( interface, ENC28J60_ERDPTH <vul-end>, MSB ( <vul-start> ( interface, ENC28J60_TCTS <vul-end>, sizeof ( <vul-start> ; if ( enc28j60ReadReg ( interface, ENC28J60_TCTS <vul-end> )!= 0 <vul-start> 0 ) { data <vul-end> = MIN ( <vul-start> -> rxBuffer, data <vul-end> ) ; error <vul-start> ( interface, ENC28J60_ERXRDPTL <vul-end>, LSB ( <vul-start> ( interface, ENC28J60_ERXRDPTH <vul-end>, MSB ( <vul-start> ( interface, ENC28J60_ECON2, ENC28J60_ECON2_PKTDE ) ; } else { enc28j60WriteReg ( interface, ENC28J60_ERXRDPTL, LSB ( context -> nextPacket - 1 ) ) ; enc28j60WriteReg ( interface, ENC28J60_ECON2, ENC28J60_ECON2_PKTDE ) ; } } else { enc28j60WriteReg ( interface, ENC28J60_ERXRDPTL, LSB ( context -> nextPacket - 1 ) ) ; enc28j60WriteReg ( interface, ENC28J60_ECON2, ENC28J60_ECON2_PKTDE ) ; } <vul-end> } else { <vul-start> ( interface, ENC28J60_ECON2, ENC28J60_ECON2_PKTDE <vul-end> ) ; }\n"
  },
  {
    "id": 343,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , \"Now seen %d relay cells here (command %d, stream %d).\" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay cell length field too long. Closing circuit.\" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay command %d with zero \" \"stream_id. Dropping.\" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ;",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> } if (! layer_hint &&\n"
  },
  {
    "id": 344,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , \"PACK\" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <vul-start> * head = NULL ; <vul-end> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , \"ACK\" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , \"NAK\" ) ) ret = nak_pkt",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , \"Invalid empty packet\" ) ; return GIT_ERROR <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> PKT_LEN_SIZE ) { if ( * head!= NULL )\n"
  },
  {
    "id": 345,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void dhcpClientProcessMessage ( NetInterface * interface , const IpPseudoHeader * pseudoHeader , const UdpHeader * udpHeader , const NetBuffer * buffer , size_t offset , const NetRxAncillary * ancillary , void * param ) { size_t length ; DhcpClientContext * context ; DhcpMessage * message ; DhcpOption * option ; context = ( DhcpClientContext * ) param ; length = netBufferGetLength ( buffer ) - offset ; <vul-start> if ( length < sizeof ( DhcpMessage ) ) <vul-end> return ; if ( length > DHCP_MAX_MSG_SIZE ) return ; message = netBufferAt ( buffer , offset ) ; if ( message == NULL ) return ; TRACE_DEBUG ( \"\\\\r\\\\n%s: DHCP message received (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , formatSystemTime ( osGetSystemTime ( ) , NULL ) , length ) ; dhcpDumpMessage ( message , length ) ; if ( message -> op != DHCP_OPCODE_BOOTREPLY ) return ; if ( message -> htype != DHCP_HARDWARE_TYPE_ETH ) return ; if ( message -> hlen != sizeof ( MacAddr ) ) return ; if ( message -> magicCookie != HTONL ( DHCP_MAGIC_COOKIE ) ) return ; option = dhcpGetOption ( message , length , DHCP_OPT_DHCP_MESSAGE_TYPE ) ; if ( option == NULL || option -> length != 1 ) return ; switch ( option -> value [ 0 ] ) { case DHCP_MESSAGE_TYPE_OFFER : dhcpClientParseOffer ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_ACK : dhcpClientParseAck ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_NAK : dhcpClientParseNak ( context , message , length ) ; break ; default : break ; } }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( DhcpMessage ) || <vul-end> length > DHCP_MAX_MSG_SIZE\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( length < offset || length > DHCP_MAX_MSG_SIZE || length < <vul-start> ( DhcpMessage ) <vul-end> ) return ;\n"
  },
  {
    "id": 346,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( \"Entering request loop!\\\\n\" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( \"%d: \" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , \"Disconnect request received.\" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( \"Not enough magic.\" ) ; <vul-start> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <vul-end> err ( \"Request too big!\" ) ; # ifdef DODBG printf ( \"%s from %llu (%llu) len %d, \" , request .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> len > BUFSIZE - <vul-end> sizeof ( struct\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( len > ( size_t )\n"
  },
  {
    "id": 347,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait ) <vul-end> { struct nfs4_state_owner * owner = state -> owner ; int call_close = 0 ; <vul-start> int newstate ; <vul-end> atomic_inc ( & owner -> so_count ) ; spin_lock ( & owner -> so_lock ) ; <vul-start> switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) { <vul-end> case FMODE_READ : state -> n_rdonly -- ; break ; case FMODE_WRITE : state -> n_wronly -- ; break ; case FMODE_READ | FMODE_WRITE : state -> n_rdwr -- ; } newstate = FMODE_READ | FMODE_WRITE ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { newstate &= ~ FMODE_READ ; call_close |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { newstate &= ~ FMODE_WRITE ; call_close |= test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( newstate == 0 ) clear_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } nfs4_state_set_mode_locked ( state , newstate ) ; spin_unlock ( & owner -> so_lock ) ; if ( ! call_close ) { nfs4_put_open_state ( state ) ; nfs4_put_state_owner ( owner ) ; } else nfs4_do_close ( path , state , wait ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> * state , fmode_t fmode <vul-end> , int wait <vul-start> = 0 ; fmode_t <vul-end> newstate ; atomic_inc <vul-start> ; switch ( fmode <vul-end> & ( FMODE_READ\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * state, fmode_t fmode <vul-end>, int wait <vul-start> ; int newstate ; fmode_t newfmode <vul-start> ; switch ( fmode <vul-end> ) { case\n"
  },
  {
    "id": 348,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_tread tread ; memset ( & tread, 0, sizeof ( tread ) ) ;\n"
  },
  {
    "id": 349,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( sk -> sk_user_data!= NULL &&\n"
  },
  {
    "id": 350,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , \"invalid len\" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_origin_values , \"Unknown Origin Typecode\" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , \"invalid len\" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , \"empty\" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_as_path_segment_open_values , <vul-start> \"?\" , tptr [ 0 ] ) ) ) ; <vul-end> for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( bgp_as_path_segment_open_values, \"Unknown Path segment\" <vul-end>, tptr [\n"
  },
  {
    "id": 351,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) <vul-start> return chg ; <vul-end> if ( hugepage_subpool_get_pages ( spool , chg ) ) <vul-start> return - ENOSPC ; <vul-end> <vul-start> ret = hugetlb_acct_memory ( h , chg ) ; <vul-end> if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; <vul-start> return ret ; <vul-end> } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> < 0 ) { ret = chg ; goto out_err ; } <vul-end> if ( hugepage_subpool_get_pages <vul-start> chg ) ) { ret = <vul-end> - ENOSPC ; <vul-start> - ENOSPC ; goto out_err ; } <vul-start> chg ) ; goto out_err <vul-end> ; } if <vul-start> return 0 ; out_err : resv_map_put ( vma ) ; return ret ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> < 0 ) goto err_put_pages <vul-end> ; if ( <vul-start> chg ) ) goto err_put_pages <vul-end> ; ret = <vul-start> h, chg, chg, spool <vul-start> chg ) ; goto err_put_pages <vul-end> ; } if <vul-start> return 0 ; err_put_pages : hugepage_subpool_put_pages ( spool, chg ) ; return ret ;\n"
  },
  {
    "id": 352,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv , <vul-end> int_mv * dst_mv , int mb_row , int mb_col ) { <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err , tmp_err ; <vul-start> int_mv tmp_mv ; <vul-end> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <vul-start> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <vul-end> INT_MAX ) ; dst_mv -> as_int = 0 ; <vul-start> tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv , <vul-end> mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_int = tmp_mv . as_int ; } if ( ref_mv -> as_int ) { unsigned int tmp_err ; int_mv zero_ref_mv , tmp_mv ; zero_ref_mv . as_int = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv . as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_int = tmp_mv . as_int ; err = tmp_err ; } } return err ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cpi , const MV * ref_mv , int_mv * <vul-end> dst_mv , int <vul-start> & cpi -> td . <vul-start> , tmp_err ; MV tmp_mv ; err = vpx_sad16x16 <vul-end> ( x -> <vul-start> ] . stride <vul-end> ) ; dst_mv <vul-start> ( cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <vul-end> ; err =\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, MACROBLOCK * const x, <vul-start> mb_col ) { <vul-end> unsigned int err <vul-start>, tmp_err ; const int_mv * const pre = xd -> plane [ 0 ]. pre [ 0 ] ; const int_mv tmp_mv ; const int pre_idx = xd -> plane [ 0 ]. pre [ 0 ] -> stride ; const int_mv * const post = xd -> plane [ 0 ]. pre [ 0 ] -> buf ; const int_mv * const post_mv = xd -> plane [ 0 ]. pre [ 0 ] -> stride ; err = vpx_sad16x16 ( x -> plane [ 0 ]. src. buf, x -> plane [ 0 ]. src. stride, pre -> buf, pre -> stride <vul-end> ) ; dst_mv <vul-start> ( cpi, & ref_mv -> as_mv, & tmp_mv. as_mv, <vul-end> mb_row, mb_col\n"
  },
  {
    "id": 353,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t tcpSendResetSegment ( NetInterface * interface , IpPseudoHeader * pseudoHeader , TcpHeader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqNum ; uint32_t ackNum ; NetBuffer * buffer ; TcpHeader * segment2 ; IpPseudoHeader pseudoHeader2 ; NetTxAncillary ancillary ; if ( segment -> flags & TCP_FLAG_ACK ) { flags = TCP_FLAG_RST ; seqNum = segment -> ackNum ; ackNum = 0 ; } else { flags = TCP_FLAG_RST | TCP_FLAG_ACK ; seqNum = 0 ; ackNum = segment -> seqNum + length ; if ( segment -> flags & TCP_FLAG_SYN ) <vul-start> ackNum ++ ; <vul-end> <vul-start> if ( segment -> flags & TCP_FLAG_FIN ) <vul-end> <vul-start> ackNum ++ ; <vul-end> } buffer = ipAllocBuffer ( sizeof ( TcpHeader ) , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; segment2 = netBufferAt ( buffer , offset ) ; segment2 -> srcPort = htons ( segment -> destPort ) ; segment2 -> destPort = htons ( segment -> srcPort ) ; segment2 -> seqNum = htonl ( seqNum ) ; segment2 -> ackNum = htonl ( ackNum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataOffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentPointer = 0 ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader2 . ipv4Data",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> & TCP_FLAG_SYN ) { <vul-start> ackNum ++ ; } <vul-start> & TCP_FLAG_FIN ) { <vul-start> ackNum ++ ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> & TCP_FLAG_SYN ) { if ( ackNum > length ) { return ERROR_OUT_OF_MEMORY ; } <vul-start> ackNum ++ ; } <vul-start> & TCP_FLAG_FIN ) { if ( ackNum > length ) { return ERROR_OUT_OF_MEMORY ; } <vul-start> ackNum ++ ; }\n"
  },
  {
    "id": 354,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { <vul-start> struct snd_timer_user * tu ; <vul-end> void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ; <vul-start> switch ( cmd ) { <vul-end> case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ; <vul-start> mutex_lock ( & tu -> tread_sem ) ; <vul-end> if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ; <vul-start> mutex_unlock ( & tu -> tread_sem ) ; <vul-end> <vul-start> return 0 ; <vul-end> } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> snd_timer_user * tu <vul-end> = file -> <vul-start> -> private_data ; long ret <vul-end> ; mutex_lock ( <vul-start> & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <vul-end> ; mutex_unlock ( <vul-start> & tu -> ioctl_lock <vul-end> ) ; return <vul-start> ) ; return ret <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> arg ) { return snd_timer_user_user_ioctl ( file, cmd <vul-end>, argp ) <vul-start> -> private_data ; <vul-end> }    \n"
  },
  {
    "id": 355,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void monitor_apply_keystate ( struct monitor * pmonitor ) { struct ssh * ssh = active_state ; struct kex * kex ; int r ; debug3 ( \"%s: packet_set_state\" , __func__ ) ; if ( ( r = ssh_packet_set_state ( ssh , child_state ) ) != 0 ) fatal ( \"%s: packet_set_state: %s\" , __func__ , ssh_err ( r ) ) ; sshbuf_free ( child_state ) ; child_state = NULL ; if ( ( kex = ssh -> kex ) != NULL ) { # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; } <vul-start> if ( options . compression ) { <vul-end> ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> sshd_hostkey_sign ; } <vul-end> }    \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } if ( pmonitor -> m_zlib ) { if ( <vul-start> options. compression!= NULL ) <vul-end> { ssh_packet_set_compress_hooks ( <vul-start> } } } }\n"
  },
  {
    "id": 356,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , \"RA: %s, dev: %s\\\\n\" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , \"RA: source address is not link-local\\\\n\" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , \"RA: packet too short\\\\n\" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , \"RA: from host or unauthorized router\\\\n\" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , \"RA: can\\'t find inet6 device for %s\\\\n\" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , \"RA: invalid",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> icmp6_hop_limit ) { if ( <vul-start> cnf . hop_limit < <vul-end> ra_msg -> icmph <vul-start> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , \"RA: Got route advertisement with lower hop_limit than current\\\\n\" ) ; } <vul-end> if ( rt\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> icmp6_hop_limit ) { if ( rt ) dst_metric_set ( & rt -> dst, RTAX_HOPLIMIT, ra_msg -> icmph. icmp6_hop_limit ) ; else\n"
  },
  {
    "id": 357,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> . val = ! ! <vul-start> -> flags ) <vul-end> ; break ; <vul-start> . val = ! ! <vul-start> -> flags ) <vul-end> ; break ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. val = sk -> sk_type == SOCK_STREAM <vul-end>? 1 : <vul-start>. val = sk -> sk_type == SOCK_STREAM <vul-end>? 1 :\n"
  },
  {
    "id": 358,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , struct udphdr * uh ) { struct udp_offload_priv * uo_priv ; struct sk_buff * p , * * pp = NULL ; struct udphdr * uh2 ; unsigned int off = skb_gro_offset ( skb ) ; int flush = 1 ; <vul-start> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <vul-end> ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ; <vul-start> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <vul-end> rcu_read_lock ( ) ; uo_priv = rcu_dereference ( udp_offload_base ) ; for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_receive ) goto unflush ; } goto out_unlock ; unflush : flush = 0 ; for ( p = * head ; p ; p = p -> next ) { if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; uh2 = ( struct udphdr * ) ( p -> data + off ) ; if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || ( ! uh -> check ^ ! uh2 -> check )",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark <vul-end> || ( skb <vul-start> skb ) -> encap_mark <vul-end> = 1 ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; if ( skb_is_gso ( skb ) || <vul-start> goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ;\n"
  },
  {
    "id": 359,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> MB_PREDICTION_MODE mode ; <vul-end> MB_PREDICTION_MODE mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , this_rd ; int this_rate_tokenonly , this_rate , s ; <vul-start> int64_t this_distortion , this_sse ; <vul-end> for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ; xd -> mi [ 0 ] -> mbmi . uv_mode = mode ; <vul-start> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <vul-end> <vul-start> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <vul-end> if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + <vul-start> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <vul-end> this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; <vul-start> if ( ! x -> select_txfm_size ) { <vul-end> int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <vul-end> mode_selected = DC_PRED <vul-start> this_distortion , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <vul-start> = mode ; if ( ! <vul-start> , best_rd ) <vul-end> ) continue ; <vul-start> = this_rate_tokenonly + cpi <vul-end> -> intra_uv_mode_cost [ <vul-start> ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <vul-end> } } xd\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <vul-end> mode_selected = DC_PRED <vul-start>, s ; PREDICTION_MODE <vul-end> this_distortion, this_sse <vul-start> = mode ; if (! x -> select_txfm_size ) { int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; <vul-start>, & this_sse, & this_rate, & this_distortion, & s, & this_sse, bsize, best_rd ) ; } else { this_rate = this_rate_tokenonly ; this_distortion = this_sse ; } <vul-end> for ( mode <vul-start> = this_rate_tokenonly + xd <vul-end> -> intra_uv_mode_cost [ <vul-start> [ mode ] <vul-end> ; if ( <vul-start> ; if ( <vul-end> this_rd < best_rd <vul-start> best_rd ) { <vul-end> * rate = <vul-start> this_rd ; * rate_tokenonly = this_rate_tokenonly ; * rate_tokenonly = this_rate_tokenonly ; * skippable = s ; } else { this_rd = INT64_MAX ; this_rd = this_rate_tokenonly + x -> intra_uv_mode_cost [ cpi -> common. frame_type ] [ mode ] ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; } else { this_rd = INT64_MAX ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * rate_tokenonly = this_rate_tokenonly ; * rate_tokenonly = this_rate_tokenonly ; * skippable = s ; } <vul-end> } xd ->\n"
  },
  {
    "id": 360,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> static int read_fragment_table ( long long * directory_table_end ) <vul-end> { int res , i ; <vul-start> int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ; <vul-end> <vul-start> int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ; <vul-end> long long fragment_table_index [ indexes ] ; TRACE ( \"read_fragment_table: %d fragments, reading %d fragment indexes \" \"from 0x%llx\\\\n\" , sBlk . s . fragments , indexes , sBlk . s . fragment_table_start ) ; <vul-start> if ( sBlk . s . fragments == 0 ) { <vul-end> * directory_table_end = sBlk . s . fragment_table_start ; return TRUE ; } fragment_table = malloc ( bytes ) ; if ( fragment_table == NULL ) EXIT_UNSQUASH ( \"read_fragment_table: failed to allocate \" \"fragment table\\\\n\" ) ; res = read_fs_bytes ( fd , sBlk . s . fragment_table_start , <vul-start> SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) , <vul-end> fragment_table_index ) ; if ( res == FALSE ) { ERROR ( \"read_fragment_table: failed to read fragment table \" \"index\\\\n\" ) ; return FALSE ; } SQUASHFS_INSWAP_FRAGMENT_INDEXES ( fragment_table_index , indexes ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , fragment_table_index [ i ] , NULL , expected , ( ( char * ) fragment_table ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( \"Read fragment table block %d, from 0x%llx, length %d\\\\n\" , i",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> long long * table_start <vul-end> ) { int <vul-start> , i ; long long <vul-end> bytes = SQUASHFS_FRAGMENT_BYTES <vul-start> = SQUASHFS_FRAGMENT_BYTES ( ( long long ) <vul-start> = SQUASHFS_FRAGMENT_INDEXES ( ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( \"read_fragment_table: Bad fragment count in super block\\\\n\" ) ; return FALSE ; } <vul-end> TRACE ( \"read_fragment_table: %d fragments, reading %d fragment indexes \" <vul-start> fragment_table_start ) ; fragment_table_index = alloc_index_table ( indexes ) ; <vul-end> fragment_table = malloc <vul-start> . fragment_table_start , length <vul-end> , fragment_table_index ) <vul-start> ) ; * table_start <vul-end> = fragment_table_index [\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> int read_fragment_table ( struct s_hash_block * s_hash_block, <vul-start> = SQUASHFS_FRAGMENT_BYTES ( s_hash_block -> s. <vul-end> fragments ) ; <vul-start> = SQUASHFS_FRAGMENT_INDEXES ( s_hash_block -> s. <vul-end> fragments ) ; <vul-start> ; if ( s_hash_block -> s. <vul-end> fragment_table_end == NULL <vul-start>. fragment_table_start, s_hash_block -> s. <vul-end> fragment_table_index ) ;\n"
  },
  {
    "id": 361,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ras_getcmap ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap ) { int i ; int j ; int x ; int c ; int numcolors ; int actualnumcolors ; switch ( hdr -> maptype ) { case RAS_MT_NONE : break ; case RAS_MT_EQUALRGB : { jas_eprintf ( \"warning: palettized images not fully supported\\\\n\" ) ; numcolors = 1 << hdr -> depth ; <vul-start> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <vul-end> actualnumcolors = hdr -> maplength / 3 ; for ( i = 0 ; i < numcolors ; i ++ ) { cmap -> data [ i ] = 0 ; } if ( ( hdr -> maplength % 3 ) || hdr -> maplength < 0 || hdr -> maplength > 3 * numcolors ) { return - 1 ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < actualnumcolors ; j ++ ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } x = 0 ; switch ( i ) { case 0 : x = RAS_RED ( c ) ; break ; case 1 : x = RAS_GREEN ( c ) ; break ; case 2 : x = RAS_BLUE ( c ) ; break ; } cmap -> data [ j ] |= x ; } } } break ; default : return - 1 ; break ; } return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <vul-end> actualnumcolors = hdr\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> depth ; if ( numcolors > RAS_MAP_MAXSIZ ) { return - 1 ; } <vul-end> actualnumcolors = hdr\n"
  },
  {
    "id": 362,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; <vul-start> if ( img ) <vul-end> <vul-start> res = validate_img ( ctx , img ) ; <vul-end> pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = \"Conflicting flags.\" ; return VPX_CODEC_INVALID_PARAM ; } <vul-start> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | <vul-end> VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = VPX_CODEC_OK ; VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <vul-start> if ( img != NULL ) { <vul-end> res = validate_img <vul-start> img ) ; if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <vul-start> VPX_CODEC_INVALID_PARAM ; } vp9_apply_encoding_flags ( cpi , flags ) ; <vul-end> if ( ctx <vul-start> == VPX_CODEC_OK && <vul-end> cpi != NULL <vul-start> unsigned int lib_flags = 0 <vul-start> ; int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <vul-end> ; size_t size <vul-start> & VPX_CODEC_USE_PSNR ) cpi <vul-end> -> b_calculate_psnr = <vul-start> b_calculate_psnr = 1 <vul-end> ; if ( <vul-start> ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags <vul-end> , & sd <vul-start> ) ) { <vul-end> res = update_error_state <vul-start> ) ; } ctx -> next_frame_flags = 0 ; <vul-start> ctx -> cx_data_sz <vul-end> ; if ( <vul-start> != vp9_get_compressed_data ( <vul-end> cpi , & <vul-start> size ) { <vul-end> vpx_codec_cx_pkt_t pkt ; <vul-start> vpx_codec_cx_pkt_t pkt ; # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <vul-end> cpi -> common <vul-start> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <vul-end> ) { if <vul-start> -= size ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <vul-end> dst_end_time_stamp - dst_time_stamp <vul-start> ; pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <vul-start> . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) <vul-end> ; pkt . <vul-start> unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <vul-end> ) ; pkt <vul-start> . flags = get_frame_pkt_flags ( cpi , lib_flags ) <vul-end> ; if ( <vul-start> += size ; if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <vul-start> - 1 ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <vul-start> -= size ; # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = VX_CODEX_OK ; int rc = 0 ; <vul-start> ctx, img ) ; if ( res == VPX_CODEX_INCAPABLE ) return VPX_CODEX_INCAPABLE ; rc = vp9_get_compressed_data ( ctx -> cpi, & ctx -> cfg, & ctx -> cfg, & ctx -> pending_cx_data, ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_data_sz, & ctx -> pending_cx_"
  },
  {
    "id": 363,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else {",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> slow ) ; cond_resched ( ) <vul-end> ; msg ->\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> slow ) ; cond_resched ( ) <vul-end> ; msg ->\n"
  },
  {
    "id": 364,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <vul-start> ctx -> clockid = clockid ; <vul-end> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( \"[timerfd]\" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> wqh ) ; spin_lock_init ( & ctx -> lock ) ;\n"
  },
  {
    "id": 365,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <vul-start> struct mount * child , * p ; <vul-end> struct hlist_node * n ; int err ; <vul-start> if ( IS_MNT_SHARED ( dest_mnt ) ) { <vul-end> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <vul-start> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <vul-end> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <vul-start> umount_tree ( child",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <vul-start> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <vul-end> ) ; if <vul-start> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <vul-start> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <vul-start> ; out : ns -> pending_mounts = 0 ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <vul-start> int err ; lock_mount_hash ( ) ; <vul-start> goto out ; if (! user_ns_capable ( user_ns ) ) { err = - EPERM ; goto out ; } <vul-start> mnt_hash ) ; if (! user_ns_capable ( user_ns ) ) { unlock_mount_hash ( ) ; err = - EPERM ; goto out ; }\n"
  },
  {
    "id": 366,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; <vul-start> unsigned int maxfraglen , fragheaderlen ; <vul-end> int exthdrlen ; int dst_exthdrlen ; <vul-start> int hh_len ; <vul-end> int mtu ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ;",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> maxfraglen , fragheaderlen , mtu <vul-start> ; int hh_len <vul-end> ; int copy <vul-start> skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; unsigned int fragheaderlen, mtu <vul-start> ; int hh_len <vul-end> ; int copy <vul-start>, & maxfraglen <vul-end>, fragheaderlen, <vul-start>, fragheaderlen, mtu <vul-end>, rt )\n"
  },
  {
    "id": 367,
    "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <vul-start> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <vul-end> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( \"%s is not a valid .CAF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( \"%s: can\\'t handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( \"%s is not a valid .CAF file!\"",
    "golden_answers": [
      "CWE-665 Fixed Code Lines are: <vul-start> { uint32_t chan_chunk = 0 , desc_chunk <vul-start> , CAFAudioFormatFormat ) ; desc_chunk = 1 <vul-start> if ( ! desc_chunk || !\n"
    ],
    "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> config ) { int64_t <vul-end> chan_chunk = 0 <vul-start> CAFAudioFormatFormat ) ; if (! config -> num_channels ) { error_line ( \"%s is not a valid.CAF file!\", infilename ) ; return WAVPACK_SOFT_ERROR ; }\n"
  },
  {
    "id": 368,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <vul-end> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ; const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ; const int c0123 = c01 + c23 ; const int c4567 = c45 + c67 ; int cost = c0123 * vp9_cost_zero ( probs [ 0 ] ) + c4567 * vp9_cost_one ( probs [ 0 ] ) ; if ( c0123 > 0 ) { cost += c01 * vp9_cost_zero ( probs [ 1 ] ) + c23 * vp9_cost_one ( probs [ 1 ] ) ; if ( c01 > 0 ) cost += segcounts [ 0 ] * vp9_cost_zero ( probs [ 3 ] ) + segcounts [ 1 ] * vp9_cost_one ( probs [ 3 ] ) ; if ( c23 > 0 ) cost += segcounts [ 2 ] * vp9_cost_zero ( probs [ 4 ] ) + segcounts [ 3 ] * vp9_cost_one ( probs [ 4 ] ) ; } if ( c4567 > 0 ) { cost += c45 * vp9_cost_zero ( probs [ 2 ] ) + c67 * vp9_cost_one ( probs [ 2 ] ) ; if ( c45 > 0 ) cost += segcounts [ 4 ] * vp9_cost_zero ( probs [ 5 ] ) + segcounts [ 5 ] * vp9_cost_one (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * segcounts , vpx_prob <vul-end> * probs )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * segcounts, vpx_prob <vul-end> * probs )\n"
  },
  {
    "id": 369,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void accumulate_frame_motion_stats ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame , double * this_frame_mv_in_out , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ; <vul-start> motion_pct = this_frame -> pcnt_motion ; <vul-end> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; if ( motion_pct > 0.05 ) { this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ; * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> double motion_pct ; ( void ) cpi ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> this_frame -> pcnt_motion ; ( void ) cpi\n"
  },
  {
    "id": 370,
    "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) { <vul-start> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <vul-end> if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }",
    "golden_answers": [
      "CWE-674 Fixed Code Lines are: <vul-start> , & len , 0\n"
    ],
    "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start>, & len, 0\n"
  },
  {
    "id": 371,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void fadst16_8col ( __m128i * in ) { <vul-end> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> = _mm_set1_epi16 ( ( int16_t ) <vul-start> = _mm_set1_epi16 ( ( int16_t )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> = _mm_set1_epi16 ( ( int16_t ) <vul-start> = _mm_set1_epi16 ( ( int16_t )\n"
  },
  {
    "id": 372,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int try_read_command_binary ( conn * c ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { memcpy ( & c -> binary_header , c -> rcurr , sizeof ( c -> binary_header ) ) ; protocol_binary_request_header * req ; req = & c -> binary_header ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , \"\\\\n<%d \" , c -> sfd ) ; } fprintf ( stderr , \" 0x%02x\" , req -> bytes [ ii ] ) ; } fprintf ( stderr , \"\\\\n\" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , \"Invalid magic: %x\\\\n\" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } uint8_t extlen = c -> binary_header",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> ) + BIN_MAX_EXTLEN + 1 <vul-start> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> = current_time ; c -> rbytes -= <vul-end> sizeof ( c <vul-start> binary_header ) + c -> binary_header. request. extlen + keylen ; c -> rcurr += <vul-end> sizeof ( c <vul-start> binary_header ), c -> rbytes <vul-end> ) ; }\n"
  },
  {
    "id": 373,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <vul-start> ut32 len = sec -> payload_len ; <vul-end> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <vul-start> while ( i < len && r < count ) { <vul-end> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <vul-start> i < len && len < buflen <vul-start> ) ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach <vul-end> ; } ut32 <vul-start> return ret ; beach : free ( ptr ) ; return ret ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> payload_data ; if (! buf ) { return NULL ; } <vul-start> r < count + ( ut32 ) sec -> payload_len <vul-start> ) ) { goto bail <vul-end> ; } if <vul-start> ) ) { goto bail <vul-end> ; } if <vul-start> ) ) { goto bail <vul-end> ; } if <vul-start> ) ) { goto bail <vul-end> ; } ut32 <vul-start> return ret ; bail : free ( ptr ) ; return ret ;\n"
  },
  {
    "id": 374,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  },
  {
    "id": 375,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , buffer [ 257 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , buffer ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer ,",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; <vul-start> \"MemoryAllocationFailed\" ) ; }\n"
  },
  {
    "id": 376,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { <vul-start> uchar magicbuf [ MIF_MAGICLEN ] ; <vul-end> char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( \"error: bad signature\\\\n\" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( \"mif_getline failed\\\\n\" ) ; goto error ; } if ( buf [ 0 ] == '\\\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( \"header line: len=%d; %s\\\\n\" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( \"jas_tvparser_create failed\\\\n\" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( \"cannot get record type\\\\n\" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> in ) { jas_uchar <vul-end> magicbuf [ MIF_MAGICLEN\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> in ) { jas_uchar <vul-end> magicbuf [ MIF_MAGICLEN\n"
  },
  {
    "id": 377,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( \"\" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <vul-start> dl = kmalloc ( size , GFP_KERNEL ) ; <vul-end> if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof (",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; dl = kzalloc <vul-end> ( size ,\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; dl = kzalloc <vul-end> ( size,\n"
  },
  {
    "id": 378,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void otp_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_keyblock * armor_key = NULL ; krb5_pa_otp_req * req = NULL ; struct request_state * rs ; krb5_error_code retval ; krb5_data d , plaintext ; char * config ; <vul-start> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; <vul-end> armor_key = cb -> fast_armor ( context , rock ) ; if ( armor_key == NULL ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; com_err ( \"otp\" , retval , \"No armor key found when verifying padata\" ) ; goto error ; } d = make_data ( pa -> contents , pa -> length ) ; retval = decode_krb5_pa_otp_req ( & d , & req ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to decode OTP request\" ) ; goto error ; } retval = decrypt_encdata ( context , armor_key , req , & plaintext ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to decrypt nonce\" ) ; goto error ; } retval = nonce_verify ( context , armor_key , & plaintext ) ; if ( retval != 0 ) retval = timestamp_verify ( context , & plaintext ) ; krb5_free_data_contents ( context , & plaintext ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to verify nonce or timestamp\" ) ; goto error ; } rs",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> * config ; <vul-end> armor_key = cb <vul-start> respond = respond ; rs -> enc_tkt_reply = enc_tkt_reply\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * config ; int pre_auth = 0 ; <vul-start> |= TKT_FLG_PRE_AUTH ; if ( enc_tkt_reply -> flags & TKT_FLG_PRE_AUTH ) { pre_auth = 1 ; } <vul-start> = arg ; if ( enc_tkt_reply -> flags & TKT_FLG_PRE_AUTH ) { <vul-start> = respond ; } <vul-start> ; error : if ( pre_auth ) { enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; }\n"
  },
  {
    "id": 379,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static MYSQL * db_connect ( char * host , char * database , char * user , char * passwd ) { MYSQL * mysql ; if ( verbose ) fprintf ( stdout , \"Connecting to %s\\\\n\" , host ? host : \"localhost\" ) ; if ( ! ( mysql = mysql_init ( NULL ) ) ) return 0 ; if ( opt_compress ) mysql_options ( mysql , MYSQL_OPT_COMPRESS , NullS ) ; if ( opt_local_file ) mysql_options ( mysql , MYSQL_OPT_LOCAL_INFILE , ( char * ) & opt_local_file ) ; <vul-start> # ifdef HAVE_OPENSSL <vul-end> if ( opt_use_ssl ) { mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( mysql , MYSQL_OPT_CONNECT_ATTR_ADD ,",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ; <vul-end> if ( opt_protocol\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> opt_local_file ) ; SSL_SET ( mysql ) ; <vul-end> if ( opt_protocol\n"
  },
  {
    "id": 380,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) { struct iso9660 * iso9660 ; struct isoent * np ; unsigned char * p ; size_t l ; int r ; <vul-start> int ffmax , parent_len ; <vul-end> static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ; if ( isoent -> children . cnt == 0 ) return ( 0 ) ; iso9660 = a -> format_data ; if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) ffmax = 206 ; else ffmax = 128 ; <vul-start> r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <vul-end> if ( r < 0 ) return ( r ) ; parent_len = 1 ; for ( np = isoent ; np -> parent != np ; np = np -> parent ) parent_len += np -> mb_len + 1 ; for ( np = isoent -> children . first ; np != NULL ; np = np -> chnext ) { unsigned char * dot ; int ext_off , noff , weight ; size_t lt ; <vul-start> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) <vul-end> l = ffmax ; p = malloc ( ( l + 1 ) * 2 ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t allocate memory\" ) ; return ( ARCHIVE_FATAL",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> int r ; size_t <vul-end> ffmax , parent_len <vul-start> . cnt , ( int ) <vul-start> if ( ( <vul-end> l = np <vul-start> ; if ( <vul-end> np -> file <vul-start> if ( parent_len > 240 || <vul-end> np -> mb_len <vul-start> mb_len > 240 || parent_len + np -> mb_len > 240 <vul-start> } if ( <vul-end> l == ffmax <vul-start> else if ( <vul-end> l == ffmax <vul-start> else if ( <vul-end> l == ffmax\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ffmax, parent_len, has_idr <vul-start>. cnt, <vul-end> 6, 2 <vul-start> size_t lt ; has_idr = ( int ) ( np -> file -> basename_utf16. length ) > ffmax ; <vul-start>. length > has_idr <vul-end> ) { if <vul-start> ) l == has_idr <vul-end> ) noff = <vul-start> ) l == has_idr <vul-end> - 2 ) <vul-start>. length > has_idr <vul-end> - 4 )\n"
  },
  {
    "id": 381,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <vul-start> bool disconnect ; <vul-end> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; <vul-start> __touch_mnt_namespace ( p -> mnt_ns ) ; <vul-end> p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = disconnect_mount ( p , how ) ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; }",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ) ) { struct mnt_namespace * ns ; <vul-start> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <vul-end> p -> mnt_ns\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) ) { int disconnect ; struct user_namespace * user_ns = p -> mnt_ns ; bool disconnect <vul-end> ; p = <vul-start> mnt_list ) ; user_ns = NULL ; if (! user_ns_capable ( user_ns ) ) user_ns = NULL ; list_add_tail ( & p -> mnt_child, & user_ns -> mnt_mounts ) ; p -> mnt_ns = user_ns ; if (! disconnect ) disconnect = disconnect_mount ( p, MS_PRIVATE ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent, - 1 ) ; if (! disconnect ) { list_add_tail ( & p -> mnt_child, & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p, MS_PRIVATE ) ; } } if (! disconnect ) { list_del_init ( & p -> mnt_child ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if (! user_ns_capable ( user_ns ) ) user_ns = NULL ; if (! disconnect ) { list_add_tail ( & p -> mnt_child, & p -> mnt_parent -> mnt, disconnect? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent, - 1 ) ; if (! disconnect ) { list_add_tail ( & p -> mnt_child, & p -> mnt_parent -> mnts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p, MS_PRIVATE ) ; } } change_mnt_parent ( p, MS_PRIVATE ) ; } } if (! disconnect ) { mnt_add_count ( p -> mnt_parent, - 1 ) ; if (! disconnect ) { list_add_tail ( & p -> mnt_ns, & p -> mnt_parent -> mnt"
  },
  {
    "id": 382,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void tree_to_node ( void * data , BLOCK_SIZE bsize , variance_node * node ) { int i ; <vul-start> switch ( bsize ) { <vul-end> case BLOCK_64X64 : { v64x64 * vt = ( v64x64 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_32X32 : { v32x32 * vt = ( v32x32 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_16X16 : { v16x16 * vt = ( v16x16 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_8X8 : { v8x8 * vt = ( v8x8 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) <vul-start> node -> split [ i ] = & vt -> split [ i ] ; <vul-end> break ; } default : { assert ( 0 ) ; <vul-start>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int i ; node -> part_variances = NULL ; <vul-start> [ i ] . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] <vul-start> 0 ) ; break ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int i ; node -> split = ( v32_t * ) data ; <vul-start> i ] = ( v32_t * ) <vul-start> i ] = ( v32_t * ) <vul-start> ) ; } node -> split [ i ] = ( v32_t * ) vt -> split [ i ] ;\n"
  },
  {
    "id": 383,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void copy_and_extend_plane ( const uint8_t * src , int src_pitch , uint8_t * dst , int dst_pitch , int w , int h , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i , linesize ; const uint8_t * src_ptr1 = src ; const uint8_t * src_ptr2 = src + w - 1 ; uint8_t * dst_ptr1 = dst - extend_left ; uint8_t * dst_ptr2 = dst + w ; for ( i = 0 ; i < h ; i ++ ) { <vul-start> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <vul-end> <vul-start> vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <vul-end> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_pitch ; src_ptr2 += src_pitch ; dst_ptr1 += dst_pitch ; dst_ptr2 += dst_pitch ; } src_ptr1 = dst - extend_left ; src_ptr2 = dst + dst_pitch * ( h - 1 ) - extend_left ; dst_ptr1 = dst + dst_pitch * ( - extend_top ) - extend_left ; dst_ptr2 = dst + dst_pitch * ( h ) - extend_left ; linesize = extend_left + extend_right + w ; for ( i = 0 ; i < extend_top ; i ++ ) { <vul-start> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <vul-end> dst_ptr1 += dst_pitch ; } for ( i = 0 ; i < extend_bottom ; i ++ ) { <vul-start> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <vul-end> dst_ptr2 += dst_pitch ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( dst_ptr1 , <vul-start> extend_left ) ; memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset <vul-end> ( dst_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr1 , <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr2 ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( dst_ptr1, <vul-start> extend_left ) ; memcpy ( dst_ptr1 + extend_left, src_ptr1, w ) ; memset <vul-end> ( dst_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr1, <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr2,\n"
  },
  {
    "id": 384,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB ) <vul-start> return - EOPNOTSUPP ; <vul-end> if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> return - EOPNOTSUPP <vul-end> ; if ( <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin6\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> return - EOPNOTSUPP <vul-end> ; if ( <vul-start> ) -> iif, msg -> msg_namelen\n"
  },
  {
    "id": 385,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t dm9000ReceivePacket ( NetInterface * interface ) { error_t error ; size_t i ; size_t n ; size_t length ; volatile uint8_t status ; volatile uint16_t data ; Dm9000Context * context ; context = ( Dm9000Context * ) interface -> nicContext ; <vul-start> data = dm9000ReadReg ( DM9000_REG_MRCMDX ) ; <vul-end> <vul-start> DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ; <vul-end> status = LSB ( DM9000_DATA_REG ) ; if ( status == 0x01 ) { <vul-start> DM9000_INDEX_REG = DM9000_REG_MRCMD ; <vul-end> status = MSB ( DM9000_DATA_REG ) ; length = DM9000_DATA_REG ; n = MIN ( length , ETH_MAX_FRAME_SIZE ) ; i = 0 ; <vul-start> if ( ( status & ( RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE ) ) == 0 ) <vul-end> { while ( ( i + 1 ) < n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ++ ] = LSB ( data ) ; context -> rxBuffer [ i ++ ] = MSB ( data ) ; } if ( ( i + 1 ) == n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ] = LSB ( data ) ; i += 2 ; } error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } while ( i < length ) { data = DM9000_DATA_REG ; i += 2 ; } } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; } return",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = dm9000ReadReg ( DM9000_MRCMDX <vul-end> ) ; DM9000_INDEX_REG <vul-start> ; DM9000_INDEX_REG = DM9000_MRCMDX1 <vul-end> ; status = <vul-start> { DM9000_INDEX_REG = DM9000_MRCMD <vul-end> ; status = <vul-start> status & ( DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE <vul-end> ) ) ==\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = dm9000ReadReg ( DM9000_MRCMDX ) ; DM9000_INDEX_REG = DM9000_MRCMDX1 ; status = LSB ( DM9000_DATA_REG ) ; if ( status == 0x01 ) { DM9000_INDEX_REG = DM9000_MRCMD ; status = MSB ( DM9000_DATA_REG ) ; length = DM9000_DATA_REG ; n = MIN ( length, ETH_MAX_FRAME_SIZE ) ; i = 0 ; if ( ( status & DM9000_RSR_LCS ) == DM9000_RSR_RWTO ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ++ ] = LSB ( data ) ; context -> rxBuffer [ i ++ ] = MSB ( data ) ; } else if ( ( status & DM9000_RSR_AE ) == DM9000_RSR_CE ) == DM9000_RSR_FOE ) { while ( ( i + 1 ) < n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ++ ] = LSB ( data ) ; i += 2 ; } } else { error = ERROR_INVALID_PACKET ; } while ( i < length ) { data = DM9000_DATA_REG ; i += 2 ; } if (! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface, context -> rxBuffer, n, & ancillary ) ; } if (! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface, context -> rxBuffer, n, & ancillary ) ; } if (! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface, context -> rxBuffer, n, & ancillary ) ; } if (! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; an"
  },
  {
    "id": 386,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { <vul-start> return SECURE_ELEMENT_ERROR_NPE ; <vul-end> } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } memcpy1 ( decJoinAccept , encJoinAccept , encJoinAcceptSize ) ; if ( SecureElementAesEncrypt ( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE , encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE , encKeyID , decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_ENCRYPT ; } * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ] << 0 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3 ] << 24 ) ; if ( * versionMinor == 0 ) { if ( SecureElementVerifyAesCmac ( decJoinAccept , ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ) , mic , NWK_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) else if ( * versionMinor == 1 ) { uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr =",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize < LORAMAC_MIC_FIELD_SIZE ) { return SECURE_ELEMENT_FAIL_ENCRYPT\n"
  },
  {
    "id": 387,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( \"nfnetlink-subsys-%d\" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <vul-start> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <vul-end> skb ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <vul-start> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( skb -> len < nlmsg_total_size ( 0 ) ||\n"
  },
  {
    "id": 388,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , \"unable to get BOS descriptor\\\\n\" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , \"unable to get BOS descriptor set\\\\n\" ) ; if ( ret >= 0 ) ret = - ENOMSG ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <vul-end> cap -> bLength <vul-start> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <vul-end> ; total_len -=\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) buffer ; if ( total_len < cap -> bLength ) break ;\n"
  },
  {
    "id": 389,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int ape_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { AVIOContext * pb = s -> pb ; APEContext * ape = s -> priv_data ; AVStream * st ; uint32_t tag ; int i ; int total_blocks ; int64_t pts ; ape -> junklength = 0 ; tag = avio_rl32 ( pb ) ; if ( tag != MKTAG ( 'M' , 'A' , 'C' , ' ' ) ) return - 1 ; ape -> fileversion = avio_rl16 ( pb ) ; if ( ape -> fileversion < APE_MIN_VERSION || ape -> fileversion > APE_MAX_VERSION ) { av_log ( s , AV_LOG_ERROR , \"Unsupported file version - %d.%02d\\\\n\" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 ) ; return - 1 ; } if ( ape -> fileversion >= 3980 ) { ape -> padding1 = avio_rl16 ( pb ) ; ape -> descriptorlength = avio_rl32 ( pb ) ; ape -> headerlength = avio_rl32 ( pb ) ; ape -> seektablelength = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> audiodatalength = avio_rl32 ( pb ) ; ape -> audiodatalength_high = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; avio_read ( pb , ape -> md5 , 16 ) ; if ( ape -> descriptorlength > 52 ) avio_seek ( pb , ape -> descriptorlength - 52 , SEEK_CUR ) ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , \"No frames in the file!\\\\n\" ) ; return AVERROR ( EINVAL ) ; } if (\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> totalframes > UINT32_MAX <vul-end> / sizeof (\n"
  },
  {
    "id": 390,
    "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static av_cold int rl2_read_header ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; AVStream * st ; unsigned int frame_count ; unsigned int audio_frame_counter = 0 ; unsigned int video_frame_counter = 0 ; unsigned int back_size ; unsigned short sound_rate ; unsigned short rate ; unsigned short channels ; unsigned short def_sound_size ; unsigned int signature ; unsigned int pts_den = 11025 ; unsigned int pts_num = 1103 ; unsigned int * chunk_offset = NULL ; int * chunk_size = NULL ; int * audio_size = NULL ; int i ; int ret = 0 ; avio_skip ( pb , 4 ) ; back_size = avio_rl32 ( pb ) ; signature = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; frame_count = avio_rl32 ( pb ) ; if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 2 ) ; sound_rate = avio_rl16 ( pb ) ; rate = avio_rl16 ( pb ) ; channels = avio_rl16 ( pb ) ; def_sound_size = avio_rl16 ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; st -> codecpar -> codec_tag = 0 ; st -> codecpar -> width = 320 ; st -> codecpar -> height = 200 ; st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; if ( signature == RLV3_TAG &&",
    "golden_answers": [
      "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> & 0xFFFF ; }\n"
    ],
    "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> & 0xFFFF ; }\n"
  },
  {
    "id": 391,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int parseFileInner ( MaState * state , cchar * path ) { MaDirective * directive ; char * tok , * key , * line , * value ; assert ( state ) ; assert ( path && * path ) ; if ( openConfig ( state , path ) < 0 ) { return MPR_ERR_CANT_OPEN ; } for ( state -> lineNumber = 1 ; state -> file && ( line = mprReadLine ( state -> file , 0 , NULL ) ) != 0 ; state -> lineNumber ++ ) { for ( tok = line ; isspace ( ( uchar ) * tok ) ; tok ++ ) ; if ( * tok == '\\\\0' || * tok == '#' ) { continue ; } state -> key = 0 ; <vul-start> key = getDirective ( line , & value ) ; <vul-end> if ( ! state -> enabled ) { if ( key [ 0 ] != '<' ) { continue ; } } if ( ( directive = mprLookupKey ( directives , key ) ) == 0 ) { mprLog ( \"error appweb config\" , 0 , \"Unknown directive \\\\\"%s\\\\\". At line %d in %s\" , key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } state -> key = key ; mprPauseGC ( ) ; if ( ( * directive ) ( state , key , value ) < 0 ) { mprResumeGC ( ) ; mprLog ( \"error appweb config\" , 0 , \"Error with directive \\\\\"%s\\\\\". At line %d in %s\"",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; if ( ( <vul-start> & value ) ) == 0 ) { continue ; } <vul-end> if ( !\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; key = mprGetDirective <vul-end> ( line,\n"
  },
  {
    "id": 392,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , <vul-end> <vul-start> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <vul-end> VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ; <vul-start> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <vul-end> unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <vul-start> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && <vul-end> cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ; <vul-start> x -> skip_optimize = ctx -> is_coded ; <vul-end> ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ; <vul-start> if ( cm -> frame_type == KEY_FRAME ) { <vul-end> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <vul-start> x = & td <vul-end> -> mb ; <vul-start> -> mbmi ; const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <vul-end> ; const int <vul-start> ! x -> select_tx_size <vul-end> && mbmi -> <vul-start> . allow_skip_recode ; if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <vul-start> ; if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <vul-end> } else { <vul-start> } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; <vul-start> [ 1 ] <vul-end> ) ; for <vul-start> ] ) ; assert ( cfg != NULL ) ; <vul-start> ) ; } if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <vul-end> ( xd , <vul-start> ) ) ; vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <vul-end> ; vp9_encode_sb ( <vul-start> vp9_tokenize_sb ( cpi , td <vul-start> ) ) ; <vul-end> } if ( <vul-start> -> skip || seg_skip <vul-end> ) ) ) <vul-start> bsize ] , get_tx_size_context <vul-end> ( xd ) <vul-start> ) , & td -> counts -> <vul-end> tx ) [ <vul-start> tx_size ; } ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, <vul-start>, BLOCK_SIZE bsize, PC_TREE * pc_tree <vul-start> & cpi -> td <vul-end> ; MACROBLOCKD * <vul-start> ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int segment_id = mbmi -> segment_id ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mi_8x8 [ 1 ] ; MB_MODE_CONTEXT * ctx = get_block_context ( x, bsize ) ; unsigned int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; unsigned int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; unsigned int mi_width = num_8x8_blocks"
  },
  {
    "id": 393,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( \"BPF_LDX uses reserved fields\\\\n\" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( \"BPF_STX uses reserved fields\\\\n\" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( \"invalid bpf_ld_imm64 insn\\\\n\" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( \"unrecognized bpf_ld_imm64 insn\\\\n\" ) ; return - EINVAL ; } f =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <vul-start> = map ; <vul-end> fdput ( f\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> E2BIG ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } <vul-start> ( map, true <vul-end> ) ; fdput\n"
  },
  {
    "id": 394,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ; <vul-start> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <vul-end> ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! index_key .\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>. type -> validate ||! index_key. type ->\n"
  },
  {
    "id": 395,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <vul-start> s -> decode_mb = mpeg4_decode_studio_mb ; <vul-end> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; s -> interlaced_dct = 0 ; s ->\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> decode_mb = mpeg4_decode_studio_mb ; s -> intra_dc_precision = 0\n"
  },
  {
    "id": 396,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static PyObject * builtin_compile_impl ( PyObject * module , PyObject * source , PyObject * filename , const char * mode , int flags , int dont_inherit , int optimize ) { PyObject * source_copy ; const char * str ; int compile_mode = - 1 ; int is_ast ; PyCompilerFlags cf ; <vul-start> int start [ ] = { Py_file_input , Py_eval_input , Py_single_input } ; <vul-end> PyObject * result ; cf . cf_flags = flags | PyCF_SOURCE_IS_UTF8 ; if ( flags & <vul-start> ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) ) <vul-end> { PyErr_SetString ( PyExc_ValueError , \"compile(): unrecognised flags\" ) ; goto error ; } if ( optimize < - 1 || optimize > 2 ) { PyErr_SetString ( PyExc_ValueError , \"compile(): invalid optimize value\" ) ; goto error ; } if ( ! dont_inherit ) { PyEval_MergeCompilerFlags ( & cf ) ; } if ( strcmp ( mode , \"exec\" ) == 0 ) compile_mode = 0 ; else if ( strcmp ( mode , \"eval\" ) == 0 ) compile_mode = 1 ; else if ( strcmp ( mode , \"single\" ) == 0 ) compile_mode = 2 ; <vul-start> else { <vul-end> PyErr_SetString ( PyExc_ValueError , <vul-start> \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\'\" ) ; <vul-end> goto error ; } is_ast = PyAST_Check ( source ) ; if ( is_ast == - 1 ) goto error ; if ( is_ast ) { if ( flags & PyCF_ONLY_AST ) { Py_INCREF ( source ) ; result = source ; } else { PyArena * arena",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> Py_eval_input , Py_single_input , Py_func_type_input <vul-start> PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS <vul-start> 2 ; else if ( strcmp ( mode , \"func_type\" ) == 0 ) { if ( ! ( flags & PyCF_ONLY_AST ) ) <vul-start> ( PyExc_ValueError , \"compile() mode \\'func_type\\' requires flag PyCF_ONLY_AST\" ) ; goto error ; } compile_mode = 3 ; } else { const char * msg ; if ( flags & PyCF_ONLY_AST ) msg = \"compile() mode must be \\'exec\\', \\'eval\\', \\'single\\' or \\'func_type\\'\" ; else msg = \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\'\" ; PyErr_SetString ( PyExc_ValueError , msg <vul-end> ) ; goto\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> PyCompilerFlags cf ; PyObject * result ; PyObject * str_copy ; <vul-start> Py_file_input, Py_eval_input <vul-end> } ; cf <vul-start> PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT <vul-end> ) ) { <vul-start> 2 ; else if ( strcmp ( mode, \"compat\" ) == 0 ) { compile_mode = 3 ; else <vul-start> ( PyExc_ValueError, \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\' or \\'compat\\'\" ) ; goto error ; } if ( strcmp ( mode, \"compat\" ) == 0 ) { compile_mode = 0 ; else if ( strcmp ( mode, \"compat\" ) == 0 ) { compile_mode = 1 ; else if ( strcmp ( mode, \"compat\" ) == 0 ) { compile_mode = 2 ; } else { PyErr_SetString ( PyExc_ValueError, \"compile() mode must be \\'compat\\', \\'compat\\' or \\'compat\\'\" ) ; goto error ; } str_copy = Py_BuildValue ( source, filename, \"compat\", & cf, optimize ) ; if ( str_copy == NULL ) goto error ; result = Py_CompileStringObject ( str_copy, filename, start [ compile_mode ], & cf, optimize ) ; Py_XDECREF ( source_copy ) ; goto finally ; } str = source_as_string ( source, \"compile\", \"string, bytes or AST\", & cf, & source_copy ) ; if ( str == NULL ) goto error ; result = Py_CompileStringObject ( str, filename, start [ compile_mode ], & cf, optimize ) ; Py_XDECREF ( source_copy ) ; goto finally ; error : str_copy = Py_BuildValue ( source, filename, \"string, bytes or AST\", & cf, & source_copy ) ; Py_XDECREF ( source_copy ) ; goto error ; } str = source_as_string ( source, \"compile\", \"string, bytes or AST\", & cf, & source_copy ) ; if ( str == NULL ) goto error ; result = Py_CompileStringObject ( str, filename, start [ compile_mode ], & cf, optimize ) ; Py_XDECREF ("
  },
  {
    "id": 397,
    "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( \"%s\\\\n\" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <vul-start> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <vul-end> printf ( \"Extracting %s\\\\n\"",
    "golden_answers": [
      "CWE-22 Fixed Code Lines are: <vul-start> = create_output_name ( <vul-end> f [ i <vul-start> ] -> filename <vul-end> ) ; printf\n"
    ],
    "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> 1, 0, 0\n"
  },
  {
    "id": 398,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <vul-start> char combname [ L_BUF_SIZE ] ; <vul-end> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( \"selaGetCombName\" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( \"sela not defined\" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( \"invalid direction\" , procName , NULL ) ; if ( direction == L_HORIZ ) <vul-start> snprintf ( combname , L_BUF_SIZE , \"sel_comb_%dh\" , size ) ; <vul-end> else <vul-start> snprintf ( combname , L_BUF_SIZE , \"sel_comb_%dv\" , size ) ; <vul-end> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( \"sel not found\" , procName , NULL ) ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char combname [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( combname , L_BUFSIZE <vul-end> , \"sel_comb_%dh\" , <vul-start> ( combname , L_BUFSIZE <vul-end> , \"sel_comb_%dv\" ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char combname [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( combname, L_BUFSIZE <vul-end>, \"sel_comb_%dh\", <vul-start> ( combname, L_BUFSIZE <vul-end>, \"sel_comb_%dv\",\n"
  },
  {
    "id": 399,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <vul-start> int rc ; <vul-end> unsigned char key2 [ 8 ] ; <vul-start> struct crypto_skcipher * tfm_des ; <vul-end> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <vul-start> tfm_des = crypto_alloc_skcipher ( \"ecb(des)\" , 0 , CRYPTO_ALG_ASYNC ) ; <vul-end> if ( IS_ERR ( tfm_des ) ) { <vul-start> rc = PTR_ERR ( tfm_des ) ; <vul-end> cifs_dbg ( VFS , \"could not allocate des crypto API\\\\n\" ) ; <vul-start> goto smbhash_err ; <vul-end> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , \"could not allocate des crypto API\\\\n\" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <vul-start> sg_init_one ( & sgin , in , 8 ) ; <vul-end> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , \"could not encrypt crypt key rc: %d\\\\n\" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <vul-start> smbhash_err : <vul-end> return rc ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> key ) { <vul-end> unsigned char key2 <vul-start> ] ; struct crypto_cipher * tfm_des <vul-end> ; str_to_key ( <vul-start> ; tfm_des = crypto_alloc_cipher ( \"des\" <vul-end> , 0 , <vul-start> , 0 , 0 <vul-end> ) ; if <vul-start> ) ) { <vul-end> cifs_dbg ( VFS <vul-start> \"could not allocate des crypto API\\\\n\" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <vul-end> ( tfm_des , <vul-start> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <vul-end> ( tfm_des ) <vul-start> tfm_des ) ; return 0 <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> key ) { <vul-end> char key2 [ <vul-start> 8 ] ; int err = - EINVAL ; <vul-start> key2 ) ; err = crypto_alloc_skcipher ( \"ecb(des)\", 0, CRYPTO_ALG_ASYNC ) ; if ( err <vul-end> ) { rc <vul-start> { rc = err <vul-end> ; cifs_dbg ( <vul-start> ; goto smbhash_free_skcipher ; } if (! err ) { rc = - ENOMEM <vul-start> 8 ) ; if (! err ) { <vul-start> tfm_des ) ; } return rc <vul-end> ; }  \n"
  },
  {
    "id": 400,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { int err ; u32 tsk_portid = cb -> args [ 0 ] ; u32 last_publ = cb -> args [ 1 ] ; u32 done = cb -> args [ 2 ] ; struct net * net = sock_net ( skb -> sk ) ; struct tipc_sock * tsk ; if ( ! tsk_portid ) { struct nlattr * * attrs ; struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; if ( err ) return err ; <vul-start> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , <vul-end> <vul-start> attrs [ TIPC_NLA_SOCK ] , <vul-end> tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ; <vul-start> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; <vul-end> } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; <vul-start> lock_sock ( & tsk -> sk ) ; <vul-end> err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; if ( ! err ) done = 1 ; release_sock ( & tsk -> sk ) ; sock_put ( & tsk -> sk ) ; cb -> args [ 0 ] = tsk_portid ; cb -> args [ 1 ] = last_publ ; cb -> args [ 2 ] = done ; return skb -> len ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> return err ; if ( ! <vul-end> attrs [ TIPC_NLA_SOCK <vul-start> attrs [ TIPC_NLA_SOCK <vul-end> ] ) return <vul-start> - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <vul-end> [ TIPC_NLA_SOCK_REF ] <vul-start> [ TIPC_NLA_SOCK_REF ] <vul-end> ) return - <vul-start> - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> return err ; if ( <vul-end> attrs [ TIP_NLA_SOCK <vul-start> [ TIP_NLA_SOCK ] ) { err = - EINVAL ; goto out ; } <vul-end> tsk_portid = nla_get_u32 <vul-start> - EINVAL ; out : <vul-start> - EINVAL ; <vul-end> cb -> args\n"
  },
  {
    "id": 401,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) )",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ioffset ) ; <vul-end> credits = ext4_writepage_trans_blocks <vul-start> ) ; goto out_mmap <vul-end> ; } inode <vul-start> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-end> ext4_inode_resume_unlocked_dio ( inode\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ioffset ) ; <vul-end> credits = ext4_writepage_trans_blocks <vul-start> ; goto out_dio <vul-end> ; } inode\n"
  },
  {
    "id": 402,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; <vul-start> name . name = buf ; <vul-end> name . len = outarg . namelen ; <vul-start> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <vul-end> if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <vul-end> outarg . namelen <vul-start> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> goto err ; fuse_copy_finish ( cs ) ; buf [ outarg. namelen ] = 0 ; <vul-start> ( cs, & name, sizeof ( name ) <vul-end> ) ; if\n"
  },
  {
    "id": 403,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int nci_extract_activation_params_iso_dep ( struct nci_dev * ndev , struct nci_rf_intf_activated_ntf * ntf , __u8 * data ) { struct activation_params_nfca_poll_iso_dep * nfca_poll ; struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; switch ( ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ; <vul-start> nfca_poll -> rats_res_len = * data ++ ; <vul-end> pr_debug ( \"rats_res_len %d\\\\n\" , nfca_poll -> rats_res_len ) ; if ( nfca_poll -> rats_res_len > 0 ) { memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ) ; } break ; case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ; <vul-start> nfcb_poll -> attrib_res_len = * data ++ ; <vul-end> pr_debug ( \"attrib_res_len %d\\\\n\" , nfcb_poll -> attrib_res_len ) ; if ( nfcb_poll -> attrib_res_len > 0 ) { memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ) ; } break ; default : pr_err ( \"unsupported activation_rf_tech_and_mode 0x%x\\\\n\" , ntf -> activation_rf_tech_and_mode ) ; return NCI_STATUS_RF_PROTOCOL_ERROR ; } return NCI_STATUS_OK ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> rats_res_len = min_t ( __u8 , <vul-start> * data ++ , 20 ) <vul-start> -> attrib_res_len = min_t ( __u8 , <vul-start> * data ++ , 50 )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> rats_res_len = min ( <vul-start> * data ++, NCI_NFC_RES_MAXSIZE ) <vul-start> -> attrib_res_len = min ( <vul-start> * data ++, NCI_NFC_RES_MAXSIZE )\n"
  },
  {
    "id": 404,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , unsigned long resolution , unsigned long ticks ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread * r , r1 ; struct timespec tstamp ; int prev , append = 0 ; memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; spin_lock ( & tu -> qlock ) ; if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { spin_unlock ( & tu -> qlock ) ; return ; } if ( tu -> last_resolution != resolution || ticks > 0 ) { if ( timer_tstamp_monotonic ) ktime_get_ts ( & tstamp ) ; else getnstimeofday ( & tstamp ) ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && tu -> last_resolution != resolution ) { <vul-start> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <vul-end> r1 . tstamp = tstamp ; r1 . val = resolution ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; tu -> last_resolution = resolution ; append ++ ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) goto __wake ; if ( ticks == 0 ) goto __wake ; if ( tu -> qused > 0 ) { prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; r = & tu -> tqueue [ prev ] ; if ( r -> event ==",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> resolution ) { memset ( & r1, 0, sizeof ( r1 ) ) ;\n"
  },
  {
    "id": 405,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd , int start_mb_row ) { volatile const int * last_row_current_mb_col ; volatile int * current_mb_col ; int mb_row ; VP8_COMMON * pc = & pbi -> common ; const int nsync = pbi -> sync_range ; const int first_row_no_sync_above = pc -> mb_cols + nsync ; int num_part = 1 << pbi -> common . multi_token_partition ; int last_mb_row = start_mb_row ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; YV12_BUFFER_CONFIG * yv12_fb_lst = pbi -> dec_fb_ref [ LAST_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; xd -> up_available = ( start_mb_row != 0 ) ; for ( mb_row = start_mb_row ; mb_row < pc -> mb_rows ; mb_row",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> above_context ; memset <vul-end> ( xd -> <vul-start> 1 ) { memcpy <vul-end> ( ( pbi <vul-start> 16 ) ; memcpy <vul-end> ( ( pbi <vul-start> 8 ) ; memcpy <vul-end> ( ( pbi\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> above_context ; memset <vul-end> ( xd -> <vul-start> -> above_context ; memset <vul-end> ( xd ->\n"
  },
  {
    "id": 406,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <vul-start> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <vul-end> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS id out of range: %d\\\\n\" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS changed between slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ;",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Two slices reporting being the first in the same frame.\\\\n\" ) ; return 1 ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>, ret ; if ( s -> nal_unit_type == HEVC_NAL_NUT ) { ret = set_pic_header ( s, gb ) ; if ( ret < 0 ) return ret ; }\n"
  },
  {
    "id": 407,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame -= frame -> frame ; <vul-start> section -> intra_error -= frame -> intra_error ; <vul-end> section -> coded_error -= frame -> coded_error ; section -> sr_coded_error -= frame -> sr_coded_error ; <vul-start> section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ; <vul-end> section -> pcnt_inter -= frame -> pcnt_inter ; section -> pcnt_motion -= frame -> pcnt_motion ; section -> pcnt_second_ref -= frame -> pcnt_second_ref ; <vul-start> section -> pcnt_neutral -= frame -> pcnt_neutral ; <vul-end> section -> MVr -= frame -> MVr ; section -> mvr_abs -= frame -> mvr_abs ; section -> MVc -= frame -> MVc ; section -> mvc_abs -= frame -> mvc_abs ; section -> MVrv -= frame -> MVrv ; section -> MVcv -= frame -> MVcv ; section -> mv_in_out_count -= frame -> mv_in_out_count ; section -> new_mv_count -= frame -> new_mv_count ; section -> count -= frame -> count ; section -> duration -= frame -> duration ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; section -> weight -= frame -> weight ; section -> <vul-start> ; section -> <vul-end> pcnt_inter -= frame <vul-start> frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; section -> weight -= frame -> weight ; section -> <vul-start> ; section -> <vul-end> pcnt_inter -= frame <vul-start> frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols\n"
  },
  {
    "id": 408,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , \"R%d type=%s expected=%s\\\\n\" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , \"invalid variable stack read R%d var_off=%s\\\\n\" , regno , tn_buf ) ; <vul-start> } <vul-end> off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , \"invalid stack type R%d off=%d access_size=%d\\\\n\" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> tn_buf ) ; return - EACCES ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tn_buf ) ; return - EACCES ;\n"
  },
  {
    "id": 409,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( \"Creating initial consoles under container /dev\" ) ; ret = snprintf ( path , MAXPATHLEN , \"%s/dev\" , rootfs -> path ? rootfs -> mount : \"\" ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { ERROR ( \"Error calculating container /dev location\" ) ; return - 1 ; } if ( ! dir_exists ( path ) ) return 0 ; INFO ( \"Populating container /dev\" ) ; cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ; for ( i = 0 ; i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ; i ++ ) { const struct lxc_devs * d = & lxc_devs [ i ] ; ret = snprintf ( path , MAXPATHLEN , \"%s/dev/%s\" , rootfs -> path ? rootfs -> mount : \"\" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ; if ( ret && errno != EEXIST ) { char hostpath [ MAXPATHLEN ] ; FILE * pathfile ; ret = snprintf ( hostpath , MAXPATHLEN , \"/dev/%s\" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; pathfile = fopen ( path , \"wb\" )",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <vul-end> NULL ) !=\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> ; if ( safe_mount <vul-end> ( hostpath,\n"
  },
  {
    "id": 410,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , \"SYSV%08x\" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN (",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <vul-start> no_id ; } <vul-end> list_add ( &\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist, & current -> sysvshm. shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm. id ; <vul-start> no_id ; } <vul-end> ipc_unlock_object ( &\n"
  },
  {
    "id": 411,
    "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , \"Video compression %i\" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast",
    "golden_answers": [
      "CWE-834 Fixed Code Lines are: <vul-start> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA\n"
    ],
    "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> pb ) ; int vsize = avio_rb32 <vul-end> ( pb )\n"
  },
  {
    "id": 412,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void sctp_auth_get_cookie_params ( struct sctp_tcb * stcb , struct mbuf * m , uint32_t offset , uint32_t length ) { struct sctp_paramhdr * phdr , tmp_param ; uint16_t plen , ptype ; uint8_t random_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_random * p_random = NULL ; uint16_t random_len = 0 ; uint8_t hmacs_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_hmac_algo * hmacs = NULL ; uint16_t hmacs_len = 0 ; uint8_t chunks_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_chunk_list * chunks = NULL ; uint16_t num_chunks = 0 ; sctp_key_t * new_key ; uint32_t keylen ; length += offset ; phdr = ( struct sctp_paramhdr * ) sctp_m_getptr ( m , offset , sizeof ( struct sctp_paramhdr ) , ( uint8_t * ) & tmp_param ) ; while ( phdr != NULL ) { ptype = ntohs ( phdr -> param_type ) ; plen = ntohs ( phdr -> param_length ) ; <vul-start> if ( ( plen == 0 ) || ( offset + plen > length ) ) <vul-end> break ; if ( ptype == SCTP_RANDOM ) { if ( plen > sizeof ( random_store ) ) break ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) random_store , plen ) ; if ( phdr == NULL ) return ; p_random = ( struct sctp_auth_random * ) phdr ; random_len = plen - sizeof ( * p_random ) ; } else if ( ptype == SCTP_HMAC_LIST ) { uint16_t num_hmacs ; uint16_t i ; if ( plen > sizeof ( hmacs_store ) ) break ; phdr = sctp_get_next_param ( m , offset",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( ( plen < sizeof ( struct sctp_paramhdr ) <vul-end> ) || (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ptype == SCTP_RANDOM\n"
  },
  {
    "id": 413,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_frame ( vpx_codec_ctx_t * ctx , <vul-end> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <vul-start> VpxVideoWriter * writer ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to encode frame.\" ) ; <vul-start> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <vul-end> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , \"Failed to write compressed frame.\" ) ; printf ( keyframe ? \"K\" : \".\" ) ; fflush ( stdout ) ; } } <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
  },
  {
    "id": 414,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 enum auth_stat gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , bool_t * no_dispatch ) { enum auth_stat retstat ; XDR xdrs ; SVCAUTH * auth ; struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; struct rpc_gss_init_res gr ; int call_stat , offset ; OM_uint32 min_stat ; log_debug ( \"in svcauth_gss()\" ) ; rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; if ( rqst -> rq_xprt -> xp_auth == NULL || rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { fprintf ( stderr , \"svcauth_gss: out_of_memory\\\\n\" ) ; return ( AUTH_FAILED ) ; } if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { fprintf ( stderr , \"svcauth_gss: out_of_memory\\\\n\" ) ; return ( AUTH_FAILED ) ; } auth -> svc_ah_ops = & svc_auth_gss_ops ; SVCAUTH_PRIVATE ( auth ) = gd ; rqst -> rq_xprt -> xp_auth = auth ; } else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; log_debug ( \"xp_auth=%p, gd=%p\" , rqst -> rq_xprt -> xp_auth , gd ) ; if ( rqst -> rq_cred . oa_length <= 0 ) return ( AUTH_BADCRED ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gc , 0 , sizeof ( * gc ) ) ; log_debug ( \"calling xdrmem_create()\" ) ; log_debug ( \"oa_base=%p, oa_length=%u\" , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length )",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> gr_token ) ; <vul-end> ret_freegc ( AUTH_FAILED <vul-start> gd -> checksum <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> gr_token ) ; <vul-end> ret_freegc ( AUTH_FAILED <vul-start> gd -> checksum <vul-end> ) ; if\n"
  },
  {
    "id": 415,
    "question": "CWE-129 Code Input Vulnerable Code Is: CWE-129 static int cbs_av1_read_uvlc ( CodedBitstreamContext * ctx , GetBitContext * gbc , const char * name , uint32_t * write_to , uint32_t range_min , uint32_t range_max ) { <vul-start> uint32_t value ; <vul-end> <vul-start> int position , zeroes , i , j ; <vul-end> char bits [ 65 ] ; if ( ctx -> trace_enable ) position = get_bits_count ( gbc ) ; <vul-start> zeroes = i = 0 ; <vul-end> while ( 1 ) { <vul-start> if ( get_bits_left ( gbc ) < zeroes + 1 ) { <vul-end> av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid uvlc code at \" \"%s: bitstream ended.\\\\n\" , name ) ; return AVERROR_INVALIDDATA ; } <vul-start> if ( get_bits1 ( gbc ) ) { <vul-end> bits [ i ++ ] = '1' ; <vul-start> break ; <vul-end> } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { value = get_bits_long ( gbc , zeroes ) ; for ( j = 0 ; j < zeroes ; j ++ ) <vul-start> bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; <vul-end> <vul-start> value += ( 1 << zeroes ) - 1 ; <vul-end> } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , value ) ; } if ( value < range_min",
    "golden_answers": [
      "CWE-129 Fixed Code Lines are: <vul-start> ) { uint32_t zeroes , bits_value , <vul-start> ; int position <vul-end> ; if ( <vul-start> ; zeroes = <vul-end> 0 ; while <vul-start> gbc ) < <vul-end> 1 ) { <vul-start> gbc ) ) break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid uvlc code at \" \"%s: bitstream ended.\\\\n\" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <vul-end> bits [ i <vul-start> = '1' ; if ( zeroes < 32 ) { <vul-end> for ( j <vul-start> ] = ( bits_value <vul-end> >> ( zeroes <vul-start> : '0' ; } <vul-end> bits [ i\n"
    ],
    "generated_answer": "CWE-129 Fixed Code Lines are: <vul-start> { uint32_t value = 0 <vul-start> i, j, remaining <vul-start> ; zeroes = remaining = <vul-start> i = 0 ; remaining = get_bits_left ( gbc ) <vul-start> { if ( remaining <vul-end> + 1 ) <vul-start> } if ( remaining <vul-end> ) { bits <vul-start> = '1' ; remaining -- ; <vul-start> j ++ ) { if ( remaining == 0 ) return AVERROR_INVALIDDATA ; bits [ i ++ ] = '0' ; remaining -- ; <vul-start> : '0' ; remaining -- ; } <vul-start> ) - 1 ; remaining = get_bits_left ( gbc )\n"
  },
  {
    "id": 416,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { <vul-start> int v , i ; <vul-end> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <vul-start> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <vul-end> return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , \"trns before IHDR\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , \"trns after IDAT\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <vul-start> != 6 ) || s -> bit_depth == 1\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> v, i ; if ( s -> color_type == PNG_COLOR_TYPE_UNKNOWN && length!= 6 ) return AVERROR_INVALIDDATA <vul-start>!= 6 ) ) return AVERROR_INVALIDDATA ; if ( s -> bit_depth > 7\n"
  },
  {
    "id": 417,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int main ( int argc , char * argv [ ] ) { <vul-start> p_fm_config_conx_hdlt hdl ; <vul-end> int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = \"public\" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , \"i:d:h-\" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , \"Command required\\\\n\" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( \"Connecting to %s FM instance %d\\\\n\" , ( rem_addr == NULL ) ? \"LOCAL\" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , \"Failed to initialize the client handle: %d\\\\n\" , res ) ; <vul-start> goto die_clean ; <vul-end> } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , \"Failed to connect: (%d) %s\\\\n\"",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> { p_fm_config_conx_hdlt hdl = NULL <vul-start> ) ; goto cleanup <vul-end> ; } if <vul-start> ) ; goto cleanup <vul-end> ; } for <vul-start> 0 ) { res = <vul-end> commandList [ i <vul-start> ] ) ; goto cleanup ; <vul-start> - 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <vul-end> free ( hdl <vul-start> hdl ) ; }\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ] ) { p_fm_config_conx_hdlt hdl ; fm_mgr_config_errno_t err <vul-end> ; char * <vul-start> ) ) ; err = FM_MGR_CONFIG_ERROR ; <vul-start> ) ; goto err_free <vul-end> ; } for <vul-start> 0 ) { err = <vul-start> ] ) ; if ( err!= FM_MGR_CONFIG_OK ) { fprintf ( stderr, \"Command (%s) is not valid\\\\n\", command ) ; usage ( argv [ 0 ] ) ; res = - 1 ; die_clean : free ( hdl ) ; return res ; } <vul-start> - 1 ; err_free <vul-end> : free ( <vul-start> ; return res <vul-end> ; }  \n"
  },
  {
    "id": 418,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s failed vm entry %x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> : case EXIT_REASON_INVEPT : case EXIT_REASON_INVPT\n"
  },
  {
    "id": 419,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <vul-start> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <vul-end> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <vul-start> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <vul-end> & max_bytes ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. sb_bsize_shift ; if ( next == 0 ) { error = - EINVAL ; goto out_free_dinode ; } <vul-start> = bytes ; error = <vul-start>, & ind_blocks ) ; if ( error ) goto out_free_dinode ; if ( error ) goto out_trans_fail\n"
  },
  {
    "id": 420,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , \"CCID option %u optlen too short\" , * option ) ) ; else ND_PRINT ( ( ndo , \"%s optlen too short\" , tok2str ( dccp_option_values , \"Option %u\" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , \"CCID option %u optlen goes past header length\" , * option ) ) ; else ND_PRINT ( ( ndo , \"%s optlen goes past header length\" , tok2str ( dccp_option_values , \"Option %u\" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , \"CCID option %d\" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( optlen == 6 <vul-end> ) ND_PRINT ( <vul-start> ( ndo , \" [optlen != 6]\" <vul-end> ) ) ; <vul-start> case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , \" (elapsed time %u)\" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , \" (elapsed time %u)\" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , \" [optlen != 6 or 8 or 10]\" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <vul-start> , \" %u\" , EXTRACT_16BITS <vul-end> ( option + <vul-start> ( ndo , \" [optlen != 4 or 6]\" <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case 41 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> ) ) ; ND_TCHECK_16BITS ( option + 2 ) ; <vul-start> case 42 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> ) ) ; ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 43 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 43 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> case 44 : ND_TCHECK_32BITS ( option + 2 ) ;\n"
  },
  {
    "id": 421,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s > %s.%s: \" , ip6addr_string ( ndo , & ip6 ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <vul-start> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_LENGTH option, length %u != %u]\" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , \" OPTS LEN (extra?) %d\" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_FRAGMENT option, length %u != %u]\" , opt_len , PGM_OPT_FRAGMENT_LEN <vul-end> ) ) ; <vul-start> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" FRAG seq %u off %u len %u\" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , \" NAK LIST\" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , \"[Option length not a multiple of 4]\" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <vul-end> ; opts_len -= <vul-start> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_JOIN option, length %u != %u]\" , opt_len , PGM_OPT_JOIN_LEN <vul-end> ) ) ; <vul-start> ; bp += 4 ; ND_PRINT ( ( ndo , \" JOIN %u\" , seq <vul-end> ) ) ; <vul-start> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <vul-end> if ( opt_len <vul-start> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NAK_BO_IVL option, length %u != %u]\" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <vul-end> ) ) ; <vul-start> return ; } bp += 2 ; offset = <vul-end> EXTRACT_32BITS ( bp <vul-start> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" BACKOFF ivl %u ivlseq %u\" , offset , seq ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NAK_BO_RNG option, length %u != %u]\" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <vul-end> ) ) ; <vul-start> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <vul-start> ; bp += 4 ; ND_PRINT ( ( ndo , \" BACKOFF max %u min %u\" , offset <vul-end> , seq ) <vul-start> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <vul-end> if ( opt_len <vul-start> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u < %u]\" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u != %u + address size]\" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <vul-end> : if ( <vul-start> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u != %u + address size]\" , PGM_OPT_REDIRECT_FIXED_LEN <vul-end> , opt_len ) <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \" REDIRECT %s\" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PARITY_PRM option, length %u != %u]\" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY MAXTGS %u\" , len ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PARITY_GRP option, length %u != %u]\" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY GROUP %u\" , seq ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_CURR_TGSIZE option, length %u != %u]\" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY ATGS %u\" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NBR_UNREACH option, length %u != %u]\" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" NBR_UNREACH\" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , \" PATH_NLA [%d]\" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_SYN option, length %u != %u]\" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" SYN\" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_FIN option, length %u != %u]\" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" FIN\" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_RST option, length %u != %u]\" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" RST\" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , \" CR\" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_CRQST option, length %u != %u]\" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" CRQST\" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u < %u]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <vul-end> + sizeof ( <vul-start> ( ndo , \" PGMCC DATA %u %s\" , offset <vul-end> , nla_buf ) <vul-start> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <vul-end> if ( opt_len <vul-start> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <vul-end> : if ( <vul-start> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> + sizeof (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case PGM_OPT_LENGTH : ND_TCHECK_16BITS ( bp ) ; <vul-start> case PGM_OPT_FRAGMENT : ND_TCHECK_16BITS ( bp ) ; <vul-start> case PGM_OPT_DESCRIPTORS : ND_TCHECK_16BITS ( bp ) ;\n"
  },
  {
    "id": 422,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == ' ' || c == '\\\\t' || c == ',' || c == ';' ) { } <vul-start> else if ( isalnum ( c ) || strchr ( \"!#$%&\\'*+-.^_`|~\" , c ) || c >= 128 ) <vul-end> { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == ' ' || c == '\\\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '='",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" ,\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> c ) || memchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start> c ) || memchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start> c ) || memchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start> c ) || memchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start> c ) || memchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\",\n"
  },
  {
    "id": 423,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , \".fini_array\" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , \".init_array\" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , \".preinit_array\" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <vul-start> for ( i = 0 ; i < sec -> size ; i += 4 ) { <vul-end> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <vul-start> for ( i = 0 ; i < sec -> size ; i += 8 ) { <vul-end> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ( i + 3 ) <vul-end> < sec -> <vul-start> = 0 ; ( i + 7 ) <vul-end> < sec ->\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 32 ) { if ( buf == NULL ) { free ( secs ) ; return ; } <vul-start> } else { if ( buf == NULL ) { free ( secs ) ; return ; }\n"
  },
  {
    "id": 424,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int jpc_dec_tileinit ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { jpc_dec_tcomp_t * tcomp ; int compno ; int rlvlno ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_prc_t * prc ; int bndno ; jpc_tsfb_band_t * bnd ; int bandno ; jpc_dec_ccp_t * ccp ; int prccnt ; jpc_dec_cblk_t * cblk ; int cblkcnt ; uint_fast32_t tlprcxstart ; uint_fast32_t tlprcystart ; uint_fast32_t brprcxend ; uint_fast32_t brprcyend ; uint_fast32_t tlcbgxstart ; uint_fast32_t tlcbgystart ; uint_fast32_t brcbgxend ; uint_fast32_t brcbgyend ; uint_fast32_t cbgxstart ; uint_fast32_t cbgystart ; uint_fast32_t cbgxend ; uint_fast32_t cbgyend ; uint_fast32_t tlcblkxstart ; uint_fast32_t tlcblkystart ; uint_fast32_t brcblkxend ; uint_fast32_t brcblkyend ; uint_fast32_t cblkxstart ; uint_fast32_t cblkystart ; uint_fast32_t cblkxend ; uint_fast32_t cblkyend ; uint_fast32_t tmpxstart ; uint_fast32_t tmpystart ; uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ; <vul-start> jpc_tsfb_band_t bnds [ 64 ] ; <vul-end> jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ; cp = tile -> cp ; tile -> realmode = 0 ; if ( cp -> mctid == JPC_MCT_ICT ) { tile -> realmode = 1 ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { ccp = & tile -> cp -> ccps [ compno ] ; if ( ccp -> qmfbid == JPC_COX_INS ) { tile -> realmode = 1 ; } tcomp -> numrlvls = ccp -> numrlvls ; if ( ! ( tcomp -> rlvls = jas_alloc2 ( tcomp -> numrlvls",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <vul-end> ] ; jpc_pchg_t\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> jpc_tsfb_band_t bnds [ 128 <vul-end> ] ; jpc_pchg_t\n"
  },
  {
    "id": 425,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , <vul-start> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <vul-end> packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>, packet -> http_content_type. ptr = NULL, packet -> <vul-start>, packet -> http_content_type. len = 0, packet ->\n"
  },
  {
    "id": 426,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , \"r\" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , \"cannot open CSR file!\\\\n\" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , \"could not read file length!\\\\n\" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_column_idx\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_column_idx\n"
  },
  {
    "id": 427,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) { <vul-start> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <vul-end> goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ) ) { jas_eprintf ( \"cannot copy box data\\\\n\" ) ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> { if (! box -> len ) { goto error ; } if (\n"
  },
  {
    "id": 428,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <vul-start> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <vul-end> <vul-start> Min ( 4 , dds_info -> height - y ) , exception ) ; <vul-end> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> , y , MagickMin <vul-end> ( 4 , <vul-start> x ) , MagickMin <vul-end> ( 4 , <vul-start> ; } } return ( <vul-start> dds_info , 8 , exception ) ) <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, y, MagickMin <vul-end> ( 4, <vul-start> x ), MagickMin <vul-end> ( 4, <vul-start> ; } } return ( <vul-start> dds_info, 8, exception ) ) <vul-end> ; }  \n"
  },
  {
    "id": 429,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) { <vul-start> # if HAVE_NEON <vul-end> int64_t dx_store_reg [ 8 ] ; # endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ; <vul-start> pbi -> common . error . error_code = VPX_CODEC_OK ; <vul-end> retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ; <vul-start> # if HAVE_NEON <vul-end> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( dx_store_reg ) ; } # endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> time_stamp ) { <vul-end> VP8_COMMON * cm <vul-start> - 1 ; ( void ) size ; ( void ) source ; <vul-start> return retcode ; <vul-end> cm -> new_fb_idx <vul-start> ; decode_exit : <vul-end> pbi -> common <vul-start> = 0 ; vp8_clear_system_state ( ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> time_stamp ) { <vul-end> VP8_COMMON * cm <vul-start> - 1 ; # if CONFIG_TEMPORAL_DENOISING if ( cm -> cpu_caps & CONFIG_TEMPORAL_DENOISING ) { vp8_zero ( dx_store_reg ) ; } # endif <vul-start> return retcode ; <vul-end> cm -> new_fb_idx\n"
  },
  {
    "id": 430,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t dm9000UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashTable [ 8 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( \"Updating MAC filter...\\\\r\\\\n\" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; hashTable [ 7 ] = 0x80 ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = dm9000CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = crc & 0x3F ; hashTable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } for ( i = 0 ; i < 8 ; i ++ ) { <vul-start> dm9000WriteReg ( DM9000_REG_MAR0 + i , hashTable [ i ] ) ; <vul-end> } TRACE_DEBUG ( \" MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \" \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\\\r\\\\n\" , <vul-start> dm9000ReadReg ( DM9000_REG_MAR0 ) , dm9000ReadReg ( DM9000_REG_MAR1 ) , <vul-end> dm9000ReadReg ( DM9000_REG_MAR2 ) , dm9000ReadReg ( DM9000_REG_MAR3 ) , dm9000ReadReg ( DM9000_REG_MAR4 ) , dm9000ReadReg ( DM9000_REG_MAR5 ) , dm9000ReadReg ( DM9000_REG_MAR6 ) , dm9000ReadReg ( DM9000_REG_MAR7 ) ) ; return NO_ERROR ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_MAR0 <vul-end> + i , <vul-start> , dm9000ReadReg ( DM9000_MAR0 ) , dm9000ReadReg ( DM9000_MAR1 ) , dm9000ReadReg ( DM9000_MAR2 ) , dm9000ReadReg ( DM9000_MAR3 ) , dm9000ReadReg ( DM9000_MAR4 ) , dm9000ReadReg ( DM9000_MAR5 ) , dm9000ReadReg ( DM9000_MAR6 ) , dm9000ReadReg ( DM9000_MAR7 <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_MAR0 <vul-end>, hashTable [ <vul-start>, dm9000ReadReg ( DM9000_MAR0 ), dm9000ReadReg ( DM9000_MAR1 ), dm9000ReadReg ( DM9000_MAR2 ), dm9000ReadReg ( DM9000_MAR3 ), dm9000ReadReg ( DM9000_MAR4 ), dm9000ReadReg ( DM9000_MAR5 ), dm9000ReadReg ( DM9000_MAR6 ), dm9000ReadReg ( DM9000_MAR7 ) ) ; } TRACE_DEBUG ( \" MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\\\r\\\\n\", dm9000ReadReg ( DM9000_MAR0 ), dm9000ReadReg ( DM9000_MAR1 ), dm9000ReadReg ( DM9000_MAR2 ), dm9000ReadReg ( DM9000_MAR3 ), dm9000ReadReg ( DM9000_MAR4 ), dm9000ReadReg ( DM9000_MAR5 ), dm9000ReadReg ( DM9000_MAR6 ), dm9000ReadReg ( DM9000_MAR7 ) ) ; for ( i = 0 ; i < 8 ; i ++ ) { dm9000WriteReg ( DM9000_MAR0 + i, dm9000ReadReg ( DM9000_MAR4 ), dm9000ReadReg ( DM9000_MAR5 ), dm9000ReadReg ( DM9000_MAR6 ), dm9000ReadReg ( DM9000_MAR7 ) ) ; } TRACE_DEBUG ( \" MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02"
  },
  {
    "id": 431,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <vul-start> } <vul-end> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel (",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <vul-start> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> -> rmtblkcnt2 ; args -> rmtvaluelen2 = args -> rmtvaluelen ;\n"
  },
  {
    "id": 432,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <vul-start> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <vul-end> CORE_MMU_USER_PARAM_SIZE ) ; <vul-start> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <vul-end> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <vul-start> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <vul-end> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> uaddr_t a ; uaddr_t end_addr = 0 ; <vul-start> len , & end_addr <vul-end> ) ) return <vul-start> ( a = ROUNDDOWN ( uaddr , addr_incr ) <vul-end> ; a < <vul-start> ; a < end_addr <vul-end> ; a +=\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> uaddr_t a ; <vul-end> if ( ADD_OVERFLOW <vul-start>, & a ) ) return TEE_ERROR_ACCESS_DENIED ; if ( len < addr_incr ) return TEE_ERROR_ACCESS_DENIED ; assert ( len < CORE_MMU_USER_CODE_SIZE ) ; assert ( len < CORE_MMU_USER_PARAM_SIZE <vul-start> len ) ; ) { uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc, ( void * ) a, NULL, & attr ) ; if ( res!= TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) &&! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; }\n"
  },
  {
    "id": 433,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( \"%s: metadata is null!\" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = \"camera_metadata\" , . alignment = METADATA_ALIGNMENT } , { . name = \"camera_metadata_buffer_entry\" , . alignment = ENTRY_ALIGNMENT } , { . name = \"camera_metadata_data\" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( \"%s: Metadata pointer is not aligned (actual %p, \" \"expected %p) to type %s\" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( \"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( \"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , <vul-end> entry . type <vul-start> . count ) != OK ) { ALOGE ( \"%s: Entry data size is invalid. type: %u count: %u\" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <vul-end> if ( data_size\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ERROR ; } uint32_t entry_count = entry. count ; if ( entry_count == 0 ) { ALOGE ( \"%s: Entry index %zu had no entries\", __FUNCTION__, i ) ; return ERROR ; } <vul-start>. type, entry_count <vul-end> ) ; if\n"
  },
  {
    "id": 434,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , \" ubik call %s\" , tok2str ( ubik_req , \"op#%d\" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , \" syncsite %s\" , temp ? \"yes\" : \"no\" ) ) ; ND_PRINT ( ( ndo , \" votestart\" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , \" dbversion\" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , \" site\" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , \" file\" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , \" pos\" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , \" length\" ) ) ; INTOUT (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( ) ; ND_TCHECK_32BITS ( bp ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; temp = EXTRACT_16BITS <vul-end> ( bp )\n"
  },
  {
    "id": 435,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( \"section len: %u properties %u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <vul-start> ) p + ofs <vul-end> - 2 * <vul-start> sizeof ( uint32_t ) <vul-start> SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\\\n\" , i , <vul-end> inp [ i <vul-start> - p , offs <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { uint32_t p_off ; <vul-start> ) ) ) ; p_off = CDF_GETUINT32 ( p, ( i << 1 ) + 1 ) ; if ( q > e ) goto out <vul-start> ( ( \"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%x max=%u\\\\n\" <vul-end>, i, <vul-start> - p, p_off, <vul-start> ) ) ) ; * info = inp ; * count = i ; * maxcount = i ; return 0\n"
  },
  {
    "id": 436,
    "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <vul-start> if ( iph -> ihl == 5 ) { <vul-end> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <vul-start> } <vul-end> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev",
    "golden_answers": [
      "CWE-665 Fixed Code Lines are: <vul-start> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <vul-start> == 5 ) <vul-end> return 0 ; <vul-start> return 0 ; <vul-end> opt -> optlen\n"
    ],
    "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> == 5 ) <vul-end> return 0 ; <vul-start> return 0 ; <vul-end> opt -> optlen\n"
  },
  {
    "id": 437,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <vul-start> mmu_notifier_mm_init ( mm ) ; <vul-end> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> p ) ; INIT_LIST_HEAD ( & mm -> mm_list ) ;\n"
  },
  {
    "id": 438,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 SEL * selReadStream ( FILE * fp ) { char * selname ; <vul-start> char linebuf [ L_BUF_SIZE ] ; <vul-end> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( \"selReadStream\" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( \"stream not defined\" , procName , NULL ) ; if ( fscanf ( fp , \" Sel Version %d\\\\n\" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( \"not a sel file\" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( \"invalid sel version\" , procName , NULL ) ; <vul-start> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <vul-end> return ( SEL * ) ERROR_PTR ( \"error reading into linebuf\" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <vul-start> sscanf ( linebuf , \" ------ %s ------\" , selname ) ; <vul-end> if ( fscanf ( fp , \" sy = %d, sx = %d, cy = %d, cx = %d\\\\n\" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( \"dimensions not read\" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR (",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char linebuf [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( linebuf , L_BUFSIZE <vul-end> , fp ) <vul-start> ( linebuf , \"  ------  %200s  ------\" <vul-end> , selname )\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char linebuf [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( linebuf, L_BUFSIZE <vul-end>, fp ) <vul-start> ( linebuf, \" ------ %511s ------\" <vul-end>, selname )\n"
  },
  {
    "id": 439,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_svc_init ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * enc_cfg ) { <vul-start> int max_intra_size_pct ; <vul-end> vpx_codec_err_t res ; <vul-start> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <vul-end> if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) { return VPX_CODEC_INVALID_PARAM ; } if ( si == NULL ) return VPX_CODEC_MEM_ERROR ; si -> codec_ctx = codec_ctx ; si -> width = enc_cfg -> g_w ; si -> height = enc_cfg -> g_h ; if ( enc_cfg -> kf_max_dist < 2 ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"key frame distance too small: %d\\\\n\" , enc_cfg -> kf_max_dist ) ; return VPX_CODEC_INVALID_PARAM ; } si -> kf_dist = enc_cfg -> kf_max_dist ; if ( svc_ctx -> spatial_layers == 0 ) svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ; if ( svc_ctx -> spatial_layers < 1 || svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"spatial layers: invalid value: %d\\\\n\" , svc_ctx -> spatial_layers ) ; return VPX_CODEC_INVALID_PARAM ; } <vul-start> res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ; <vul-end> if ( res != VPX_CODEC_OK ) return res ; <vul-start> res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ; <vul-end> if ( res != VPX_CODEC_OK ) <vul-start> memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; <vul-end> res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ; if ( res != VPX_CODEC_OK )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> enc_cfg ) { <vul-end> vpx_codec_err_t res ; <vul-start> vpx_codec_err_t res ; int i ; SvcInternal_t <vul-end> * const si <vul-start> VPX_CODEC_INVALID_PARAM ; } if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } res = parse_options ( svc_ctx , si -> options <vul-end> ) ; if <vul-start> return res ; if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"spatial layers * temporal layers exceeds the maximum number of \" \"allowed layers of %d\\\\n\" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR <vul-end> ) ; if <vul-start> != VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc_enc_init error\\\\n\" ) ; <vul-end> return res ; <vul-start> return res ; } vpx_codec_control <vul-end> ( codec_ctx , <vul-start> ( codec_ctx , VP9E_SET_SVC , 1 ) ; <vul-end> vpx_codec_control ( codec_ctx <vul-start> ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> enc_cfg ) { <vul-end> vpx_codec_err_t res ; <vul-start> = get_svc_internal ( codec_ctx ) ; svc_log ( svc_ctx, SVC_LOG_ERROR, \"svc_init error\\\\n\" <vul-end> ) ; return <vul-start> } res = vpx_svc_set_spatial_layers ( codec_ctx, si ) ; if ( res!= VPX_CODEC_OK ) return res ; res = <vul-start> si -> quantizers_keyframe <vul-end> ) ; if <vul-start>!= VPX_CODEC_OK ) { svc_log ( svc_ctx, SVC_LOG_ERROR, \"vpx_svc_set_quantizer_values error\\\\n\" ) ; return res ; } <vul-start> ( codec_ctx, <vul-end> VP8E_SET_NOISE_SENSITIVITY, 1\n"
  },
  {
    "id": 440,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info !=",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> size_t ) ldblk + 1\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( * BImgBuff ), exception\n"
  },
  {
    "id": 441,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <vul-start> MACROBLOCK * x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; <vul-start> int step_param ; <vul-end> int sadpb = x -> sadperbit16 ; <vul-start> int bestsme = INT_MAX ; <vul-end> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <vul-start> if ( cpi -> speed < 8 ) <vul-end> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <vul-start> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { MACROBLOCK * const x = & cpi -> td . <vul-end> mb ; MACROBLOCKD <vul-start> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <vul-start> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <vul-start> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <vul-end> - 2 ) <vul-start> - 2 ) <vul-end> ; vp9_hex_search ( <vul-start> , 1 , cond_cost_list ( cpi , cost_list ) , <vul-start> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <vul-end> x -> plane\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> & cpi -> td. <vul-start> -> e_mbd ; uint32_t step_param ; uint32_t sadpb = x -> sadperbit8 <vul-end> ; int bestsme <vul-start> bestsme = INT_MAX ; MV best_ref_mv1_full ; MV best_ref_mv1_full ; MV best_ref_mv1_full ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd. mi [ 0 ] -> bmi [ 0 ]. as_mv [ 0 ]. as_mv ; struct buf_2d src = x -> plane [ 0 ]. src ; struct buf_2d pre = xd -> plane [ 0 ]. pre [ 0 ] ; best_ref_mv1_full. col = best_ref_mv1. col >> 3 ; best_ref_mv1_full. row = best_ref_mv1. row >> 3 ; x -> plane [ 0 ]. src. buf = arf_frame_buf ; x -> plane [ 0 ]. src. stride = stride ; xd -> plane [ 0 ]. pre [ 0 ]. buf = frame_ptr_buf ; xd -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = arf_frame_buf ; x -> plane [ 0 ]. src. stride = stride ; xd -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = frame_ptr_buf ; x -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = frame_ptr_buf ; x -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = arf_frame_buf ; x -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = frame_ptr_buf ; x -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf = frame_ptr_buf ; x -> plane [ 0 ]. pre [ 0 ]. stride = stride ; x -> plane [ 0 ]. src. buf"
  },
  {
    "id": 442,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <vul-start> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <vul-end> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ;",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; entries = kmalloc_array ( cmap -> len , <vul-end> sizeof ( * <vul-start> * entries ) , <vul-end> GFP_KERNEL ) ;\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; entries = kzalloc <vul-end> ( sizeof (\n"
  },
  {
    "id": 443,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <vul-start> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <vul-end> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! f2fs_readonly (\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end>! f2fs_readonly (\n"
  },
  {
    "id": 444,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; <vul-start> int procfd = payload -> procfd ; <vul-end> lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; <vul-start> uid_t new_uid ; <vul-end> gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { <vul-start> ERROR ( \"error using IPC to receive notification from initial process (0)\" ) ; <vul-end> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( \"could not ensure correct architecture\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 )",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> -> ipc_socket ; <vul-end> lxc_attach_options_t * options <vul-start> int fd ; int lsm_labelfd ; <vul-start> { ERROR ( \"Error using IPC to receive notification from initial process (0): %s.\" , strerror ( errno ) <vul-end> ) ; shutdown <vul-start> { ERROR ( \"Error using IPC to notify initial process for initialization (1): %s.\" , strerror ( errno ) <vul-end> ) ; shutdown <vul-start> { ERROR ( \"Error using IPC to receive message from initial process \" \"that it is done pre-initializing (2): %s\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <vul-end> if ( ( <vul-start> \"privileges.\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <vul-start> ( \"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \" \"gainable privileges.\" ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"Error using IPC to tell parent to set up LSM labels (3): %s.\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <vul-start> int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( \"Error using IPC for parent to tell us LSM label fd (4): %s.\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <vul-start> ( lsm_set_label_at ( lsm_labelfd <vul-end> , on_exec , <vul-start> 0 ) { SYSERROR ( \"Failed to set LSM label.\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <vul-end> } if ( <vul-start> \"Loading seccomp policy\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <vul-end> lxc_proc_put_context_info ( init_ctx <vul-start> ) ; } <vul-end> rexit ( payload\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> ipc_socket ; <vul-end> lxc_attach_options_t * options <vul-start> int fd ; <vul-end> expected = 0 <vul-start> { ERROR ( \"error using IPC to receive notification from initial process (0)\" <vul-end> ) ; shutdown <vul-start> \"PR_SET_NO_NEW_PRIVS could not be set. \" \"Process can use execve() gainable \" \"privileges.\" ) ; close ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC? 1 : 0 ; if ( lsm_set_label_at ( procfd, on_exec, init_ctx -> lsm_label ) < 0 ) { ERROR ( \"error using IPC to receive final notification from initial process (2)\" ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf )!= 0 ) ) { ERROR ( \"Loading seccomp policy\" ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } } else { ERROR ( \"No new privileges\" ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } lxc_proc_put_context_info ( init_ctx ) ; if ( ( options -> stdin_fd >= 0 && options -> stdin_fd!= 0 ) || ( dup2 ( options -> stdin_fd, 0 )!= 0 ) ) { SYSERROR ( \"could not dup dup2 ( options -> stdin_fd, 1 ) ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( init_ctx -> lsm_label!= 0 ) { int on_exec ; on_exec"
  },
  {
    "id": 445,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , <vul-end> <vul-start> const TileInfo * const tile , <vul-end> int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-end> struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; <vul-start> MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ; <vul-end> <vul-start> MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ; <vul-end> INTERP_FILTER best_pred_filter = EIGHTTAP ; int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG } ; <vul-start> int64_t best_rd = INT64_MAX ; <vul-end> int64_t this_rd = INT64_MAX ; int rate = INT_MAX ; int64_t dist = INT64_MAX ; VP9_COMMON * cm = & cpi -> common ; <vul-start> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <vul-end> const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , <vul-start> intra_cost_penalty , 0 ) ; <vul-end> const int64_t intra_mode_cost = 50 ; unsigned char segment_id = mbmi -> segment_id ; <vul-start> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; <vul-end> <vul-start> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>       void <vul-end> vp9_pick_inter_mode ( VP9_COMP <vul-start> * x , TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; SPEED_FEATURES * const sf = & cpi -> sf ; <vul-end> TileInfo * const <vul-start> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCKD * const <vul-end> xd = & <vul-start> ; MB_MODE_INFO * const <vul-start> ] -> mbmi <vul-end> ; struct macroblockd_plane <vul-start> 0 ] ; PREDICTION_MODE <vul-end> best_mode = ZEROMV <vul-start> best_ref_frame = LAST_FRAME ; MV_REFERENCE_FRAME usable_ref_frame ; TX_SIZE best_tx_size = TX_SIZES <vul-start> VP9_ALT_FLAG } ; RD_COST this_rdc , best_rdc ; uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; unsigned int var_y = UINT_MAX ; unsigned int sse_y = UINT_MAX ; const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; const <vul-end> int intra_cost_penalty = <vul-start> int intra_cost_penalty = vp9_get_intra_cost_penalty ( <vul-end> cm -> base_qindex <vul-start> cm -> y_dc_delta_q , cm -> bit_depth ) >> reduction_fac <vul-end> ; const int64_t <vul-start> , 0 ) <vul-end> ; const int <vul-start> = cpi -> rd . threshes [ mbmi -> <vul-end> segment_id ] [ <vul-start> const rd_thresh_freq_fact = tile_data -> thresh_freq_fact <vul-end> [ bsize ] <vul-start> [ bsize ] <vul-end> ; INTERP_FILTER filter_ref <vul-start> ; INTERP_FILTER filter_ref ; const int bsl = mi_width_log2_lookup [ bsize ] ; const int pred_filter_search = cm -> <vul-end> interp_filter == SWITCHABLE <vul-start> == SWITCHABLE ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int const_motion [ MAX_REF_FRAMES ] = { 0 } ; const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; PRED_BUFFER tmp [ 4 ] ; DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; # endif struct buf_2d orig_dst = pd -> dst ; PRED_BUFFER * best_pred = NULL ; PRED_BUFFER * this_mode_pred = NULL ; const int pixels_in_block = bh * bw ; int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; int ref_frame_skip_mask = 0 ; int idx ; int best_pred_sad = INT_MAX ; int best_early_term = 0 ; int ref_frame_cost [ MAX_REF_FRAMES ] ; init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; if ( reuse_inter_pred ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # endif tmp [ i ] . stride = bw ; tmp [ i ] . in_use = 0 ; } tmp [ 3 ] . data = pd -> dst . buf ; tmp [ 3 ] . stride = pd -> dst . stride ; tmp [ 3 ] . in_use = 0 ; } x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x <vul-end> -> skip = <vul-start> = 0 ; <vul-end> if ( xd <vul-start> . interp_filter ; else filter_ref = cm -> interp_filter ; vp9_rd_cost_reset ( & best_rdc ) ; vp9_rd_cost_reset ( rd_cost ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; # if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ; # endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { usable_ref_frame = LAST_FRAME ; } else { usable_ref_frame = GOLDEN_FRAME ; } <vul-start> ; ref_frame <= usable_ref_frame <vul-end> ; ++ ref_frame <vul-start> ref_frame ) { const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; x -> pred_mv_sad [ ref_frame ] = INT_MAX ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ; if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ; else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ; <vul-start> if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ; } else { ref_frame_skip_mask |= ( 1 << ref_frame ) ; } } for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { int rate_mv = 0 ; int mode_rd_thresh ; int mode_index ; int i ; int64_t this_sse ; int is_skippable ; int this_early_term = 0 ; PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ; if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ; ref_frame = ref_mode_set [ idx ] . ref_frame ; if ( cpi -> use_svc ) ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; if ( ! <vul-start> ) continue ; if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ; i = <vul-end> ( ref_frame == <vul-start> == LAST_FRAME ) ? GOLDEN_FRAME : LAST_FRAME ; if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) ref_frame_skip_mask |= <vul-end> ( 1 << <vul-start> ( 1 << ref_frame ) ; if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; mbmi -> ref_frame [ 0 ] = ref_frame ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; mode_index = mode_idx [ ref_frame ] [ <vul-start> ( this_mode ) ] ; mode_rd_thresh = best_mode_skip_txfm ? rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) <vul-end> ) continue ; <vul-start> NEWMV ) { if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { int tmp_sad ; int dis , cost_list [ 5 ] ; if ( bsize < BLOCK_16X16 ) continue ; tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ; if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) continue ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr <vul-end> [ bsize ] <vul-start> [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { continue ; } } if ( this_mode == NEWMV && ref_frame == LAST_FRAME && frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; } if ( cpi -> use_svc ) { if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && <vul-end> frame_mv [ NEWMV <vul-start> NEWMV ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + <vul-end> ( frame_mv [ <vul-start> NEWMV ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; } <vul-end> } if ( <vul-start> this_mode != NEARESTMV && <vul-end> frame_mv [ this_mode <vul-start> . as_int ; if ( reuse_inter_pred ) { if ( ! this_mode_pred ) { this_mode_pred = & tmp [ 3 ] ; } else { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = bw ; } } <vul-start> SWITCHABLE ) && pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && ( <vul-start> as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) <vul-start> ) != 0 ) ) { <vul-end> int pf_rate [ <vul-start> 3 ] ; unsigned int pf_var [ 3 ] ; unsigned int pf_sse [ 3 ] ; TX_SIZE pf_tx_size [ 3 ] ; int64_t best_cost = INT64_MAX ; INTERP_FILTER best_filter = SWITCHABLE , filter ; PRED_BUFFER * current_pred = this_mode_pred ; for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { int64_t cost ; <vul-start> -> interp_filter = filter <vul-end> ; vp9_build_inter_predictors_sby ( <vul-start> & pf_rate [ filter ] , <vul-end> & pf_dist [ <vul-start> & pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ; pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; cost <vul-end> = RDCOST ( <vul-start> -> rddiv , pf_rate [ filter ] , pf_dist [ filter ] ) ; pf_tx_size [ filter ] = mbmi -> tx_size ; if ( cost < best_cost ) { best_filter = filter ; best_cost = cost ; skip_txfm = x -> skip_txfm [ 0 ] ; if ( reuse_inter_pred ) { if ( this_mode_pred != current_pred ) { free_pred_buffer ( this_mode_pred ) ; this_mode_pred = current_pred ; } if ( filter < EIGHTTAP_SHARP ) { current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = current_pred -> data ; pd -> dst . stride = bw ; } } } } if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ; mbmi -> interp_filter = best_filter ; mbmi -> tx_size = pf_tx_size [ best_filter ] ; this_rdc . rate = pf_rate [ best_filter ] ; this_rdc . dist = pf_dist [ best_filter ] ; var_y = pf_var [ best_filter ] ; sse_y = pf_sse [ best_filter ] ; x -> skip_txfm [ 0 ] = skip_txfm ; if ( reuse_inter_pred ) { pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = this_mode_pred -> stride ; } <vul-end> } else { <vul-start> bsize ) ; if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) { model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , & this_early_term ) ; } else { <vul-start> xd , & this_rdc . <vul-start> rate , & this_rdc . dist , & var_y , & sse_y ) ; } } if ( ! this_early_term ) { this_sse = ( int64_t ) sse_y ; block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; x -> skip_txfm [ 0 ] = is_skippable ; if ( is_skippable ) { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else { if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; this_rdc . dist = this_sse ; x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } } if ( cm -> interp_filter == SWITCHABLE ) { if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; } } else { this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { int uv_rate = 0 ; int64_t uv_dist = 0 ; if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ; this_rdc . rate += uv_rate ; this_rdc . dist += uv_dist ; } this_rdc . <vul-end> rate += rate_mv <vul-start> += rate_mv ; this_rdc . rate += cpi <vul-end> -> inter_mode_cost [ <vul-start> -> inter_mode_cost [ x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; this_rdc . rate += ref_frame_cost [ ref_frame ] ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( cpi -> allow_encode_breakout ) { encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & this_rdc . rate , & this_rdc . dist ) ; if ( x -> skip ) { this_rdc . rate += rate_mv ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } } # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; # else ( void ) ctx ; # endif if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { best_rdc = this_rdc <vul-end> ; best_mode = <vul-start> -> interp_filter ; best_tx_size = mbmi -> tx_size ; <vul-start> = ref_frame ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; best_early_term = this_early_term ; if ( reuse_inter_pred ) { free_pred_buffer ( best_pred ) ; best_pred = this_mode_pred ; } } else { if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ; } if ( x -> skip ) break ; if ( best_early_term && idx > 0 ) { x -> skip = 1 ; break ; <vul-end> } } mbmi <vul-start> ; mbmi -> tx_size = best_tx_size ; mbmi -> <vul-start> . as_int ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) { struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; int i ; TX_SIZE best_intra_tx_size = TX_SIZES ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data == orig_dst . buf ) { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif best_pred = this_mode_pred ; } } pd -> dst = orig_dst ; for ( i = 0 ; i < 4 ; ++ i ) { const PREDICTION_MODE this_mode = intra_mode_list [ i ] ; THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; int mode_rd_thresh = rd_threshes [ mode_index ] ; if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; args . mode = this_mode ; args . rate = 0 ; args . dist = 0 ; mbmi -> tx_size = intra_tx_size ; vp9_foreach_transformed_block_in_plane <vul-end> ( xd , <vul-start> ( xd , bsize , 0 , estimate_block_intra , & args ) ; this_rdc . rate = args . rate ; this_rdc . dist = args . dist ; this_rdc . rate += cpi <vul-end> -> mbmode_cost [ <vul-start> this_mode ] ; this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; this_rdc . <vul-start> += intra_cost_penalty ; this_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , this_rdc . rate , this_rdc . <vul-end> dist ) ; <vul-start> ; if ( this_rdc . rdcost < best_rdc . rdcost ) { best_rdc = this_rdc ; best_mode = this_mode ; best_intra_tx_size = mbmi -> tx_size ; best_ref_frame = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; } } if ( best_ref_frame != INTRA_FRAME ) { mbmi -> tx_size = best_tx_size ; } else { mbmi -> tx_size = best_intra_tx_size ; } } pd -> dst = orig_dst ; mbmi -> mode = best_mode ; mbmi -> ref_frame [ 0 ] = best_ref_frame ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif } } if ( cpi -> sf . adaptive_rd_thresh ) { THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; if ( best_ref_frame == INTRA_FRAME ) { int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; int i ; for ( i = 0 ; i < intra_modes ; i ++ ) { update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ; } } else { for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { PREDICTION_MODE this_mode ; if ( best_ref_frame != ref_frame ) continue ; for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ; } } } } * rd_cost = best_rdc <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       void <vul-end> vp9_pick_inter_mode ( VP9_COMP <vul-start> * cpi, MACROBLOCKD * xd, <vul-start> TileInfo * const tile_info <vul-end>, int mi_row <vul-start> -> e_mbd ; MB_MODE_INFO_EXT * const mbmi_ext = & xd -> mbmi_ext ; <vul-start> 0 ] ; PREDICTION_MODE <vul-end> this_mode, best_mode <vul-start>, best_mode = LAST_FRAME ; INTERP_FILTER best_pred_filter = PREDICTION_MODE <vul-end> ; int_mv frame_mv <vul-start> VEROMV ; MV_REFERENCE_FRAME ref_frame, best_ref_frame = LAST_FRAME ; INTERP_FILTER best_pred_filter = PREDICTION_FILTER <vul-end> ; int_mv frame_mv <vul-start> VEROMV ; INTERP_FILTER best_pred_filter = PREDICTION_FILTER <vul-end> ; int_mv frame_mv <vul-start> -> common ; const int64_t inter_cost_penalty = cpi -> bd_inter_cost_penalty ; const int64_t intra_cost_penalty_cost = cpi -> bd_inter_cost_penalty <vul-end> ; const int64_t <vul-start>, intra_cost_penalty, PREDICTION_MODE <vul-end> ) ; const <vul-start> ; const int64_t <vul-end> rate_mode = 0 <vul-start> ; const int rd_threshes [ segment_id ] [ bsize ] ; const int * const rd_thresh_freq_fact [ BLOCK_SIZE bsize ] ; int mode_idx [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int64_t dist = INT64_MAX ; int64_t best_rd = INT64_MAX ; int64_t best_ref_frame = LAST_FRAME ; int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int_mv dist <vul-end> ; unsigned char <vul-start> segment_id ; const int * const rd_threshes [ segment_id ] [ bsize ] ; int mode_idx [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int <vul-end> mode_idx [ SWITCHABLE <vul-start> { int rate_mode"
  },
  {
    "id": 446,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <vul-start> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <vul-end> if ( ses ) { cFYI ( 1 , \"Existing smb sess found (status=%d)\" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , \"Session needs reconnect\" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , \"Existing smb sess not found\" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , \"%pI6\" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses ->",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> server , volume_info <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> volume_info -> username, 0\n"
  },
  {
    "id": 447,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else { <vul-start> return rold -> umin_value == 0 && <vul-end> rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> else { return false <vul-end> ; } case\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> else { return tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold, rcur, offsetof ( struct bpf_reg_state, id ) ) == 0 && range_within ( rold, rcur ) && tnum_in ( rold -> var_off, rcur -> var_off ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : return tnum_is_unknown ( rold -> var_off ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : return <vul-start> rold -> umin_value!= 0 && rold -> umax_value!= U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : return memcmp ( rold, rcur, offsetof ( struct bpf_reg_state, id ) ) == 0 && range_within ( rold, rcur ) && tnum_in ( rold -> var_off, rcur -> var_off ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : return memcmp ( rold, rcur, offsetof ( struct bpf_reg_state, id ) ) == 0 && range_within ( rold, rcur ) && tnum_in ( rold -> var_off, rcur -> var_off ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET_END : default : return false ; } WARN_ON ( 1 ) ; return true ; } <vul-end> }    \n"
  },
  {
    "id": 448,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( (",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ipv6_select_ident ( fh , rt <vul-start> ipv6_select_ident ( fh , rt\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ipv6_select_ident ( fh, rt\n"
  },
  {
    "id": 449,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <vul-start> ybf -> uv_width = uv_width ; <vul-end> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; ybf -> uv_stride = uv_stride ; ybf ->\n"
  },
  {
    "id": 450,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> RT_ENCODED ) && ( ( number_pixels * <vul-end> sun_info . depth <vul-start> sun_info . depth ) > ( 8 * <vul-end> sun_info . length <vul-start> sun_info . length ) <vul-start> ( bytes_per_line + bytes_per_line <vul-end> % 2 )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>!= RT_ENCODED ) || <vul-end> ( ( number_pixels <vul-start> sun_info. depth > <vul-end> 8 ) && <vul-start>. length ) ) { if ( q == ( Quantum * ) NULL ) break ; <vul-end> ThrowReaderException ( ResourceLimitError <vul-start> \"MemoryAllocationFailed\" ) ; }\n"
  },
  {
    "id": 451,
    "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? \"*\" : sptr -> name ) ; return 0 ; } <vul-start> if ( strlen ( parv [ 1 ] ) > 400 ) <vul-end> { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? \"*\" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? \"0\" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , \"certfp\" ) ; sendto_server ( NULL , 0 , 0 , \":%s SASL %s %s H %s %s\" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , \":%s SASL %s %s S %s %s\" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , \":%s",
    "golden_answers": [
      "CWE-287 Fixed Code Lines are: <vul-start> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , ' ' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , \"*\" , \"AUTHENTICATE\" , \"Invalid parameter\" ) ; return 0 ; } if (\n"
    ],
    "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> } if ( BadPtr ( sptr -> name ) ) { sendto_one ( sptr, err_str ( ERR_SASLINVALID ), me. name, BadPtr ( sptr -> name )? \"*\" : sptr -> name ) ; return 0 ; } if (\n"
  },
  {
    "id": 452,
    "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 gboolean flatpak_run_add_environment_args ( FlatpakBwrap * bwrap , const char * app_info_path , FlatpakRunFlags flags , const char * app_id , FlatpakContext * context , GFile * app_id_dir , GPtrArray * previous_app_id_dirs , FlatpakExports * * exports_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autoptr ( FlatpakBwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = FALSE ; gboolean allow_x11 = FALSE ; if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) { g_debug ( \"Disallowing ipc access\" ) ; flatpak_bwrap_add_args ( bwrap , \"--unshare-ipc\" , NULL ) ; } if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) { g_debug ( \"Disallowing network access\" ) ; flatpak_bwrap_add_args ( bwrap , \"--unshare-net\" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) { flatpak_bwrap_add_args ( bwrap , \"--dev-bind\" , \"/dev\" , \"/dev\" , NULL ) ; if ( g_file_test ( \"/dev/shm\" , G_FILE_TEST_IS_DIR ) ) { if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , \"--tmpfs\" , \"/dev/shm\" , NULL ) ; } else if ( g_file_test ( \"/dev/shm\" , G_FILE_TEST_IS_SYMLINK ) ) { g_autofree char * link = flatpak_readlink ( \"/dev/shm\" , NULL ) ; if ( g_strcmp0 ( link , \"/run/shm\" ) == 0 ) { if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( \"/run/shm\" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , \"--bind\" , \"/run/shm\" , \"/run/shm\" , NULL ) ; else flatpak_bwrap_add_args",
    "golden_answers": [
      "CWE-74 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! flatpak_run_in_transient_unit (\n"
    ],
    "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> flags ) ; <vul-end> } if (\n"
  },
  {
    "id": 453,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = \"INVALID_S4U2SELF_REQUEST\" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start>, request, <vul-end> no_server, kdc_time\n"
  },
  {
    "id": 454,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <vul-start> f2fs_wait_discard_bios ( sbi ) ; <vul-end> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> f2fs_wait_discard_bios ( sbi , true\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> f2fs_wait_discard_bios ( sbi, false\n"
  },
  {
    "id": 455,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int rfcomm_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { <vul-start> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <vul-end> struct sock * sk = sock -> sk ; <vul-start> int chan = sa -> rc_channel ; <vul-end> <vul-start> int err = 0 ; <vul-end> BT_DBG ( \"sk %p %pMR\" , sk , & sa -> rc_bdaddr ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; <vul-start> lock_sock ( sk ) ; <vul-end> if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; goto done ; } write_lock ( & rfcomm_sk_list . lock ) ; <vul-start> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { <vul-end> err = - EADDRINUSE ; } else { <vul-start> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; <vul-end> <vul-start> rfcomm_pi ( sk ) -> channel = chan ; <vul-end> sk -> sk_state = BT_BOUND ; } write_unlock ( & rfcomm_sk_list . lock ) ; done : release_sock ( sk ) ; return err ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> { struct sockaddr_rc sa <vul-end> ; struct sock <vul-start> sk ; int len , <vul-end> err = 0 <vul-start> err = 0 <vul-end> ; if ( <vul-start> - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( \"sk %p %pMR\" , sk , & sa . rc_bdaddr ) ; <vul-start> ; if ( sa . rc_channel <vul-end> && __rfcomm_get_listen_sock_by_addr ( <vul-start> && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <vul-end> rc_bdaddr ) ) <vul-start> , & sa . <vul-end> rc_bdaddr ) ; <vul-start> -> channel = sa . rc_channel <vul-end> ; sk ->\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> addr_len ) { <vul-end> struct sock * <vul-start> -> sk ; <vul-end> int err = <vul-start> err = 0 <vul-end> ; if ( <vul-start> - EINVAL ; <vul-end> write_lock ( & <vul-start> ; if ( addr_len < sizeof ( struct sockaddr_rc ) ) { err = - EINVAL ; goto done ; } if ( <vul-start> && __rfcomm_get_listen_sock_by_addr ( addr_len <vul-end>, & sa <vul-start> } else { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <vul-start> sk ) -> src_bacpy <vul-end> ( & rfcomm_pi <vul-start> ) -> channel, sa -> rc_channel\n"
  },
  {
    "id": 456,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"buffer too small (%d < 640).\\\\n\" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\\\n\" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , \"interlaced %d, cur field %d\\\\n\" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] >> 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"mb height too big: %d\\\\n\" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <vul-end> ( ctx -> <vul-start> AVERROR_INVALIDDATA ; } <vul-end> if ( buf_size\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ctx -> mb_height >= 68 || ( ctx -> mb_height << frame -> interlaced_frame ) <vul-start> data_offset = 0x280 + ( ctx -> mb_height << frame -> interlaced_frame )\n"
  },
  {
    "id": 457,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( \"Interrupt %d, without any data\\\\n\" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( \"MUX error, status is %02x, data is %02x\\\\n\" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT &&",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( likely ( serio <vul-end> && ! filtered\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( likely (! filtered && <vul-start> port -> exists <vul-end> ) ) serio_interrupt\n"
  },
  {
    "id": 458,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; ssize_t bit ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; <vul-start> switch ( quantum_info -> depth ) <vul-end> { case 1 : { register Quantum black , white ; black = 0 ; white = QuantumRange ; if ( quantum_info -> min_is_white != MagickFalse ) { black = QuantumRange ; white = 0 ; } for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } case 4 :",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> MagickCoreSignature ) ; pixel = 0 ;\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> MagickCoreSignature ) ; if ( quantum_info -> depth > GetQuantumMaxDepth ( quantum_info -> depth ) ) { q = QuantumRange ; q += GetPixelChannels ( image ) ; p += quantum_info -> pad ; q += GetPixelChannels ( image ) ; }\n"
  },
  {
    "id": 459,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , key_perm_t perm ) { struct keyring_search_context ctx = { . match_data . cmp = lookup_user_key_possessed , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_NO_STATE_CHECK , } ; struct request_key_auth * rka ; struct key * key ; key_ref_t key_ref , skey_ref ; int ret ; try_again : ctx . cred = get_current_cred ( ) ; key_ref = ERR_PTR ( - ENOKEY ) ; switch ( id ) { case KEY_SPEC_THREAD_KEYRING : if ( ! ctx . cred -> thread_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_thread_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> thread_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_PROCESS_KEYRING : if ( ! ctx . cred -> process_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_process_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> process_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_SESSION_KEYRING : if ( ! ctx . cred -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; if (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <vul-end> ) goto invalid_key\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) &&! key_read_state ( key <vul-end> ) ) goto\n"
  },
  {
    "id": 460,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_expr ( void * _o ) { expr_ty o = ( expr_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } switch ( o -> kind ) { case BoolOp_kind : result = PyType_GenericNew ( BoolOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_boolop ( o -> v . BoolOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . BoolOp . values , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_values , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case BinOp_kind : result = PyType_GenericNew ( BinOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . BinOp . left ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_left , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . BinOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) ==",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
  },
  {
    "id": 461,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t vp8_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; unsigned int resolution_change = 0 ; unsigned int w , h ; <vul-start> if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) <vul-end> return res ; w = ctx -> si . w ; h = ctx -> si . h ; res = vp8_peek_si_internal ( ctx -> fragments . ptrs [ 0 ] , ctx -> fragments . sizes [ 0 ] , & ctx -> si , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( ( res == VPX_CODEC_UNSUP_BITSTREAM ) && ! ctx -> si . is_kf ) { res = VPX_CODEC_OK ; } if ( ! ctx -> decoder_init && ! ctx -> si . is_kf ) res = VPX_CODEC_UNSUP_BITSTREAM ; if ( ( ctx -> si . h != h ) || ( ctx -> si . w != w ) ) resolution_change = 1 ; <vul-start> if ( ! res && ctx -> defer_alloc ) <vul-end> { int i ; for ( i = 1 ; ! res && i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { vpx_codec_dec_cfg_t cfg ; cfg . w = ctx -> si . w ; cfg . h = ctx -> si . h ; ctx -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> mmaps [ i ] . sz =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( <vul-start> ! res && ! <vul-end> ctx -> decoder_init <vul-start> ctx -> decoder_init <vul-end> ) { VP8D_CONFIG <vul-start> ; ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> <vul-start> ctx -> decrypt_state <vul-end> ; } if <vul-start> = 0 ; vp8_clear_system_state ( ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, & res, deadline <vul-start> ; if ( ctx -> decoder_init && <vul-start> = 1 ; ctx -> si. w = ctx -> si. h ; ctx -> si. h = ctx -> si. w ; <vul-start> return - 1 ; } if (! res && ctx -> decoder_init ) { int i <vul-start> oxcf ) ; if (! ctx -> decoder_init ) { ctx -> decoder_init = 1 ; ctx -> si. w = 0 ; ctx -> si. h = 0 ; } if (! ctx -> decoder_init ) { ctx -> decoder_init = 0 ; ctx -> si. w = ctx -> si. w ; ctx -> si. h = ctx -> si. h ; } ctx -> postproc_cfg. post_proc_flag = VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE ; ctx -> postproc_cfg. noise_level = 0 ; } res = vp8_create_decoder_instances ( & ctx -> si, data, data_sz, & ctx -> decrypt_cb, ctx -> decrypt_state ) ; if (! res && ctx -> defer_alloc ) { int i ; for ( i = 1 ; i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { VP8D_COMMON * const pc = & ctx -> mmaps [ i ] ; vp8_build_block_doffsets ( & ctx -> mmaps [ i ]. mbd ) ; if (! ctx -> mmaps [ i ]. pre ) { ctx -> postproc_cfg. pre = 0 ; ctx -> postproc_cfg. pre = 0 ; ctx -> postproc_cfg. noise_level = ctx -> postproc_cfg. noise_level ; } ctx -> postproc_cfg. noise_level = ctx -> postproc_cfg. noise_level ; } ctx -> decoder_init = 1 ; } if (! res ) { ctx -> si. w = ctx -> si. w ; ctx -> si. h = ctx -> si. h ; vp8_build_block_doffsets ( & ctx -> mmaps [ i ]. mbd ) ; } if (! ctx -> decoder_init ) { ctx -> si. w = ctx -> si. w ; ctx -> si. h = ctx -> si. h ; vp8"
  },
  {
    "id": 462,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <vul-start> in_what_stride",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> best_address , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here , in_what_stride <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> best_address, in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here, in_what_stride <vul-end> ) ; if\n"
  },
  {
    "id": 463,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc28j60Init ( NetInterface * interface ) { uint8_t revisionId ; Enc28j60Context * context ; TRACE_INFO ( \"Initializing ENC28J60 Ethernet controller...\\\\r\\\\n\" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; enc28j60SoftReset ( interface ) ; sleep ( 10 ) ; context = ( Enc28j60Context * ) interface -> nicContext ; context -> currentBank = UINT16_MAX ; context -> nextPacket = ENC28J60_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } <vul-start> revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ; <vul-end> TRACE_INFO ( \"ENC28J60 revision ID: 0x%02X\\\\r\\\\n\" , revisionId ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ; <vul-end> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR1 , interface -> macAddr . b [ 0 ] ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC28J60_EREVID <vul-end> ) ; TRACE_INFO <vul-start> ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR4 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR3 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR2 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR1 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR0 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_ERXSTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXSTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXNDL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXNDH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_MAMXFLH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT <vul-end> ) ; # <vul-start> ( interface , ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_PHCON1 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS <vul-end> ) ; enc28j60WritePhyReg <vul-start> ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE <vul-end> ) ; enc28j60WritePhyReg <vul-start> ( interface , ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE <vul-end> ) ; enc28j60SetBit <vul-start> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN <vul-end> ) ; enc28j60DumpReg\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC28J60_EREVID <vul-end> ) ; TRACE_INFO <vul-start> ( interface, ENC28J60_ECOCON <vul-end>, 0x00 ) <vul-start> ( interface, ENC28J60_MAADR1, interface -> macAddr. b [ 0 ] ) ; enc28j60WriteReg ( interface, ENC28J60_MAADR2 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_MAADR3 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_MAADR4, interface -> macAddr. b [ 2 ] ) ; enc28j60WriteReg ( interface, ENC28J60_MAADR5, interface -> macAddr. b [ 3 ] ) ; enc28j60WriteReg ( interface, ENC28J60_MAADR6 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_ERXFCON, ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN <vul-end> ) ; enc28j60WriteReg <vul-start> ( interface, ENC28J60_EIPSTH <vul-end>, 0x15 ) <vul-start> ( interface, ENC28J60_ECOCON <vul-end>, 0x12 ) <vul-start> ( interface, ENC28J60_EIPG <vul-end>, 0x12 ) <vul-start> ( interface, ENC28J60_EIPGH <vul-end>, 0x0 ) <vul-start> ( interface, ENC28J60_MACLCON2, 63 <vul-end> ) ; # <vul-start> ( interface, ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED ) enc28j60WritePhyReg ( interface, ENC28J60_PHCON1, ENC28J60_PHCON1_PDPXMD ) ; enc28j60WriteReg ( interface, ENC28J60_PHCON2, ENC28J60_PHCON2_HDLDIS ) ; enc28j60WritePhyReg ( interface, ENC28J60_EIPFCON, ENC28J60"
  },
  {
    "id": 464,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , \"echo %s, id %u, seq %u\" , dp -> icmp_type == ICMP_ECHO ? \"request\" : \"reply\" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> if ( sum == 0 || sum\n"
  },
  {
    "id": 465,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ;",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <vul-start> ) goto out_free <vul-end> ; r = <vul-start> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <vul-start> return 0 ; out_slots : kfree ( slots ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> srcu ) ; kvm_iommu_unmap_pages ( kvm, & old ) ; <vul-start> r ) goto out_free <vul-end> ; r = <vul-start> goto out_free ; <vul-end> update_memslots ( slots <vul-start> return 0 ; out_free : kvm_free_pages ( kvm, & old ) ; <vul-end> kfree ( old_memslots\n"
  },
  {
    "id": 466,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ; <vul-start> if ( ! asoc -> temp ) { <vul-end> list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> if ( ! list_empty ( & asoc -> asocs ) <vul-end> ) { list_del\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> asoc -> temp &&! asoc -> peer. transport_count\n"
  },
  {
    "id": 467,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> , VCPU_SREG_LDTR , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if\n"
  },
  {
    "id": 468,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) { <vul-start> tlv = cp + i ; <vul-end> type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , \"\\\\n\" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , \"\\\\t\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( dh4opt_str , \"Unknown\" , type ) ) ) ; <vul-start> ND_PRINT ( ( ndo , \" (%u)\" , optlen + 2 ) ) ; <vul-end> switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , \" %s\" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , \" \" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return -",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i + 2 > length ) return - 1 ; <vul-start> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i + 2 > length ) return - 1 ; <vul-start> 2 ) ) ; if ( i + 2 < length ) return - 1\n"
  },
  {
    "id": 469,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame skip %d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode: %3X \" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Start\" ) ;",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> studio_profile ) { <vul-end> if ( !\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> studio_profile ) { if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx, \"Mixes studio and non studio profile\\\\n\" ) ; return AVERROR_PATCHWELCOME ; }\n"
  },
  {
    "id": 470,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <vul-start> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <vul-end> ea_idebug ( inode , \"buffer=%p, buffer_size=%ld\" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , \"reading block %llu\" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , \"b_count=%d, refcount=%d\" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , \"bad block %llu\" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> error ; struct mb2_cache <vul-end> * ext4_mb_cache =\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> error ; struct mb2_cache <vul-end> * ext4_mb_cache =\n"
  },
  {
    "id": 471,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"nreslevels2decode %d invalid or uninitialized\\\\n\" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> band = av_calloc <vul-end> ( reslevel -> <vul-start> -> prec = av_calloc <vul-end> ( reslevel ->\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> log2_prec_height ) ; if ( reslevel -> nbands > MAX_RESLEVELS ) return AVERROR_INVALIDDATA ; <vul-start> -> band = av_calloc ( <vul-end> reslevel -> nbands <vul-start> reslevel -> nbands * <vul-end> sizeof ( *\n"
  },
  {
    "id": 472,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ast_type_init ( PyObject * self , PyObject * args , PyObject * kw ) { <vul-start> _Py_IDENTIFIER ( _fields ) ; <vul-end> Py_ssize_t i , numfields = 0 ; int res = - 1 ; PyObject * key , * value , * fields ; <vul-start> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <vul-end> if ( ! fields ) PyErr_Clear ( ) ; if ( fields ) { numfields = PySequence_Size ( fields ) ; if ( numfields == - 1 ) goto cleanup ; } res = 0 ; <vul-start> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <vul-end> if ( numfields != PyTuple_GET_SIZE ( args ) ) { <vul-start> PyErr_Format ( PyExc_TypeError , \"%.400s constructor takes %s\" <vul-end> \"%zd positional argument%s\" , <vul-start> Py_TYPE ( self ) -> tp_name , <vul-end> numfields == 0 ? \"\" : \"either 0 or \" , numfields , numfields == 1 ? \"\" : \"s\" ) ; res = - 1 ; goto cleanup ; } for ( i = 0 ; i < PyTuple_GET_SIZE ( args ) ; i ++ ) { PyObject * name = PySequence_GetItem ( fields , i ) ; if ( ! name ) { res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self , name , PyTuple_GET_ITEM ( args , i ) ) ; Py_DECREF ( name ) ; if ( res < 0 ) goto cleanup ; } <vul-start> } <vul-end> if ( kw ) { i = 0 ; while",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> kw ) { <vul-end> Py_ssize_t i , <vul-start> * fields ; if ( lookup_attr_id <vul-end> ( ( PyObject <vul-start> , & PyId__fields , & fields ) < 0 ) { goto cleanup ; } <vul-end> if ( fields <vul-start> ; if ( numfields < <vul-start> ( args ) <vul-end> ) { PyErr_Format <vul-start> ( PyExc_TypeError , \"%.400s constructor takes at most \" <vul-end> \"%zd positional argument%s\" , Py_TYPE <vul-start> ) -> tp_name <vul-end> , numfields , <vul-start> cleanup ; } <vul-end> if ( kw\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> kw ) { <vul-end> Py_ssize_t i, <vul-start> * fields ; PyObject * type = <vul-end> Py_TYPE ( self <vul-start> Py_TYPE ( self ) ; fields = lookup_attr_id ( type <vul-start>, & PyId__fields ) ; if (! fields ) return - 1 ; PyObject * type_ref = Py_None ; if (! type_ref ) { PyErr_Clear ( ) ; type_ref = Py_None ; } res = - 1 ; PyObject * key, * value, * fields ; if (! type_ref ) { PyErr_Clear ( ) ; if (! type_ref ) { PyErr_Clear ( ) ; res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self, type_ref, PyTuple_GET_ITEM ( args, 0 ) ) ; Py_DECREF ( type_ref ) ; if ( res < 0 ) goto cleanup ; } if ( kw ) { i = 0 ; while ( PyDict_Next ( kw, & i, & key, & value ) ) { res = PyObject_SetAttr ( self, key, value ) ; if ( res < 0 ) goto cleanup ; } } if ( kw ) { i = 0 ; while ( PyDict_Next ( kw, & i, & key, & value ) ) { res = PyObject_SetAttr ( self, key, value ) ; if ( res < 0 ) goto cleanup ; } } if ( kw ) { i = 0 ; while ( PyDict_Next ( kw, & i, & key, & value ) ) { res = PyObject_SetAttr ( self, key, value ) ; if ( res < 0 ) goto cleanup ; } } cleanup : Py_XDECREF ( fields ) ; return res ; } <vul-end> }    \n"
  },
  {
    "id": 473,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , \"blacklisted by %s\\\\n\" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; out1 : cancel_autoload_drivers ( ) ;\n"
  },
  {
    "id": 474,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) { mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; mpi_ptr_t xp_marker = NULL ; mpi_ptr_t tspace = NULL ; mpi_ptr_t rp , ep , mp , bp ; mpi_size_t esize , msize , bsize , rsize ; int esign , msign , bsign , rsign ; mpi_size_t size ; int mod_shift_cnt ; int negative_result ; int assign_rp = 0 ; mpi_size_t tsize = 0 ; int rc = - ENOMEM ; esize = exp -> nlimbs ; msize = mod -> nlimbs ; size = 2 * msize ; esign = exp -> sign ; msign = mod -> sign ; rp = res -> d ; ep = exp -> d ; if ( ! msize ) return - EINVAL ; if ( ! esize ) { <vul-start> rp [ 0 ] = 1 ; <vul-end> <vul-start> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <vul-end> res -> sign = 0 ; goto leave ; } mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; if ( mod_shift_cnt ) mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; else MPN_COPY ( mp , mod -> d , msize ) ; bsize = base -> nlimbs ; bsign = base -> sign ; if",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> esize ) { <vul-end> res -> nlimbs <vul-start> : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> esize ) { <vul-end> res -> nlimbs <vul-start>? 0 : 2 * msize <vul-end> ; res ->\n"
  },
  {
    "id": 475,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <vul-start> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <vul-end> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ( 2 * ( sqlite3_int64 )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>, pList, 2 * ( <vul-start> pList -> nExpr + 1 )\n"
  },
  {
    "id": 476,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int rd_pick_intra4x4mby_modes ( MACROBLOCK * mb , int * Rate , int * rate_y , int * Distortion , int best_rd ) { MACROBLOCKD * const xd = & mb -> e_mbd ; int i ; int cost = mb -> mbmode_cost [ xd -> frame_type ] [ B_PRED ] ; int distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; const int * bmode_costs ; <vul-start> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> <vul-start> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; intra_prediction_down_copy ( xd , xd -> dst . y_buffer - xd -> dst . y_stride + 16 ) ; bmode_costs = mb -> inter_bmode_costs ; for ( i = 0 ; i < 16 ; i ++ ) { MODE_INFO * const mic = xd -> mode_info_context ; const int mis = xd -> mode_info_stride ; B_PREDICTION_MODE UNINITIALIZED_IS_SAFE ( best_mode ) ; int UNINITIALIZED_IS_SAFE ( r ) , UNINITIALIZED_IS_SAFE ( ry ) , UNINITIALIZED_IS_SAFE ( d ) ; if ( mb -> e_mbd . frame_type == KEY_FRAME ) { const B_PREDICTION_MODE A = above_block_mode ( mic , i , mis ) ; const B_PREDICTION_MODE L = left_block_mode ( mic , i ) ; bmode_costs = mb -> bmode_costs [ A ] [ L ]",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * bmode_costs ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * bmode_costs ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left\n"
  },
  {
    "id": 477,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <vul-start> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <vul-end> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <vul-end> ) put_cmsg (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> & SOF_TIMESTAMPING_OPT_STATS ) && skb_is_err_queue ( skb )\n"
  },
  {
    "id": 478,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end !=",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> if ( prev && <vul-end> ( FRAG6_CB ( <vul-start> ) - offset <vul-end> > 0 ) <vul-start> > 0 ) goto discard_fq ; if <vul-end> ( next && <vul-start> < end ) goto discard_fq ; <vul-end> FRAG6_CB ( skb <vul-start> - 1 ; discard_fq : fq_kill ( fq ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> prev ) -> len <vul-end> + prev -> <vul-start> prev -> len <vul-end> ) - offset <vul-start> ; if ( end < offset ) goto err ; if ( <vul-start> i > 0 && i < end - FRAG6_CB ( prev ) -> offset\n"
  },
  {
    "id": 479,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void Np_toString ( js_State * J ) { <vul-start> char buf [ 32 ] ; <vul-end> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , \"not a number\" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , \"invalid radix\" ) ; { static const char digits [ ] = \"0123456789abcdefghijklmnopqrstuvwxyz\" ; <vul-start> char buf [ 100 ] ; <vul-end> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , \"0\" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , \"NaN\" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? \"-Infinity\" : \"Infinity\" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number *",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 100 <vul-end> ] ; js_Object <vul-start> = \"0123456789abcdefghijklmnopqrstuvwxyz\" ; <vul-end> double number =\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 64 <vul-end> ] ; js_Object <vul-start> char buf [ 64 <vul-end> ] ; double\n"
  },
  {
    "id": 480,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> = 1 ; if ( bits_left == 0 ) <vul-start> ( 16 ) <vul-end> ; bits_left =\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> = 1 ; if ( bits_left > LZX_BLOCK_SIZE ) { D ( ( \"too many bytes remaining\" ) ) ; return lzx -> error = MSPACK_ERR_DECRUNCH ; }\n"
  },
  {
    "id": 481,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; <vul-start> char buf [ DN_BUF_LEN ] ; <vul-end> unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; <vul-start> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <vul-end> XN_FLAG_SEP_COMMA_PLUS ) ; <vul-start> md -> subject_dn = strdup ( buf ) ; <vul-end> if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } <vul-start> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <vul-end> XN_FLAG_SEP_COMMA_PLUS ) ; <vul-start> md -> issuer_dn = strdup ( buf ) ; <vul-end> if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <vul-end> * md ) <vul-start> goto cleanup ; ret = rfc2253_name <vul-end> ( X509_get_subject_name ( <vul-start> cert ) , & <vul-end> md -> subject_dn <vul-start> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <vul-end> ( X509_get_issuer_name ( <vul-start> cert ) , & <vul-end> md -> issuer_dn <vul-start> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <vul-end> ret = crypto_retrieve_X509_sans\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, j ; <vul-end> * md_out = <vul-start> goto cleanup ; krb5_get_subject_name ( cert, buf, sizeof ( buf ), 0 <vul-end>, XN_FLAG_SEP_COMMA_PLUS ) <vul-start> -> subject_dn = krb5_strdup ( buf, 0 <vul-end> ) ; if <vul-start> -> issuer_dn = krb5_strdup ( buf, 0 <vul-end> ) ; if\n"
  },
  {
    "id": 482,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; <vul-start> align_get_bits ( gb ) ; <vul-end> if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame skip %d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode: %3X \" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Start\" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Layer Start\" ) ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( gb ) ; if ( get_bits_count ( gb ) < 8 ) return AVERROR_INVALIDDATA\n"
  },
  {
    "id": 483,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: \n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( offset >= 1024 ||! buf ) { return NULL ; } if (\n"
  },
  {
    "id": 484,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> endif if ( <vul-end> cpi -> current_layer <vul-start> == 0 ) { if <vul-end> ( xd -> <vul-start> mode == ZEROMV && <vul-end> xd -> mode_info_context <vul-start> == LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <vul-start> - tp_start ; vp8_pack_tokens <vul-end> ( w ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> endif if ( mb_row >= 0 && <vul-start> else if ( <vul-end> xd -> mode_info_context <vul-start> == LAST_FRAME ) <vul-end> { if (\n"
  },
  {
    "id": 485,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) \"Parse_thread\" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> buflen , buf_size - 8\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, buf_size ) ; ps_dec -> ps_dpb_cmds -> u4_start_recon_deblk = 0\n"
  },
  {
    "id": 486,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int crossOriginDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; tok = sclone ( value ) ; while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( scaselessmatch ( option , \"origin\" ) ) { route -> corsOrigin = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , \"credentials\" ) ) { route -> corsCredentials = httpGetBoolToken ( ovalue ) ; } else if ( scaselessmatch ( option , \"headers\" ) ) { route -> corsHeaders = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , \"age\" ) ) { route -> corsAge = atoi ( ovalue ) ; } else { mprLog ( \"error appweb config\" , 0 , \"Unknown CrossOrigin option %s\" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } # if KEEP if ( smatch ( route -> corsOrigin , \"*\" ) && route -> corsCredentials ) { mprLog ( \"error appweb config\" , 0 , \"CrossOrigin: Cannot use wildcard Origin if allowing credentials\" ) ; return MPR_ERR_BAD_STATE ; } # endif httpAddRouteMethods ( route , \"OPTIONS\" ) ; route -> flags |= HTTP_ROUTE_CORS ; return 0 ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
  },
  {
    "id": 487,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 tmsize_t TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = \"TIFFReadEncodedStrip\" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"%lu: Strip out of range, max %lu\" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; <vul-start> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <vul-end> stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> ; stripsperplane = TIFFhowmany_32_maxuint_compat <vul-end> ( td -> <vul-start> td -> td_imagelength , <vul-end> rowsperstrip ) ;\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> -> td_imagelength ; if ( rowsperstrip == 0 ) rowsperstrip = 0 ;\n"
  },
  {
    "id": 488,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <vul-start> int hstartcol ; <vul-end> if ( bufsize > QMFB_SPLITBUFSIZE ) { <vul-start> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <vul-end> abort ( ) ; } } if ( numrows >= 2 ) { <vul-start> hstartcol = ( numrows + 1 - parity ) >> 1 ; <vul-end> <vul-start> m = numrows - hstartcol ; <vul-end> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> m ; int hstartrow <vul-end> ; if ( <vul-start> ( buf = jas_alloc3 <vul-end> ( bufsize , <vul-start> ( bufsize , JPC_QMFB_COLGRPSIZE , <vul-start> 2 ) { hstartrow <vul-end> = ( numrows <vul-start> = numrows - hstartrow <vul-end> ; n = <vul-start> & a [ hstartrow <vul-end> * stride ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int m ; jas_size_t <vul-end> hstartcol ; if <vul-start> ( buf = jas_alloc3 ( bufsize, numrows <vul-end>, sizeof ( <vul-start> 2 ) { <vul-end> m = numrows <vul-start> numrows - hstartcol ; if ( numrows < hstartcol ) { jas_eprintf ( \"too many rows\\\\n\" ) ; abort ( ) ; } hstartcol = ( numrows + 1 - parity ) >> 1\n"
  },
  {
    "id": 489,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , \"Memory squeeze on fr_add_pvc()\\\\n\" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <vul-start> if ( type == ARPHRD_ETHER ) <vul-end> dev = alloc_netdev ( 0 , \"pvceth%d\" , ether_setup ) ; <vul-start> else <vul-end> dev = alloc_netdev ( 0 , \"pvc%d\" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , \"Memory squeeze on fr_pvc()\\\\n\" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) ->",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> == ARPHRD_ETHER ) { <vul-start> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == ARPHRD_ETHER ) { if (! used ) { netdev_warn ( frad, \"Memory squeeze on fr_add_pvc()\\\\n\" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } <vul-start> ether_setup ) ; } else { <vul-end> dev = alloc_netdev\n"
  },
  {
    "id": 490,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <vul-start> in_uint16_le ( s , type ) ; <vul-end> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , \"cliprdr_process(), type=%d, status=%d, length=%d\" , type , status , length ) ; <vul-start> if ( status == CLIPRDR_ERROR ) <vul-end> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , \"cliprdr_process(), unhandled error (type=%d)\" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , \"cliprdr_process(), unhandled packet type %d\" , type ) ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * data ; struct stream packet = * s ; <vul-start> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cliprdr_process(), consume of packet from stream would overrun\" , & packet ) ; } if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * data ; if ( length < 4 ) { logger ( Debug, \"cliprdr_process(), length too short\" ) ; return ; } <vul-start> length ) ; in_uint16_le ( s, type ) ; in_uint16_le ( s, status ) ; in_uint32_le ( s, length ) ;\n"
  },
  {
    "id": 491,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; <vul-start> int x , y , i ; <vul-end> old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; <vul-start> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <vul-end> return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * zone ; size_t tilemap_size ; <vul-start> . height ; tilemap_size = <vul-end> x_size * y_size <vul-start> struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> y, i ; size_t tile_size_scaled <vul-start> ; if ( x_size!= 0 && y_size!= 0 && <vul-start> = malloc ( tile_size_scaled <vul-end> * sizeof (\n"
  },
  {
    "id": 492,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static unsigned int help ( struct sk_buff * skb , enum ip_conntrack_info ctinfo , unsigned int protoff , unsigned int matchoff , unsigned int matchlen , struct nf_conntrack_expect * exp ) { char buffer [ sizeof ( \"4294967296 65635\" ) ] ; <vul-start> u_int16_t port ; <vul-end> <vul-start> unsigned int ret ; <vul-end> exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ; exp -> dir = IP_CT_DIR_REPLY ; exp -> expectfn = nf_nat_follow_master ; for ( port = ntohs ( exp -> saved_proto . tcp . port ) ; port != 0 ; port ++ ) { int ret ; exp -> tuple . dst . u . tcp . port = htons ( port ) ; ret = nf_ct_expect_related ( exp ) ; if ( ret == 0 ) break ; else if ( ret != - EBUSY ) { port = 0 ; break ; } } if ( port == 0 ) { <vul-start> nf_ct_helper_log ( skb , exp -> master , \"all ports in use\" ) ; <vul-end> return NF_DROP ; } <vul-start> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , <vul-end> protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ; if ( ret != NF_ACCEPT ) { <vul-start> nf_ct_helper_log ( skb , exp -> master , \"cannot mangle packet\" ) ; <vul-end> nf_ct_unexpect_related ( exp ) ; } return ret ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) ] ; struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <vul-start> unsigned int ret ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <vul-start> ( skb , ct <vul-end> , \"all ports in use\" ) <vul-start> NF_DROP ; } snprintf ( buffer , sizeof ( buffer ) , \"%u %u\" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( \"nf_nat_irc: inserting \\'%s\\' == %pI4, port %u\\\\n\" , buffer , & newaddr . ip , port ) ; <vul-start> ( skb , ct <vul-end> , ctinfo , <vul-start> ( skb , ct <vul-end> , \"cannot mangle packet\" )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ] ; struct nf_conntrack_expect_data * data ; <vul-start> unsigned int ret ; data = nf_ct_expect_data_new ( exp ) <vul-start> ( skb, data <vul-end>, \"all ports in use\" ) <vul-start> ( skb, data <vul-end>, ctinfo, <vul-start> ( skb, data <vul-end>, \"cannot mangle packet\" )\n"
  },
  {
    "id": 493,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == ' ' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( \"Too many operands\\\\n\" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == ' ' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , \"lsl\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , \"lsr\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , \"asr\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <vul-start> if ( op -> operands [ operand",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> } if ( strlen ( token ) > 4 &&\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ARM_ASR ; } else <vul-end> { op -> <vul-start> ]. shift = ARM_NO_SHIFT ; } if ( op -> operands [ operand ]. shift\n"
  },
  {
    "id": 494,
    "question": "CWE-494 Code Input Vulnerable Code Is: CWE-494 LONG ValidateSignature ( HWND hDlg , const char * path ) { LONG r ; WINTRUST_DATA trust_data = { 0 } ; WINTRUST_FILE_INFO trust_file = { 0 } ; GUID guid_generic_verify = { 0xaac56b , 0xcd44 , 0x11d0 , { 0x8c , 0xc2 , 0x0 , 0xc0 , 0x4f , 0xc2 , 0x95 , 0xee } } ; char * signature_name ; size_t i , len ; signature_name = GetSignatureName ( path ) ; if ( signature_name == NULL ) { uprintf ( \"PKI: Could not get signature name\" ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; return TRUST_E_NOSIGNATURE ; } for ( i = 0 ; i < ARRAYSIZE ( cert_name ) ; i ++ ) { len = strlen ( cert_name [ i ] ) ; if ( strncmp ( signature_name , cert_name [ i ] , len ) == 0 ) { if ( ( len >= strlen ( signature_name ) ) || isspace ( signature_name [ len ] ) ) break ; } } if ( i >= ARRAYSIZE ( cert_name ) ) { uprintf ( \"PKI: Signature \\'%s\\' is unexpected...\" , signature_name ) ; if ( MessageBoxExU ( hDlg , lmprintf ( MSG_285 , signature_name ) , lmprintf ( MSG_283 ) , MB_YESNO | MB_ICONWARNING | MB_IS_RTL , selected_langid ) != IDYES ) return TRUST_E_EXPLICIT_DISTRUST ; } trust_file . cbStruct = sizeof ( trust_file ) ; trust_file . pcwszFilePath = utf8_to_wchar ( path ) ; if ( trust_file . pcwszFilePath == NULL )",
    "golden_answers": [
      "CWE-494 Fixed Code Lines are: <vul-start> . dwUIChoice = WTD_UI_NONE <vul-end> ; trust_data . <vul-start> pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( \"PKI: File does not appear to be signed: %s\" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( \"PKI: Failed to validate signature: %s\" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }\n"
    ],
    "generated_answer": "CWE-494 Fixed Code Lines are: <vul-start> ; trust_data. <vul-end> pFile = & <vul-start> pcwszFilePath ) ; if ( r!= ERROR_OK ) { uprintf ( \"PKI: Unable to verify \\'%s\\' to UTF16\", path ) ; r = ERROR_SEVERITY_ERROR | FAC ( FACILITY_CERT ) | ERROR_NOT_ENOUGH_MEMORY ; }\n"
  },
  {
    "id": 495,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , \"Error, can\\'t read tile at %lu %lu\" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf ,",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> uint32 col ; if ( imagewidth < tilew ) { TIFFError ( TIFFFileName ( in ), \"Error, can\\'t read tile at %lu %lu\", ( unsigned long ) col, ( unsigned long ) row ) ; status = 0 ; goto done ; }\n"
  },
  {
    "id": 496,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = ' ' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> { if ( l == NULL ) break ; if (\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( rows > 0 <vul-end> ) { pos\n"
  },
  {
    "id": 497,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; configASSERT ( pxEnd ) ; vTaskSuspendAll ( ) ; { if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { <vul-start> if ( xWantedSize > 0 ) <vul-end> { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { <vul-start> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <vul-end> } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <vul-start> 0x00 ) { if ( ( xWantedSize + <vul-end> ( portBYTE_ALIGNMENT - <vul-start> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( xWantedSize >= xWantedSize + xHeapStructSize <vul-end> ) { xWantedSize <vul-start> { xWantedSize += portBYTE_ALIGNMENT - ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart. pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock!= NULL ) ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xWantedSize = 0 ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize\n"
  },
  {
    "id": 498,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( \"SH: first_mb_in_slice\" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( \"SH: slice_type\" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } {",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> pv_parse_tu_coeff_data ; } <vul-end> if ( u1_slice_type\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> } ps_dec -> ps_dpb_cmds -> i4_tpb_commands_read = 0 ; ps_dec ->\n"
  },
  {
    "id": 499,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ; <vul-start> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <vul-end> if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , \"type %.4s size %d\\\\n\" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; sc -> drefs_count = 0 ; sc ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> drefs = av_callocz ( entries, <vul-end> sizeof ( *\n"
  },
  {
    "id": 500,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <vul-start> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <vul-end> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <vul-start> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <vul-start> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> filter_level ) { memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 16 ) ; memset <vul-end> ( pbi -> <vul-start> 8 ) ; memset <vul-end> ( pbi ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> filter_level ) { memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi ->\n"
  },
  {
    "id": 501,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <vul-end> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( \"Unexpected width_shift %d in misaligned_store, PC=%08lx\\\\n\" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
  },
  {
    "id": 502,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <vul-start> } <vul-end> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , \"__wakeup\" , sizeof ( \"__wakeup\" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , \"__wakeup\" , sizeof ( \"__wakeup\" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_OBJPROP_PP ( rval )!= NULL ) { INIT_ZVAL ( & fname ) ; ZVAL_STRINGL ( & fname, \"__wakeup\", sizeof ( \"__wakeup\" ) - 1, 0 ) ; call_user_function_ex ( CG ( function_table ), rval, & fname, 0, 0, 1, NULL TSRMLS_CC ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ), rval, & fname, 0, 0, 0, 1, NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } <vul-end> return 0 ;\n"
  },
  {
    "id": 503,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; break ; default : assert ( FALSE ) ; <vul-start> } # line 2371 <vul-end> \"grammar.c\" break ; <vul-start> : # line 834 <vul-end> \"grammar.y\" { if <vul-start> ; break ; default : assert ( FALSE ) ; <vul-start> } # line 2409 <vul-end> \"grammar.c\" break ; <vul-start> : # line 872 <vul-end> \"grammar.y\" { SIZED_STRING <vul-start> } # line 2455 <vul-end> \"grammar.c\" break ; <vul-start> : # line 918 <vul-end> \"grammar.y\" { if <vul-start> } # line 2478 <vul-end> \"grammar.c\" break ; <vul-start> : # line 940 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2491 <vul-end> \"grammar.c\" break ; <vul-start> : # line 949 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2504 <vul-end> \"grammar.c\" break ; <vul-start> : # line 958 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2523 <vul-end> \"grammar.c\" break ; <vul-start> : # line 973 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2539 <vul-end> \"grammar.c\" break ; <vul-start> : # line 985 <vul-end> \"grammar.y\" { int <vul-start> } # line 2557 <vul-end> \"grammar.c\" break ; <vul-start> : # line 999 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2574 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1012 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2589 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1023 <vul-end> \"grammar.y\" { if <vul-start> NULL ; } YYERROR ; } # line 2603 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1033 <vul-end> \"grammar.y\" { int <vul-start> } # line 2637 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1063 <vul-end> \"grammar.y\" { int <vul-start> } # line 2676 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1098 <vul-end> \"grammar.y\" { int <vul-start> } # line 2759 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1177 <vul-end> \"grammar.y\" { int <vul-start> } # line 2793 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1207 <vul-end> \"grammar.y\" { int <vul-start> } # line 2846 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1256 <vul-end> \"grammar.y\" { yr_parser_emit <vul-start> } # line 2856 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1262 <vul-end> \"grammar.y\" { yr_parser_emit <vul-start> } # line 2866 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1268 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2896 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1294 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2936 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1330 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2965 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1355 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 3005 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1391 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3018 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1400 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3031 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1409 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3044 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1418 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3057 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1427 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3070 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1436 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3083 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1445 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3091 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1449 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3099 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1456 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3105 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1457 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3111 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1463 <vul-end> \"grammar.y\" { if <vul-start> } # line 3133 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1485 <vul-end> \"grammar.y\" { if <vul-start> } # line 3149 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1497 <vul-end> \"grammar.y\" { if <vul-start> } # line 3164 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1512 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3173 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1518 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3184 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1535 <vul-end> \"grammar.y\" { yr_parser_emit_pushes_for_strings <vul-start> } # line 3195 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1542 <vul-end> \"grammar.y\" { yr_parser_emit_pushes_for_strings <vul-start> } # line 3206 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1554 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3214 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1558 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3222 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1566 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3230 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1570 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3244 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1580 <vul-end> \"grammar.y\" { yywarning <vul-start> } # line 3262 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1594 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3282 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1610 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3296 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1620 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3309 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1629 <vul-end> \"grammar.y\" { SIZED_STRING <vul-start> } # line 3338 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1654 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3354 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1666 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3370 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1678 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3390 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1694 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3406 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1706 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3426 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1722 <vul-end> \"grammar.y\" { if <vul-start> } # line 3475 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1767 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3498 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1786 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3520 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1804 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3542 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1822 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3564 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1840 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3594 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1866 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3616 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1884 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3630 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1894 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3644 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1904 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3658 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1914 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3672 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1924 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3686 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1934 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3700 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1944 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3708 <vul-end> \"grammar.c\" break ; <vul-start> ; # line 3712 <vul-end> \"grammar.c\" default :\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; # line 2597 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8266 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8275 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276 <vul-end> \"grammar.c\" break ; <vul-start> : # line 8276"
  },
  {
    "id": 504,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text +",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; }\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> ; } } if ( EOFBlob ( image )!= ( char * ) NULL ) break ;\n"
  },
  {
    "id": 505,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <vul-start> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <vul-end> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <vul-start> write_lock ( & cluster -> cl_nodes_lock ) ; <vul-end> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <vul-start> if ( ret ) <vul-end> return ret ; return count ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> o2nm_cluster * cluster <vul-end> ; unsigned long <vul-start> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <vul-start> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> o2nm_cluster * cluster <vul-end> ; unsigned long <vul-start> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if (! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <vul-start> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;\n"
  },
  {
    "id": 506,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , * header ; size_t cb1_len , cb2_len , alloc_len ; unsigned char * cb1 , * cb2 ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = json_array_string ( val , 5 ) ; nbit = json_array_string ( val , 6 ) ; ntime = json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( prev_hash ) free ( prev_hash ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; if ( bbversion ) free ( bbversion ) ; if ( nbit ) free ( nbit ) ; if ( ntime ) free ( ntime ) ; goto out ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) ) ) { applog ( LOG_WARNING , \"%s: Failed to convert header to header_bin, got %s\" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <vul-end> cb1 = (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) ) { free ( pool -> coinbase ) ; <vul-start> \"Failed to convert header to header_bin in parse_notify\" ) ; }\n"
  },
  {
    "id": 507,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , \"Error %d during NTLMSSP authentication\\\\n\" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-end> <vul-start> if ( ses -> server -> sign ) { <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-start> } <vul-end> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_blob -> LmChallengeResponse . Length = 0 ; sec_blob -> LmChallengeResponse . MaximumLength = 0 ; sec_blob -> NtChallengeResponse . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; if ( ses -> user_name != NULL ) { memcpy ( tmp , ses -> auth_key . response + CIFS_SESS_KEY_SIZE , ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; tmp +=",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <vul-start> -> sign ) <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> tmp = *\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM <vul-end> | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-start> server -> sign && ( <vul-end>! ses -> <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> tmp = *\n"
  },
  {
    "id": 508,
    "question": "CWE-354 Code Input Vulnerable Code Is: CWE-354 void next_character ( void ) <vul-start> { <vul-end> strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ; random_permute_char ( cipher , strlen ( cipher ) ) ; static char CONFIDENTIAL current_word [ CURRENT_WORD_BUF ] ; get_current_word ( current_word ) ; if ( strlen ( current_word ) > 4 ) { memzero ( current_word , sizeof ( current_word ) ) ; recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , \"Words were not entered correctly. Make sure you are using the substition cipher.\" ) ; layoutHome ( ) ; return ; } CharacterRequest resp ; memset ( & resp , 0 , sizeof ( CharacterRequest ) ) ; resp . word_pos = get_current_word_pos ( ) ; resp . character_pos = strlen ( current_word ) ; msg_write ( MessageType_MessageType_CharacterRequest , & resp ) ; bool auto_completed = false ; if ( strlen ( current_word ) >= 3 ) { auto_completed = attempt_auto_complete ( current_word ) ; } # if DEBUG_LINK if ( auto_completed ) { strlcpy ( auto_completed_word , current_word , CURRENT_WORD_BUF ) ; } else { auto_completed_word [ 0 ] = '\\\\0' ; } # endif format_current_word ( current_word , auto_completed ) ; layout_cipher ( current_word , cipher ) ; memzero ( current_word , sizeof ( current_word ) ) ; }",
    "golden_answers": [
      "CWE-354 Fixed Code Lines are: <vul-start> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , \"Not in Recovery mode\" ) ; layoutHome ( ) ; return ; }\n"
    ],
    "generated_answer": "CWE-354 Fixed Code Lines are: <vul-start> void ) { if ( strlen ( cipher ) == 0 ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError, \"Words were not entered correctly. Make sure you are using the substition cipher.\" ) ; layoutHome ( ) ; return ; }\n"
  },
  {
    "id": 509,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ; <vul-start> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <vul-end> uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , \"File too short\" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> = 0.0 ; # define MUS_SZ 4 <vul-start> uint8_t mus_event [ MUS_SZ <vul-start> * ) mus_event , MUS_SZ\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0.0 ; float samples_per_tick_f_zero = 0.0 ; <vul-start> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"
  },
  {
    "id": 510,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <vul-start> void * dllhandle ; <vul-end> if ( useSystemLib ) Com_Printf ( \"Trying to load \\\\\"%s\\\\\"...\\\\n\" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = \".\" ; Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( \"fs_basepath\" ) ; if ( ! basePath || ! * basePath ) basePath = \".\" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( \"Loading \\\\\"%s\\\\\" failed\\\\n\" , name ) ; } } return dllhandle ; }",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> * dllhandle ; if ( COM_CompareExtension ( name , \".pk3\" ) ) { Com_Printf ( \"Rejecting DLL named \\\\\"%s\\\\\"\" , name ) ; return NULL ; }\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> useSystemLib ) { return Sys_LoadLibrary_ex ( name, useSystemLib, NULL ) <vul-end> ; }  \n"
  },
  {
    "id": 511,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <vul-start> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <vul-end> pr_err ( \"set_ctl: len %u != %u\\\\n\" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( len!= ( int )\n"
  },
  {
    "id": 512,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <vul-start> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <vul-end> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , \"stack too short\" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ]",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> = 0 ; check_stack_depth ( ) ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ( type = gettoken_query_internal <vul-end> ( state,\n"
  },
  {
    "id": 513,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void process_bitmap_updates ( STREAM s ) { <vul-start> uint16 num_updates ; <vul-end> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <vul-start> logger ( Protocol , Debug , \"%s()\" , __func__ ) ; <vul-end> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <vul-start> in_uint16_le ( s , left ) ; <vul-end> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> s ) { <vul-end> int i ; <vul-start> int i ; uint16 num_updates <vul-end> ; in_uint16_le ( <vul-start> ++ ) { process_bitmap_data ( s <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> s ) { int num_updates ; int16_t left, top, right, bottom, width, height ; int16_t <vul-end> compress, bufsize <vul-start>, \"%s()\", <vul-end> __func__ ) ; <vul-start> ++ ) { if ( i >= num_updates ) { rdp_protocol_error ( s, \"process_bitmap_updates(), stream is too many updates\" ) ; }\n"
  },
  {
    "id": 514,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func ) { int i , nargs , nkeywords , ngens ; asdl_seq * args ; asdl_seq * keywords ; expr_ty vararg = NULL , kwarg = NULL ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ; ngens = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) ngens ++ ; else nkeywords ++ ; } } if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { ast_error ( n , \"Generator expression must be parenthesized \" \"if not sole argument\" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( n , \"more than 255 arguments\" ) ; return NULL ; } args = asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> int k ; const\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> char * tmp ; if ( NCH ( ch ) > MAX_PROC_NAME_LEN ) { ast_error ( CHILD ( ch, 0 ), \"too many procesor entries\" ) ; return NULL ; } <vul-end> e = ast_for_expr\n"
  },
  {
    "id": 515,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , \"Modification of ArrayObject during sorting is prohibited\" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r'",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <vul-end> goto outexcept ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, & p + buf_len, & var_hash TSRMLS_CC ) || Z_TYPE_P ( intern -> array )!= IS_ARRAY ) { zval_ptr_dtor ( & intern -> array ) ; goto outexcept ; } var_push_dtor ( & var_hash, & intern -> array ) ; } if ( * p!= ';' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' || * ++ p!= ':' ) { goto outexcept ; } ++ p ; if ( * p!='m' ||"
  },
  {
    "id": 516,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <vul-start> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <vul-end> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <vul-start> case PCIBAR_MEM64 : <vul-end> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <vul-start> printf ( \"%s: invalid bar type %d\\\\n\" , __func__ ,",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> , bar ; <vul-end> if ( ( <vul-start> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( \"%s: invalid bar number %d for MEM64 type\\\\n\" , __func__ , idx ) ; return - 1 ; } <vul-start> ; default : pr_err <vul-end> ( \"%s: invalid bar type %d\\\\n\" , <vul-start> type ) ; return - 1 <vul-end> ; } if <vul-start> PCIBAR_MEM64 ) { <vul-end> pdi -> bar\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start>, bar ; if ( idx >= 0 || idx >= PCI_BARMAX ) return 0 ; <vul-start> type ) ; return 0 <vul-end> ; } if <vul-start> PCIBAR_MEM64 ) { if <vul-end> ( idx + <vul-start> <= PCI_BARMAX ) return 0\n"
  },
  {
    "id": 517,
    "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 static void * gp_worker_main ( void * pvt ) { struct gp_thread * t = ( struct gp_thread * ) pvt ; struct gp_query * q = NULL ; char dummy = 0 ; int ret ; while ( ! t -> pool -> shutdown ) { gp_debug_set_conn_id ( 0 ) ; pthread_mutex_lock ( & t -> cond_mutex ) ; while ( t -> query == NULL ) { pthread_cond_wait ( & t -> cond_wakeup , & t -> cond_mutex ) ; <vul-start> if ( t -> pool -> shutdown ) { <vul-end> pthread_exit ( NULL ) ; } } q = t -> query ; t -> query = NULL ; pthread_mutex_unlock ( & t -> cond_mutex ) ; gp_debug_set_conn_id ( gp_conn_get_cid ( q -> conn ) ) ; GPDEBUGN ( 3 , \"[status] Handling query input: %p (%zu)\\\\n\" , q -> buffer , q -> buflen ) ; gp_handle_query ( t -> pool , q ) ; GPDEBUGN ( 3 , \"[status] Handling query output: %p (%zu)\\\\n\" , q -> buffer , q -> buflen ) ; pthread_mutex_lock ( & t -> pool -> lock ) ; q -> next = t -> pool -> reply_list ; t -> pool -> reply_list = q ; if ( ! t -> pool -> shutdown ) { LIST_DEL ( t -> pool -> busy_list , t ) ; LIST_ADD ( t -> pool -> free_list , t ) ; } pthread_mutex_unlock ( & t -> pool -> lock ) ; ret = write ( t -> pool -> sig_pipe [ 1 ] , & dummy",
    "golden_answers": [
      "CWE-667 Fixed Code Lines are: <vul-start> shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;\n"
    ],
    "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> cond_mutex ) ; <vul-end> } q =\n"
  },
  {
    "id": 518,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( \"ext4_ext_handle_uninitialized_extents: inode %lu, logical \" \"block %llu, max_blocks %u, flags %x, allocated %u\\\\n\" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <vul-start> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <vul-end> path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) {",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> , inode , map ,\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> { ret = ext4_convert_unwritten_extents_endio ( handle, inode, path, map -> m_len <vul-end> ) ; if\n"
  },
  {
    "id": 519,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; <vul-start> retval = generic_gss_oid_decompose ( minor_status , <vul-end> GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; retval = gss_gss_oid_decompose <vul-end> ( minor_status,\n"
  },
  {
    "id": 520,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ( error ) { kmem_free ( sbuf ) ; <vul-start> return error ; }\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ( error ) { kmem_free ( sbuf ) ; <vul-start> return error ; }\n"
  },
  {
    "id": 521,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ; <vul-start> cur_token = * indx ; <vul-end> mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) { <vul-start> res = r ; <vul-end> goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> int res ; clist * list ; <vul-start> res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> int res ; char * first_invalid_part ; <vul-start> ) ) { first_invalid_part = cur_token ; <vul-start> ) ) { first_invalid_part = NULL ;\n"
  },
  {
    "id": 522,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void ff_h264_free_tables ( H264Context * h , int free_rbsp ) { int i ; H264Context * hx ; av_freep ( & h -> intra4x4_pred_mode ) ; av_freep ( & h -> chroma_pred_mode_table ) ; av_freep ( & h -> cbp_table ) ; av_freep ( & h -> mvd_table [ 0 ] ) ; av_freep ( & h -> mvd_table [ 1 ] ) ; av_freep ( & h -> direct_table ) ; av_freep ( & h -> non_zero_count ) ; av_freep ( & h -> slice_table_base ) ; h -> slice_table = NULL ; av_freep ( & h -> list_counts ) ; av_freep ( & h -> mb2b_xy ) ; av_freep ( & h -> mb2br_xy ) ; av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; av_buffer_pool_uninit ( & h -> mb_type_pool ) ; av_buffer_pool_uninit ( & h -> motion_val_pool ) ; av_buffer_pool_uninit ( & h -> ref_index_pool ) ; if ( free_rbsp && h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; <vul-start> av_freep ( & h -> DPB ) ; <vul-end> } else if ( h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) h -> DPB [ i ] . needs_realloc = 1 ; } h -> cur_pic_ptr = NULL ; for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { hx = h -> thread_context [ i ] ; if ( ! hx ) continue ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ] ) ; <vul-end> } else if\n"
  },
  {
    "id": 523,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , \"OLSRv%i, seq 0x%04x, length %u\" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <vul-start> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <vul-end> if ( is_ipv6 ) { msgptr . v6 =",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; if ( is_ipv6 ) { <vul-start> sizeof ( struct olsr_msg6 ) ) ; <vul-end> msgptr . v6 <vul-start> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <vul-start> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <vul-start> 2 ) ; <vul-end> addr_size = 4 <vul-start> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <vul-end> name_entries_valid = 0 <vul-start> name_entries_valid = 0 <vul-end> ; if ( <vul-start> name_entries_valid = 1 <vul-end> ; ND_PRINT (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ND_TCHECK_16BITS ( * tptr <vul-end> ) ; if <vul-start> } else { ND_TCHECK_16BITS ( * tptr, sizeof ( struct olsr_msg4 ) ) ;\n"
  },
  {
    "id": 524,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <vul-end> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( \"Unexpected width_shift %d in misaligned_load, PC=%08lx\\\\n\" , width_shift , ( unsigned long )",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
  },
  {
    "id": 525,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <vul-start> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-end> <vul-start> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <vul-end> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> ( fl6 , rcu_dereference ( <vul-start> np -> opt ) <vul-start> final ) ; rcu_read_unlock ( ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( fl6, rcu_dereference ( <vul-start> np -> opt ) <vul-start> ( sk, rcu_dereference ( <vul-start> np -> dst_cookie )\n"
  },
  {
    "id": 526,
    "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; <vul-start> err = scm_send ( sock , msg , siocb -> scm ) ; <vul-end> if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL )",
    "golden_answers": [
      "CWE-287 Fixed Code Lines are: <vul-start> siocb -> scm , true\n"
    ],
    "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> siocb -> scm, false\n"
  },
  {
    "id": 527,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int tiffcp ( TIFF * in , TIFF * out ) { <vul-start> uint16 bitspersample , samplesperpixel ; <vul-end> <vul-start> uint16 input_compression , input_photometric ; <vul-end> copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , \"tiffcp: %s: Can\\'t copy/convert subsampled image.\\\\n\" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 )",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> bitspersample , samplesperpixel = 1 <vul-start> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> out ) { uint32 bitspersample, samplesperpixel ; uint16 input_compression, input_photometric ; copyFunc cf ; uint32 width, length ; struct cpTag * p ; uint32 width, length ; uint16 subsamplinghor, subsamplingver ; TIFFGetFieldDefaulted ( in, TIFFTAG_BITSPERSAMPLE, & bitspersample ) ; CopyField ( TIFFTAG_BITSPERPIXEL, & samplesperpixel ) ; if ( compression!= ( uint16 ) - 1 ) TIFFSetField ( out, TIFFTAG_COMPRESSION, compression ) ; else CopyField ( TIFFTAG_COMPRESSION, compression ) ; <vul-end> if ( input_compression <vul-start> ; uint16 input_compression <vul-end>, input_photometric )\n"
  },
  {
    "id": 528,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ssl3_get_cert_verify ( SSL * s ) { EVP_PKEY * pkey = NULL ; unsigned char * p ; int al , ok , ret = 0 ; long n ; int type = 0 , i , j ; X509 * peer ; const EVP_MD * md = NULL ; EVP_MD_CTX mctx ; EVP_MD_CTX_init ( & mctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_VRFY_A , SSL3_ST_SR_CERT_VRFY_B , - 1 , SSL3_RT_MAX_PLAIN_LENGTH , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( s -> session -> peer != NULL ) { peer = s -> session -> peer ; pkey = X509_get_pubkey ( peer ) ; type = X509_certificate_type ( peer , pkey ) ; } else { peer = NULL ; pkey = NULL ; } if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ; <vul-start> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <vul-end> { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ; goto f_err ; } ret = 1 ; goto end ; } if ( peer == NULL ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_NO_CLIENT_CERT_RECEIVED ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } if ( ! ( type & EVP_PKT_SIGN ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE ) ; al = SSL_AD_ILLEGAL_PARAMETER ; goto f_err ; } if ( s -> s3 -> change_cipher_spec ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> ; if ( <vul-end> peer != NULL <vul-start> peer != NULL <vul-end> ) { al\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> if ( ( <vul-end> type & EVP_PKT_SIGN\n"
  },
  {
    "id": 529,
    "question": "CWE-79 Code Input Vulnerable Code Is: CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , \"INCLUDED\" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , \"text/html\" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( !",
    "golden_answers": [
      "CWE-79 Fixed Code Lines are: <vul-start> = 1 ; apr_brigade_cleanup ( brigade ) ;\n"
    ],
    "generated_answer": "CWE-79 Fixed Code Lines are: <vul-start> = 1 ; <vul-end> rv = php_apache_request_ctor\n"
  },
  {
    "id": 530,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <vul-start> case RAPTOR_OPTION_RELATIVE_URIS : <vul-end> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> RAPTOR_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case\n"
  },
  {
    "id": 531,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( \"nfnetlink-subsys-%d\" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <vul-start> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <vul-end> skb ->",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <vul-start> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if ( skb -> len < nlmsg_total_size ( 0 ) ||\n"
  },
  {
    "id": 532,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t ssiProcessExecCommand ( HttpConnection * connection , const char_t * tag , size_t length ) { char_t * separator ; char_t * attribute ; char_t * value ; if ( connection -> settings -> cgiCallback == NULL ) return ERROR_INVALID_TAG ; if ( length < 4 || length >= HTTP_SERVER_BUFFER_SIZE ) return ERROR_INVALID_TAG ; osMemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\\\0' ; <vul-start> separator = strchr ( connection -> buffer , '=' ) ; <vul-end> if ( ! separator ) return ERROR_INVALID_TAG ; * separator = '\\\\0' ; attribute = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\\\'' || value [ 0 ] == \\'\\\\\"\\' ) value ++ ; length = osStrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\\\'' || value [ length - 1 ] == \\'\\\\\"\\' ) value [ length - 1 ] = '\\\\0' ; } if ( osStrcasecmp ( attribute , \"cgi\" ) && osStrcasecmp ( attribute , \"cmd\" ) && osStrcasecmp ( attribute , \"cmd_argument\" ) ) return ERROR_INVALID_TAG ; if ( osStrlen ( value ) > HTTP_SERVER_CGI_PARAM_MAX_LEN ) return ERROR_INVALID_TAG ; osStrcpy ( connection -> cgiParam , value ) ; return connection -> settings -> cgiCallback ( connection , connection -> cgiParam ) ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; separator = osStrchr <vul-end> ( connection ->\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; separator = osStrchr <vul-end> ( connection ->\n"
  },
  {
    "id": 533,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"nreslevels %d is invalid\\\\n\" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <vul-start> if ( c -> nreslevels < s -> reduction_factor ) <vul-end> <vul-start> c -> nreslevels2decode = 1 ; <vul-end> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"cblk size invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , \"cblk size > 64\" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"extra cblk styles %X\\\\n\" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( &",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> c -> nreslevels <= <vul-end> s -> reduction_factor <vul-start> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , \"reduction_factor too large for this bitstream, max is %d\\\\n\" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <vul-end> c -> nreslevels2decode\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> reduction_factor ) { <vul-start> = 1 ; }\n"
  },
  {
    "id": 534,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_segmentation ( VP9_COMP * cpi , <vul-end> struct vp9_write_bit_buffer * wb ) { int i , j ; <vul-start> struct segmentation * seg = & cpi -> common . seg ; <vul-end> vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ; <vul-start> vp9_wb_write_bit ( wb , seg -> update_map ) ; <vul-end> if ( seg -> update_map ) { <vul-start> vp9_choose_segmap_coding_method ( cpi ) ; <vul-end> for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ; <vul-start> vp9_wb_write_bit ( wb , update ) ; <vul-end> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } <vul-start> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <vul-end> if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ; <vul-start> vp9_wb_write_bit ( wb , update ) ; <vul-end> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } } <vul-start> vp9_wb_write_bit ( wb , seg -> update_data ) ; <vul-end> if ( seg -> update_data ) { <vul-start> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <vul-end> for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> , j ; const <vul-start> seg = & cm -> seg ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> ) return ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> { vp9_choose_segmap_coding_method ( cm , xd <vul-end> ) ; for <vul-start> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <vul-end> ( wb , <vul-start> ) ; } vpx_wb_write_bit <vul-end> ( wb , <vul-start> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <vul-end> ( wb , <vul-start> } } } vpx_wb_write_bit <vul-end> ( wb , <vul-start> update_data ) { vpx_wb_write_bit <vul-end> ( wb , <vul-start> int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> int data = get_segdata <vul-end> ( seg , <vul-start> data_max ) ; vpx_wb_write_bit <vul-end> ( wb ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void encode_segmentation ( const VP9_COMMON * cm, struct vpx_write_bit_buffer * wb, vpx_bit_depth_t bit_depth <vul-end> ) { int <vul-start> common. seg ; vpx_wb_write_bit ( wb, seg -> enabled ) ; if (! seg -> enabled ) return ; vpx_wb_write_bit ( wb, seg -> update_map ) ; if ( seg -> update_map ) { vpx_choose_segmap_coding_method ( cpi ) ; for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob!= MAX_PROB ; vpx_wb_write_bit ( wb, update ) ; if ( update ) vpx_wb_write_literal ( wb, prob, 8 ) ; } vpx_wb_write_bit <vul-end> ( wb, <vul-start>!= MAX_PROB ; vpx_wb_write_bit <vul-end> ( wb, <vul-start>!= MAX_PROB ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> update_data ) { vpx_wb_write_bit <vul-end> ( wb, <vul-start> ) ; } vpx_wb_write_bit <vul-end> ( wb, <vul-start> update_data ) { vpx_wb_write_bit <vul-end> ( wb,\n"
  },
  {
    "id": 535,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int errorLogDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks stamp ; char * option , * ovalue , * tok , * path ; ssize size ; int level , flags , backup ; if ( mprGetCmdlineLogging ( ) ) { mprLog ( \"info appweb config\" , 4 , \"Already logging. Ignoring ErrorLog directive\" ) ; return 0 ; } size = MAXINT ; stamp = 0 ; level = 0 ; backup = 0 ; path = 0 ; flags = 0 ; for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , \"LOG_DIR\" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"size\" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , \"level\" ) ) { level = atoi ( ovalue ) ; } else if ( smatch ( option , \"backup\" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , \"anew\" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , \"stamp\" ) ) {",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
  },
  {
    "id": 536,
    "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , \"\\\\r\\\\n*** pulse DTR ***\\\\r\\\\n\" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , \"*** FAILED\\\\r\\\\n\" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , \"\\\\r\\\\n*** DTR: %s ***\\\\r\\\\n\" , dtr_up ? \"up\" : \"down\" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , \"\\\\r\\\\n*** baud: %d (%d) ***\\\\r\\\\n\" , opts . baud , newbaud ) ; } else {",
    "golden_answers": [
      "CWE-77 Fixed Code Lines are: <vul-start> xfr_cmd , fname <vul-end> ) ; free\n"
    ],
    "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> xfr_cmd, fname <vul-end> ) ; free\n"
  },
  {
    "id": 537,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void rd_check_segment ( VP8_COMP * cpi , MACROBLOCK * x , BEST_SEG_INFO * bsi , unsigned int segmentation ) { int i ; int const * labels ; int br = 0 ; int bd = 0 ; B_PREDICTION_MODE this_mode ; int label_count ; int this_segment_rd = 0 ; int label_mv_thresh ; int rate = 0 ; int sbr = 0 ; int sbd = 0 ; int segmentyrate = 0 ; vp8_variance_fn_ptr_t * v_fn_ptr ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; ENTROPY_CONTEXT_PLANES t_above_b , t_left_b ; ENTROPY_CONTEXT * ta_b ; ENTROPY_CONTEXT * tl_b ; <vul-start> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> <vul-start> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; ta_b = ( ENTROPY_CONTEXT * ) & t_above_b ; tl_b = ( ENTROPY_CONTEXT * ) & t_left_b ; br = 0 ; bd = 0 ; v_fn_ptr = & cpi -> fn_ptr [ segmentation ] ; labels = vp8_mbsplits [ segmentation ] ; label_count = vp8_mbsplit_count [ segmentation ] ; label_mv_thresh = 1 * bsi -> mvthresh / label_count ; rate = vp8_cost_token ( vp8_mbsplit_tree , vp8_mbsplit_probs , vp8_mbsplit_encodings + segmentation ) ; rate += vp8_cost_mv_ref ( SPLITMV , bsi -> mdcounts ) ; this_segment_rd += RDCOST ( x -> rdmult , x -> rddiv , rate , 0 ) ; br += rate ; for",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * tl_b ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left <vul-start> * tl_s ; memcpy <vul-end> ( & t_above_s <vul-start> ) ) ; memcpy <vul-end> ( & t_left_s <vul-start> = this_rd ; memcpy <vul-end> ( ta_b , <vul-start> ) ) ; memcpy <vul-end> ( tl_b , <vul-start> ; } } memcpy <vul-end> ( ta , <vul-start> ) ) ; memcpy <vul-end> ( tl ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * tl_b ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left\n"
  },
  {
    "id": 538,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ; <vul-start> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <vul-end> && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <vul-start> switch ( ctxt -> mode ) { <vul-end> case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; <vul-start> break ; <vul-end> case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ; <vul-start> cs_sel = ( u16 ) msr_data ; <vul-end> cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <vul-start> ss_sel &= ~ SELECTOR_RPL_MASK ; <vul-end> <vul-start> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <vul-end> cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel ,",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> ctxt -> mode != X86EMUL_MODE_PROT64 <vul-end> ) && ( <vul-start> msr_data ) ; <vul-end> if ( ( <vul-start> 0 ) ; <vul-end> ctxt -> eflags <vul-start> u16 ) msr_data & <vul-end> ~ SELECTOR_RPL_MASK ; <vul-start> + 8 ; if <vul-end> ( efer & <vul-start> efer & EFER_LMA <vul-end> ) { cs <vul-start> -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <vul-start> VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> == X86EMUL_MODE_PROT32 ) || <vul-end> ( efer & <vul-start> efer & EFER_LMA ) || ( efer & EFER_SCE ) <vul-start> msr_data ) ; <vul-end> ctxt -> eflags <vul-start> EFLG_IF ) ; if (! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; <vul-start> + 8 ; if (! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; <vul-start> ; if ( <vul-end> ( efer & <vul-start> efer & EFER_LMA ) || ( efer & EFER_SCE )\n"
  },
  {
    "id": 539,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) {",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> , nameptr , lfi , fname , UDF_NAME_LEN <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> continue ; } if ( lfi >= UDF_NAME_LEN ) { ret = - ENAMETOOLONG ; goto out ; }\n"
  },
  {
    "id": 540,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , \"r\" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , \"cannot open CSR file!\\\\n\" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , \"could not read file length!\\\\n\" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_column_idx\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_column_idx\n"
  },
  {
    "id": 541,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int main ( int argc , char * * argv ) { const char command0 [ ] = { 0x00 , 0x00 } ; char command1 [ ] = \"\\\\x01\\\\x00urn:schemas-upnp-org:device:InternetGatewayDevice\" ; char command2 [ ] = \"\\\\x02\\\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice\" ; const char command3 [ ] = { 0x03 , 0x00 } ; char command3compat [ ] = \"\\\\x03\\\\x00ssdp:all\" ; char command4 [ ] = \"\\\\x04\\\\x00test:test:test\" ; const char bad_command [ ] = { 0xff , 0xff } ; const char overflow [ ] = { 0x01 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; <vul-start> const char command5 [ ] = { 0x05 , 0x00 } ; <vul-end> int s ; int i ; void * tmp ; unsigned char * resp = NULL ; size_t respsize = 0 ; unsigned char buf [ 4096 ] ; ssize_t n ; int total = 0 ; const char * sockpath = \"/var/run/minissdpd.sock\" ; for ( i = 0 ; i < argc - 1 ; i ++ ) { if ( 0 == strcmp ( argv [ i ] , \"-s\" ) ) sockpath = argv [ ++ i ] ; } command1 [ 1 ] = sizeof ( command1 ) - 3 ; command2 [ 1 ] = sizeof ( command2 ) - 3 ; command3compat [ 1 ] = sizeof ( command3compat ) - 3 ; command4 [ 1 ] = sizeof ( command4 ) - 3 ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command0 , sizeof ( command0 ) ) ; n",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <vul-start> n ) ; if ( n == 0 ) { <vul-start> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } ; const int command6 [ ] = { 0x03, 0x00 } ; const <vul-start> n ) ; if ( n == 0 ) { <vul-start> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command6, sizeof ( command6 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse ( buf, n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command7, sizeof ( command7 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse ( buf, n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command8, sizeof ( command8 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse ( buf, n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command9, sizeof ( command9 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse ( buf, n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command10, sizeof ( command10 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse ( buf, n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command11, sizeof ( command11 ) ) ; n = read ( s, buf, sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\", ( int ) n ) ; printresponse"
  },
  {
    "id": 542,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <vul-start> show_object ( obj , NULL , name , data ) ; <vul-end> continue ; } if ( ! path ) path = \"\" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <vul-start> NULL , path , data ) ; <vul-end> continue ; } die ( \"unknown pending object %s (%s)\" , oid_to_hex (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( obj , <vul-end> name , data <vul-start> , show_object , & base <vul-end> , path ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( obj, data, name <vul-end> ) ; continue <vul-start>, show_object, data, <vul-start> path, data, name\n"
  },
  {
    "id": 543,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , \"%s unable to load config file; attempting to transcode legacy file.\" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , \"%s unable to transcode legacy file, starting unconfigured.\" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , \"%s unable to allocate a config object.\" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <vul-start> alarm_timer = alarm_new ( ) ; <vul-end> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , \"%s unable to create alarm.\" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) ; } btif_config_devcache_cleanup ( ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } btif_config_free ( config ) ;\n"
  },
  {
    "id": 544,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <vul-start> int groups_per_flex = 0 ; <vul-end> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <vul-start> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <vul-end> <vul-start> if ( groups_per_flex < 2 ) { <vul-end> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , \"not enough memory for %u flex groups\" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] .",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ext4_group_t flex_group ; unsigned <vul-start> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <vul-start> -> s_log_groups_per_flex ; <vul-end> flex_group_count = (\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ext4_group_t flex_group ; unsigned int groups_per_flex = 1 << EXT4_DESC_PER_BLOCK_BITS ( sb ) <vul-end> ; size_t size <vul-start> ; groups_per_flex = 1LL << <vul-end> sbi -> s_log_groups_per_flex <vul-start> sbi -> s_log_groups_per_flex ; if (! sbi -> s_mb_cache ) { ext4_msg ( sb, KERN_ERR, \"No space for any data blocks\" ) ; return 0 ; } <vul-end> flex_group_count = (\n"
  },
  {
    "id": 545,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ; <vul-start> uint8_t * outbuf ; <vul-end> int rc ; <vul-start> command = buf [ 0 ] ; <vul-end> outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( \"Command: lun=%d tag=0x%x data=0x%02x\" , req -> lun , req -> tag , buf [ 0 ] ) ; # ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( \" 0x%02x\" , buf [ i ] ) ; } printf ( \"\\\\n\" ) ; } # endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 : <vul-start> rc = scsi_disk_emulate_command ( r , outbuf ) ; <vul-end> if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> uint8_t command ; <vul-end> int rc ; <vul-start> [ 0 ] <vul-end> ; DPRINTF ( <vul-start> scsi_disk_emulate_command ( r <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> command ; uint8_t <vul-end> rc ; command <vul-start> [ 0 ] <vul-end> ; DPRINTF ( <vul-start> scsi_disk_emulate_command ( r <vul-end> ) ; if\n"
  },
  {
    "id": 546,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , \"Seems not to be a TNEF file\\\\n\" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( \"TNEF Key: %hx\\\\n\" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( a -> type == szMAPI_BINARY && a -> <vul-start> else if ( a -> type == szMAPI_BINARY &&\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> name == MAPI_BODY_HTML && a -> num_values > 0 <vul-start> name == MAPI_RTF_COMPRESSED && a -> num_values > 0\n"
  },
  {
    "id": 547,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; <vul-start> int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <vul-end> int hexdump ; <vul-start> int offset , subobj_type , subobj_len , total_subobj_len ; <vul-end> int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , \"LMP version %u packet not supported\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"LMPv%u %s Message, length: %u\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , \"unknown (%u)\" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\tLMPv%u, msg-type: %s, Flags: [%s], length: %u\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , \"unknown, type: %u\" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , \"none\" , lmp_com_header -> flags ) , tlen ) ) ; <vul-start> tptr += sizeof ( const struct lmp_common_header ) ; <vul-end> tlen -= sizeof ( const struct",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; u_int <vul-end> tlen , lmp_obj_len <vul-start> int hexdump ; u_int offset ; u_int <vul-end> link_type ; union <vul-start> ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , \" (too short)\" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , \" (too long)\" ) ) ; tlen = len ; } <vul-start> & 0x7f ; <vul-end> ND_PRINT ( ( <vul-start> ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , \" (too short)\" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , \" (not a multiple of 4)\" ) ) ; return ; } <vul-start> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Link-ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_te_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; <vul-end> ND_PRINT ( ( <vul-start> \"\\\\n\\\\t    Local Link-ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_te_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Link-ID: %u (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( <vul-end> obj_tptr + 8 <vul-start> ; break ; <vul-end> default : hexdump <vul-start> case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_data_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_data_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %u (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: %s\" , bittok2str ( lmp_obj_begin_verify_flag_values , \"none\" , <vul-start> ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Interval: %u\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Data links: %u\" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Encoding type: %s\" , tok2str ( gmpls_encoding_values , \"Unknown\" , * ( obj_tptr + <vul-end> 8 ) ) <vul-start> ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Transport Mechanism: %u (0x%x)%s\" , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> ( obj_tptr + 10 ) , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? \" (Payload test messages capable)\" : \"\" <vul-end> ) ) ; <vul-start> ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Transmission Rate: %.3f Mbps\" , <vul-end> bw . f <vul-start> ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Wavelength: %u\" , EXTRACT_32BITS ( obj_tptr + 16 <vul-end> ) ) ) <vul-start> = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Dead Interval: %u\" \"\\\\n\\\\t    Verify Transport Response: %u\" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; <vul-end> default : hexdump <vul-start> break ; case LMP_OBJ_VERIFY_ID <vul-end> : switch ( <vul-start> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify ID: %u\" , EXTRACT_32BITS ( obj_tptr <vul-end> ) ) ) <vul-start> break ; case LMP_OBJ_CHANNEL_STATUS <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } <vul-end> break ; default <vul-start> break ; case LMP_OBJ_CHANNEL_STATUS_REQ <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } <vul-end> break ; default <vul-start> break ; case LMP_OBJ_ERROR_CODE <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Error Code: %s\" , bittok2str ( lmp_obj_begin_verify_error_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Error Code: %s\" , bittok2str ( lmp_obj_link_summary_error_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; <vul-end> default : hexdump <vul-start> break ; case LMP_OBJ_SERVICE_CONFIG <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Flags: %s\" <vul-end> , bittok2str ( <vul-start> , bittok2str ( lmp_obj_service_config_sp_flag_values <vul-end> , \"none\" , <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) <vul-end> ) ) ) <vul-start> , \"\\\\n\\\\t  UNI Version: %u\" , EXTRACT_8BITS ( obj_tptr + 1 ) <vul-end> ) ) ; <vul-start> case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Link Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , \"Unknown\" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , \"\\\\n\\\\t Signal Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , \"Unknown\" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , \"\\\\n\\\\t Signal Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , \"Unknown\" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Transparency: %s\" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Contiguous Concatenation Types: %s\" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Minimum NCC: %u\" , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Maximum NCC: %u\" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Minimum NVC:%u\" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Maximum NVC:%u\" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Transparency Flags: %s\" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t TCM Monitoring Flags: %s\" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Diversity: Flags: %s\" <vul-end> , bittok2str ( <vul-start> , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values <vul-end> , \"none\" , <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr + 3 ) <vul-end> ) ) )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; unsigned <vul-start> ( ndo, \"\\\\n\\\\t Hello Interval: %u\\\\n\\\\t Hello Dead Interval: %u\" <vul-end>, EXTRACT_16BITS ( <vul-start> case LMP_CTYPE_IPV4_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_IPV6 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_HELLO : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_IPV6 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_HELLO : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_OBJ_TE_LINK : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_UNMD_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_OBJ_DATA_LINK : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_3 : ND_"
  },
  {
    "id": 548,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , \"openssl\" , sizeof ( \"openssl\" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , \"openssl not loaded\" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , \"%s.pubkey\" , fname ) ; pfp = php_stream_open_wrapper ( pfile , \"rb\" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , \"openssl public key could not be read\" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <vul-end> ) ) { <vul-start> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> PHP_SHA256_CTX context ; if (! <vul-start> & context ) ) { return FAILURE ; } <vul-end> read_len = end_of_phar <vul-start> context ) ; if (! <vul-start> & context ) ) { return FAILURE ; }\n"
  },
  {
    "id": 549,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <vul-start> int is_rf64 = ! strncmp ( fourcc , \"RF64\" , 4 ) , got_ds64 = 0 ; <vul-end> int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( \"can\\'t handle .WAV files larger than 4 GB (non-standard)!\" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , \"WAVE\" , 4 ) ) ) { error_line ( \"%s is not a valid .WAV file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) , got_ds64 = 0 , format_chunk <vul-start> , format ; if ( format_chunk ++ ) { error_line ( \"%s is not a valid .WAV file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int is_rf64 = ( <vul-start>, 4 ) ) <vul-start> { int supported <vul-end>, format ; <vul-start> { if (! config -> sample_rate ||\n"
  },
  {
    "id": 550,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <vul-start> vp9_coeff_stats * coef_branch_ct ) { <vul-end> <vul-start> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <vul-end> vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ]",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> vp9_coeff_stats * coef_branch_ct , <vul-end> vp9_coeff_probs_model * coef_probs <vul-start> vp9_coeff_probs_model * coef_probs ) { vp9_coeff_count * coef_counts <vul-start> = cpi -> td . rd_counts . <vul-end> coef_counts [ tx_size\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> TX_SIZE tx_size, vpx_coeff_stats <vul-end> * coef_branch_ct ) <vul-start> coef_branch_ct ) { vpx_coeff_probs_model * coef_probs = cpi -> coef_probs <vul-end> [ tx_size ]\n"
  },
  {
    "id": 551,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ; <vul-start> pStart = sqlite3Malloc ( sz * cnt ) ; <vul-end> sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ( sz * ( sqlite3_int64 )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; pStart = sqlite3_malloc64 <vul-end> ( sz *\n"
  },
  {
    "id": 552,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <vul-end> { u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x02 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> msleep ( 300 ) ; <vul-end> obuf [ 0 ] = 0xe ; <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> <vul-start> err ( \"command 0x0e transfer failed.\" ) ; <vul-end> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; msleep ( 300 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 0 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0x51 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> ) err ( <vul-end> \"command 0x51 transfer failed.\" ) ; <vul-start> \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <vul-end> -> fe_adap [ <vul-start> & d -> <vul-end> i2c_adap ) ; <vul-start> ; if ( adap <vul-end> -> fe_adap [ <vul-start> ( ts2020_attach , adap <vul-end> -> fe_adap [ <vul-start> , & d <vul-end> -> i2c_adap )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> dvb_usb_adapter * d, struct dvb_usb_device * dev <vul-start>, 1, d -> dev -> bus <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; <vul-end> d -> fe_adap <vul-start> = 0xe ; d -> fe_adap [ 1 ] = 0x02 ; d -> fe_adap [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev, <vul-end> obuf, 3 <vul-start>, ibuf, d -> dev -> bus <vul-end>, 0 ) <vul-start> \"command 0x0e transfer failed.\" ) ; d -> fe_adap [ 0 ] = 0xe ; d -> fe_adap [ 1 ] = 0x83 ; d -> fe_adap [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev, <vul-end> d -> dev <vul-start> dev -> i2c_adap, d -> dev -> bus <vul-start> ; msleep ( 300 <vul-end> ) ; obuf <vul-start> = 0xe ; d -> fe_adap [ 1 ] = 0x83 ; d -> fe_adap [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev, <vul-end> d -> dev <vul-start>, ibuf, d -> dev -> bus <vul-end>, 1, <vul-start> \"command 0x0e transfer failed.\" ) ; d -> fe_adap [ 0 ] = 0xe ; d -> fe_adap [ 1 ] = 0x83 ; d -> fe_adap [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev, <vul-end> d -> dev <vul-start> d -> dev, <vul-end> d -> dev <vul-start>, ibuf, d -> dev -> bus <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; d -> fe_adap [ 0 ] = 0xe ; d -> fe_adap [ 1 ] = 0x83 ; d -> fe_adap [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev, <vul-end> d -> dev <vul-start> -> dev, <vul-end> d -> dev <vul-start> -> i2c_adap ) ) { info ( \"Attached DS3000/TS2020!\" ) ;"
  },
  {
    "id": 553,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <vul-start> - EFAULT ; <vul-end> ipxitf_put ( ipxif <vul-start> ( ipxif ) <vul-end> ; break ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; if ( sipx -> sipx_node == NULL ) break ; <vul-start> arg, & sipx -> <vul-start>, sizeof ( sipx -> sipx_node <vul-end> ) ) ) <vul-start> ) break ; sipx -> sipx_node [ sizeof ( sipx -> sipx_node ) - 1 ] = 0 ;\n"
  },
  {
    "id": 554,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> break ; } <vul-end> dst_reg -> smin_value <vul-start> = S64_MAX ; <vul-end> if ( src_known\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> break ; } <vul-end> dst_reg -> smin_value <vul-start> = S64_MAX ; <vul-end> if ( src_known\n"
  },
  {
    "id": 555,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <vul-start> vpx_codec_enc_cfg_t * cfg , <vul-end> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <vul-start> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <vul-end> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <vul-start> if ( ctx -> priv ) <vul-end> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * iface , const <vul-start> ( flags & <vul-end> VPX_CODEC_USE_PSNR ) && <vul-start> ) ; } <vul-end> } return SAVE_STATUS\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * iface, const <vul-start> ( flags & <vul-end> VPX_CODEC_USE_PSNR ) && <vul-start> ) ; } <vul-end> } return SAVE_STATUS\n"
  },
  {
    "id": 556,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; <vul-start> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <vul-end> for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> & JPEG2000_CBLK_VSC ; if (! cblk -> data ) { return 0 ; }\n"
  },
  {
    "id": 557,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , <vul-start> int uv_block_size , <vul-end> int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel = <vul-start> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <vul-end> enum mv_precision mv_precision_uv ; int uv_stride ; <vul-start> if ( uv_block_size == 8 ) { <vul-end> uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } <vul-start> vp9_build_inter_predictor ( y_mb_ptr , stride , <vul-end> & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride , <vul-start> & pred [ 256 ] , uv_block_size , <vul-end> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride , <vul-start> & pred [ 512 ] , uv_block_size , <vul-end> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> stride , int uv_block_width , int uv_block_height <vul-end> , int mv_row <vul-start> const kernel = vp9_filter_kernels [ <vul-end> xd -> mi <vul-start> mbmi . interp_filter ] <vul-end> ; enum mv_precision <vul-start> ; if ( uv_block_width <vul-end> == 8 ) <vul-start> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <vul-start> 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <vul-end> , which_mv , <vul-start> 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <vul-end> , which_mv ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> stride, int uv_filter_size, int <vul-start> * const kernel <vul-end> ; enum mv_precision <vul-start> int uv_stride ; # if CONFIG_VP9_HIGHBITDEPTH const MV_FLAG_HIGHBITDEPTH = MV_FLAG_HIGHBITDEPTH ; # else const MV_FLAG_HIGHBITDEPTH = MV_FLAG_HIGHBITDEPTH ; # endif <vul-start> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { const int high_bitdepth = xd -> bd -> bit_depth ; const int low_bitdepth = xd -> bd -> low_bitdepth ; const int low_bitdepth = xd -> bd -> bit_depth ; # else const MV_FLAG_HIGHBITDEPTH = MV_FLAG_HIGHBITDEPTH ; # endif <vul-start> & pred [ 0 <vul-end> ], uv_block_size <vul-start> & pred [ 256 <vul-end> ], uv_block_size <vul-start> & pred [ 512 <vul-end> ], uv_block_size\n"
  },
  {
    "id": 558,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\\\n\" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p =",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <vul-start> low ) ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ONIG_INFINITE_DISTANCE ) { if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc, s, * low, ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, ( pprev? pprev : s ), * low ) ; } else { if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, ( pprev? pprev : str ), * low ) ; } } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc, ( pprev? pprev : str ), * low ) ; } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr, \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\\\n\", ( int ) ( * low - str ), ( int ) ( * high - str ), reg -> dmin, reg -> dmax ), ( int ) ( * high - str ), reg -> dmin ), reg -> dmax ) ; # endif return 1 ; } return 0 ; } return 0 ; } <vul-end> }  \n"
  },
  {
    "id": 559,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\\\n' ) ; if ( next_line ) { * next_line = '\\\\0' ; next_line ++",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ! new_idmap_permitted ( file ,\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if ( new_map. nr_extents == 0 ) goto out ; if (\n"
  },
  {
    "id": 560,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int amqp_handle_input ( amqp_connection_state_t state , amqp_bytes_t received_data , amqp_frame_t * decoded_frame ) { size_t bytes_consumed ; void * raw_frame ; decoded_frame -> frame_type = 0 ; if ( received_data . len == 0 ) { return AMQP_STATUS_OK ; } if ( state -> state == CONNECTION_STATE_IDLE ) { state -> state = CONNECTION_STATE_HEADER ; } bytes_consumed = consume_data ( state , & received_data ) ; if ( state -> inbound_offset < state -> target_size ) { return ( int ) bytes_consumed ; } raw_frame = state -> inbound_buffer . bytes ; switch ( state -> state ) { case CONNECTION_STATE_INITIAL : if ( memcmp ( raw_frame , \"AMQP\" , 4 ) == 0 ) { decoded_frame -> frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER ; decoded_frame -> channel = 0 ; decoded_frame -> payload . protocol_header . transport_high = amqp_d8 ( amqp_offset ( raw_frame , 4 ) ) ; decoded_frame -> payload . protocol_header . transport_low = amqp_d8 ( amqp_offset ( raw_frame , 5 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_major = amqp_d8 ( amqp_offset ( raw_frame , 6 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_minor = amqp_d8 ( amqp_offset ( raw_frame , 7 ) ) ; return_to_idle ( state ) ; return ( int ) bytes_consumed ; } case CONNECTION_STATE_HEADER : { amqp_channel_t channel ; amqp_pool_t * channel_pool ; <vul-start> channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ; <vul-end> <vul-start> state -> target_size = <vul-end> <vul-start> amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) + HEADER_SIZE + FOOTER_SIZE ; <vul-end> if ( ( size_t ) state",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * channel_pool ; uint32_t frame_size ; <vul-start> ) ) ; frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ; if ( frame_size >= INT32_MAX ) { return AMQP_STATUS_BAD_AMQP_DATA ; } <vul-start> -> target_size = frame_size <vul-end> + HEADER_SIZE +\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * channel_pool ; size_t target_size ; <vul-start> ) ) ; target_size = <vul-end> amqp_d32 ( amqp_offset <vul-start>, 3 ) ) ; if ( target_size < HEADER_SIZE + FOOTER_SIZE ) { return AMQP_STATUS_BAD_AMQP_DATA ; } state -> target_size = target_size ; decoded_frame -> payload. protocol_header. transport_high = ( amqp_d8 ( raw_frame, 5 ) ) ; decoded_frame -> payload. protocol_header. transport_low = ( amqp_d8 ( raw_frame, 6 ) ) ; decoded_frame -> payload. protocol_header. protocol_version_major = ( amqp_d8 ( raw_frame, 7 ) ) ; decoded_frame -> payload. protocol_header. protocol_version_minor = target_size ; decoded_frame -> payload. header. transport_high = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. transport_low = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. transport_high = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. transport_low = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. transport_high = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. transport_low = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_header. protocol_version_major = ( amqp_d8 ( raw_frame, 8 ) ) ; decoded_frame -> payload. protocol_version_minor = ( amqp_d8 ( raw_frame, 8 ) ) ; return_to_idle ( state ) ; return ( int ) bytes_consumed ; } case CONNECTION_STATE_HEADER : { amqp_bytes_t raw ; void * raw_frame ; void * channel_pool ; if ( memcmp ( raw_frame, \"AMQP\", 4 ) == 0 ) { decoded_frame -> frame_type = AMQP_FRAME_HEADER ; decoded_frame -> payload. header. transport_high ="
  },
  {
    "id": 561,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <vul-start> if ( file -> name ) XFREE ( file -> name ) ; <vul-end> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <vul-start> file -> len = a -> values [ 0 ] . len ; <vul-end> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <vul-start> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <vul-end> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <vul-start> if ( file -> content_id ) XFREE ( file -> content_id ) ; <vul-end> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <vul-start> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <vul-start> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <vul-start> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case MAPI_ATTACH_LONG_FILENAME : <vul-end> file -> name <vul-start> file -> name = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> name, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len <vul-end> ) ; break <vul-start> case MAPI_ATTACH_DATA_OBJ : <vul-end> file -> data <vul-start> file -> mime_type = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> mime_type, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <vul-end> file -> content_id <vul-start> file -> content_id = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> content_id, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <vul-end> file -> content_id <vul-start> file -> content_id = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> content_id, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len ) ; break ; case MAPI_ATTACH_DATA_ID : <vul-end> file -> content_id <vul-start> file -> content_id = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> content_id, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len ) ; break ; case MAPI_ATTACH_DATA_OBJ : file -> len = a -> values [ 0 ]. len ; file -> data = CHECKED_XMALLOC ( char, a -> values [ 0 ]. len ) ; memmove ( file -> data, a -> values [ 0 ]. data. buf, a -> values [ 0 ]. len ) ; break ; case MAPI_ATTACH_MIME_TAG : file -> mime_type = CHECKED_XMALLOC ( char, a ->"
  },
  {
    "id": 562,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( \"I1012\" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , \"Unable to select public key file: %s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } <vul-start> bufsize = file -> size ; <vul-end> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , \"Unable to read public key file: %s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( \"Key number %d not found.\\\\n\" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> } bufsize = MIN ( <vul-start> file -> size , sizeof buf )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } bufsize = MIN ( <vul-start> file -> size, sizeof buf )\n"
  },
  {
    "id": 563,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 boolean parse_config_line ( origbuf ) char * origbuf ; { # if defined ( MICRO ) && ! defined ( NOCWD_ASSUMPTIONS ) static boolean ramdisk_specified = FALSE ; # endif # ifdef SYSCF int n , src = iflags . parse_config_file_src ; # endif char * bufp , buf [ 4 * BUFSZ ] ; uchar translate [ MAXPCHARS ] ; int len ; boolean retval = TRUE ; <vul-start> mungspaces ( strcpy ( buf , origbuf ) ) ; <vul-end> bufp = find_optparam ( buf ) ; if ( ! bufp ) { config_error_add ( \"Not a config statement, missing \\'=\\'\" ) ; return FALSE ; } ++ bufp ; if ( * bufp == ' ' ) ++ bufp ; if ( match_varname ( buf , \"OPTIONS\" , 4 ) ) { bufp = find_optparam ( origbuf ) ; ++ bufp ; if ( ! parseoptions ( bufp , TRUE , TRUE ) ) retval = FALSE ; } else if ( match_varname ( buf , \"AUTOPICKUP_EXCEPTION\" , 5 ) ) { add_autopickup_exception ( bufp ) ; } else if ( match_varname ( buf , \"BINDINGS\" , 4 ) ) { if ( ! parsebindings ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , \"AUTOCOMPLETE\" , 5 ) ) { parseautocomplete ( bufp , TRUE ) ; } else if ( match_varname ( buf , \"MSGTYPE\" , 7 ) ) { if ( ! msgtype_parse_add ( bufp ) ) retval = FALSE ; # ifdef NOCWD_ASSUMPTIONS } else if ( match_varname ( buf , \"HACKDIR\" ,",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> = TRUE ; while ( * origbuf == ' ' || * origbuf == '\\\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\\\0' ; mungspaces ( buf <vul-end> ) ; bufp\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> = TRUE ; if ( strlen ( origbuf ) + 4 > sizeof ( buf ) ) { config_error_add ( \"Not a config statement, too many \\'=\\'\" ) ; return FALSE ; }\n"
  },
  {
    "id": 564,
    "question": "CWE-863 Code Input Vulnerable Code Is: CWE-863 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\\\n' ) ; if ( next_line ) { * next_line = '\\\\0' ; next_line ++ ; if ( * next_line == '\\\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos =",
    "golden_answers": [
      "CWE-863 Fixed Code Lines are: <vul-start> & new_map ) <vul-end> ) goto out <vul-start> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;\n"
    ],
    "generated_answer": "CWE-863 Fixed Code Lines are: <vul-start>, & new_map, 0 <vul-start> } if (! new_map. forward ||! new_map. reverse ) { kfree ( new_map. forward ) ; kfree ( new_map. reverse ) ; } if (\n"
  },
  {
    "id": 565,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; <vul-start> int pixel_ptr = 0 ; <vul-end> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , \"First chunk byte is 0x%02x instead of 0xe1\\\\n\" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , \"MOV chunk size != encoded chunk size; using MOV chunk size\\\\n\" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode &",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int pixel_ptr = - 4 <vul-end> ; int block_ptr <vul-start> -- ) { ADVANCE_BLOCK ( ) <vul-start> row_inc ; } <vul-end> } break ; <vul-start> -- ) { ADVANCE_BLOCK ( ) ; <vul-start> row_inc ; } <vul-end> } break ; <vul-start> ) return ; ADVANCE_BLOCK ( ) ; <vul-start> row_inc ; } <vul-end> break ; default\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int pixel_ptr = 0 ; int block_ptr = 0 ; int pixel_y ; int total_blocks ; int row_ptr <vul-start> -- ) { if ( s -> size < stream_ptr + pixel_ptr ) { av_log ( s -> avctx, AV_LOG_ERROR, \"b/26366256\" ) ; return ; } <vul-start> row_inc ; } if ( s -> size < block_ptr + pixel_ptr ) { av_log ( s -> avctx, AV_LOG_ERROR, \"b/26366256\" ) ; return ; } <vul-start> row_inc ; } if ( s -> size < block_ptr + pixel_ptr ) { av_log ( s -> avctx, AV_LOG_ERROR, \"b/26366256\" ) ; return ; }\n"
  },
  {
    "id": 566,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <vul-start> unsigned int link_count ; <vul-end> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , \"(ino %ld) failed !bh\\\\n\" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , \"(ino %ld) failed ident=%d\\\\n\" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <vul-start> struct buffer_head * nbh = NULL ; <vul-end> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <vul-start> if (",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> int link_count ; unsigned int indirections = 0 ; reread : <vul-start> ) { struct <vul-end> kernel_lb_addr loc ; <vul-start> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <vul-end> , & loc <vul-start> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , \"too many ICBs in ICB hierarchy\" \" (max %d supported)\\\\n\" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <vul-end> ( inode ) <vul-start> return ; } goto reread <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> unsigned int link_count ; struct kernel_lb_addr loc <vul-start> ibh ) { if ( iinfo -> i_alloc_type == UDFTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc!= inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; } if ( iinfo -> i_alloc_type == UDFTAG_FLAG_AD_IN_ICB ) goto out ; <vul-start> ; if ( ( <vul-start> indirectICB. extLength!= 0 ) && ( iinfo -> i_alloc_type == UDFTAG_FLAG_AD_IN_ICB ) <vul-start> return ; } if ( iinfo -> i_alloc_type == UDFTAG_FLAG_AD_IN_ICB ) goto out ;\n"
  },
  {
    "id": 567,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; <vul-start> int err = 0 ; <vul-end> if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; int err = 0 ; msg -> msg_namelen\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> err = 0 ; msg -> msg_namelen = 0\n"
  },
  {
    "id": 568,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <vul-start> uint32 num_properties = GETINT32 ( buf + idx ) ; <vul-end> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ;",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <vul-start> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <vul-start> += 4 ; assert ( v -> len + idx <= len ) ; <vul-start> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> 4 ) ; size_t prop_size = 0 ; <vul-start> buf + idx, & prop_size <vul-start> ; j < prop_size <vul-end> ; j ++\n"
  },
  {
    "id": 569,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <vul-start> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <vul-end> <vul-start> TileBuffer tile_buffers [ 1 << 6 ] ; <vul-end> int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) { <vul-start> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <vul-end> int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers , <vul-start> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <vul-end> for ( i = 0 ; i < num_threads ; ++ i ) { <vul-start> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <vul-end> ++ pbi -> num_tile_workers ; <vul-start> vp9_worker_init ( worker ) ; <vul-end> CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; <vul-start> if ( i",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <vul-start> ( pbi -> <vul-end> max_threads & ~ <vul-start> tile_buffers [ 1 ] [ 1 <vul-start> = pbi -> <vul-end> max_threads & ~ <vul-start> pbi -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> -> num_tile_workers ; winterface -> init ( worker <vul-end> ) ; if <vul-start> 1 && ! winterface -> reset <vul-end> ( worker ) <vul-start> n ) { VPxWorker * const worker = & <vul-start> [ n ] ; winterface -> sync ( worker ) ; worker -> <vul-end> hook = ( <vul-start> hook = ( VPxWorkerHook <vul-end> ) tile_worker_hook ; <vul-start> ) tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <vul-end> ( cm -> <vul-start> aligned_mi_cols ) ; memset <vul-end> ( cm -> <vul-start> aligned_mi_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <vul-end> n == tile_cols <vul-start> tile_cols - 1 ) { winterface -> execute <vul-end> ( worker ) <vul-start> } else { winterface -> launch <vul-end> ( worker ) <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> corrupted |= ! winterface -> sync <vul-end> ( worker ) <vul-start> ; bit_reader_end = vpx_reader_find_end <vul-end> ( & tile_data <vul-start> - 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data_end ) { const TileWorkerData * const tile_data = ( TileWorkerData * ) data ; const TileBuffer * const tile_buffers = ( TileBuffer * ) data_end ; const int num_workers = MIN ( pbi -> oxcf. max_threads, tile_cols ) ; TileBuffer tile_buffers [ 1 << 6 ] ; int n ; int final_worker = - 1 ; const uint8_t * const bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_rows = 1 << cm -> log2_tile_rows ; const int num_workers = MIN ( pbi -> oxcf. max_threads & ~ 1, tile_cols ) ; TileBuffer tile_buffers [ 1 << 6 ] ; int n ; int final_worker = - 1 ; if ( pbi -> num_tile_workers == 0 ) { const int num_threads = pbi -> oxcf. max_threads & ~ 1 ; assert ( tile_cols == 1 ) ; assert ( tile_rows == 1 ) ; assert ( pbi -> num_tile_workers == 0 ) ; if ( pbi -> num_workers == 0 ) { const int num_workers = pbi -> oxcf. max_threads ; const int worker_id = pbi -> num_workers ; const worker = & worker -> tile_workers [ worker_id ] ; const worker -> data1 = vpx_malloc ( sizeof ( TileWorkerData ) ) ; memset ( worker -> data1, 0, sizeof ( TileWorkerData ) ) ; memset ( worker -> data2, 0, sizeof ( TileInfo ) ) ; vp9_worker_init ( worker ) ; if ( worker -> data1 == 0 && worker -> data2 == 0 ) { vpx_internal_error ( & cm -> error, VPX_CODE_ERROR, \"Failed to allocate TileWorkerData\" ) ; } } } for ( i = 0 ; i < num_workers ; ++ i ) { const <vul-start> pbi -> common <vul-end> ; const uint8_t <vul-start> const worker = worker -> data1 ; worker -> data2 = vpx_malloc ( sizeof ( TileInfo ) ) ) ; vp9_worker_init ( worker"
  },
  {
    "id": 570,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ; <vul-start> offset = base + get4 ( ) + 8 ; <vul-end> while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; <vul-start> switch ( tag ) <vul-end> { case 0x505244 : fseek ( ifp , 8 , SEEK_CUR ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <vul-start> ( ) ; if ( len < 0 ) return ;\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> * 0x101 ; if ( sizeof ( ifdata. color ) < 8 ) return ; <vul-start> ( ) ; if ( sizeof ( ifdata. color ) < 8 ) return ;\n"
  },
  {
    "id": 571,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; <vul-start> if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) <vul-end> { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; <vul-start> if ( ! ps_dec -> u1_first_slice_in_stream ) <vul-end> { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec ->",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; <vul-start> = u2_frame_num ; <vul-end> { WORD32 i\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> WORD32 ret ; UINT32 u1_mbaff_flag = ps_dec -> ps_dec_err_status -> u1_mbaff_flag ; <vul-start> -> ps_dec_err_status -> u1_mbaff_flag <vul-end> & REJECT_CUR_PIC ) <vul-start> -> ps_dec_err_status -> u1_mbaff_flag <vul-end> & REJECT_CUR_PIC )\n"
  },
  {
    "id": 572,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; <vul-start> err = - EINVAL ; <vul-end> if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &=",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> err = - <vul-end> EALREADY ; if <vul-start> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <vul-end> match -> type <vul-start> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> - EINVAL ; lock_sock ( sk ) ; <vul-start> ; } } <vul-end> if ( err\n"
  },
  {
    "id": 573,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 <vul-start> static int mptctl_do_reset ( unsigned long arg ) <vul-end> { struct mpt_ioctl_diag_reset __user * urinfo = ( void __user * ) arg ; <vul-start> struct mpt_ioctl_diag_reset krinfo ; <vul-end> MPT_ADAPTER * iocp ; if ( copy_from_user ( & krinfo , urinfo , sizeof ( struct mpt_ioctl_diag_reset ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \" \"Unable to copy mpt_ioctl_diag_reset struct @ %p\\\\n\" , __FILE__ , __LINE__ , urinfo ) ; <vul-start> return - EFAULT ; <vul-end> } if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) { printk ( KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , krinfo . hdr . iocnum ) ; return - ENODEV ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\\\n\" , iocp -> name ) ) ; if ( mpt_HardResetHandler ( iocp , CAN_SLEEP ) != 0 ) { printk ( MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\\\n\" , iocp -> name , __FILE__ , __LINE__ ) ; return - 1 ; } return 0 ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_do_reset ( MPT_ADAPTER * iocp , <vul-start> struct mpt_ioctl_diag_reset krinfo <vul-end> ; if ( <vul-start> return - EFAULT <vul-end> ; } dctlprintk\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_do_reset ( MPT_ADAPTER * iocp, <vul-start> struct mpt_ioctl_diag_reset krinfo <vul-end> ; if ( <vul-start> return - EFAULT <vul-end> ; } dctlprintk\n"
  },
  {
    "id": 574,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { <vul-start> size_t off = 0 , len = 0 ; <vul-end> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> len = 0 , end <vul-start> ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <vul-end> || res_sz <\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0x80 ) { char * base_ptr = NULL, * delta_ptr = NULL ; <vul-start> off + len ) goto fail ; if ( base_ptr == NULL || res_sz < len ) goto fail ; memcpy ( base_ptr, base + off, len ) ; delta_ptr = delta ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp, delta, cmd ) ; delta += cmd ; res_sz -= cmd ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp, delta, cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp, delta, cmd ) ; delta += cmd ; res_sz -= cmd ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp, delta, cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta!= delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out_len = 0 ; <vul-start> 1 ; } <vul-end>      \n"
  },
  {
    "id": 575,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <vul-start> int ret = 0 ; <vul-end> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <vul-start> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <vul-end> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <vul-start> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <vul-end> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * bh ; unsigned int table_len ; <vul-start> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , \"error loading logical volume descriptor: \" \"Partition table too long (%u > %lu)\\\\n\" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <vul-start> && offset < table_len <vul-end> ; i ++\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * bh ; size_t map_len ; <vul-start> TAG_IDENT_LVD ) ; if ( sbi -> s_mount_state == UDF_ORPHAN_FS ) { map_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( map_len > UDF_MAX_PARTITION_MAPS ) goto out_bh ; } <vul-start> -> b_data ; if ( map_len > UDF_MAX_PARTITION_MAPS ) goto out_bh ; <vul-start> -> s_partitions && ( <vul-start> -> mapTableLength ) - offset ) )\n"
  },
  {
    "id": 576,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; <vul-start> struct segmentation * seg = & cm -> seg ; <vul-end> const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; <vul-start> vp9_clear_system_state ( ) ; <vul-end> <vul-start> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <vul-end> <vul-start> int qindex_delta , segment_rdmult ; <vul-end> <vul-start> if ( Q_RATIO ( i ) == 1 ) { <vul-end> RDMULT_RATIO ( i ) = 1 ; continue ; } <vul-start> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <vul-end> <vul-start> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <vul-end> <vul-start> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <vul-end> <vul-start> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <vul-end> cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cm -> seg <vul-end> ; int i <vul-start> = SEGMENT_DELTADATA ; vpx_clear_system_state <vul-end> ( ) ; <vul-start> ( i = 0 ; i < MAX_SEGMENTS ; ++ i <vul-end> ) { int <vul-start> { int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <vul-end> ; if ( <vul-start> ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <vul-end> continue ; } <vul-start> continue ; } <vul-end> vp9_set_segdata ( seg <vul-start> ( seg , i <vul-end> , SEG_LVL_ALT_Q , <vul-start> ( seg , i <vul-end> , SEG_LVL_ALT_Q ) <vul-start> SEG_LVL_ALT_Q ) ; <vul-end> } } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> common ; VP9_COMMON_INFO * const cpi_info = & cpi -> common_info ; struct segmentation * const seg = & cpi_info -> seg ; const double base_q = vp9_convert_qindex_to_q ( cpi -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi, cpi -> rc. is_src_frame_alt_ref ) ; int i ; if ( cpi -> rc. is_src_frame_alt_ref ) { const int shift = ( cpi -> rc. rc_mode == VPX_CBR || cpi -> rc. rc_mode == VPX_GOLDEN )? vp9_GOLDEN_SHIFT : vp9_GOLDEN_SHIFT ; if ( cpi -> rc. is_src_frame_alt_ref ) { shift = vp9_SHIFT_8 ; } <vul-start> = SEGMENT_DELTADATA ; seg -> seg_flags |= VPX_SEGMENT_FLAG_HIGHBITDEPTH ; seg -> seg_flags |= VPX_SEGMENT_FLAG_HIGHBITDEPTH ; <vul-start> ( i = 0 <vul-end> ; i <= <vul-start> ; i <= ENERGY_MAX <vul-end> ; i ++ <vul-start> ++ ) { double <vul-end> segment_rdmult ; if <vul-start> ; if ( cpi -> rc. <vul-start> continue ; } const int qindex = vp9_compute_qdelta ( & cpi -> rc, base_q, base_q * <vul-start> ) ) ; set_segdata <vul-end> ( seg, <vul-start> i ), SEG_LVL_ALT_Q, qindex <vul-end> ) ; vp9_enable_segfeature <vul-start> i ), SEG_LVL_ALT_Q ) ; set_segfeature <vul-end> ( seg, <vul-start> i ), SEG_LVL_ALT_Q ) ; segment_rdmult = vp9_compute_rd_mult ( cpi, cpi -> base_qindex + qindex + <vul-end> cm -> y_dc_delta_q\n"
  },
  {
    "id": 577,
    "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ; <vul-start> char * method = manager -> method ; <vul-end> int i ; <vul-start> build_config ( working_dir , server ) ; <vul-end> if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , <vul-start> \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , <vul-end> <vul-start> executable , method , manager -> manager_address , <vul-end> <vul-start> working_dir , server -> port , working_dir , server -> port ) ; <vul-end> if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" --acl %s\" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -t %s\" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -n %d\" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -a %s\" , manager -> user ) ; } if ( manager -> verbose",
    "golden_answers": [
      "CWE-78 Fixed Code Lines are: <vul-start> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <vul-end> ; build_config ( <vul-start> ( working_dir , manager , server ) <vul-end> ; memset ( <vul-start> , BUF_SIZE , \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\" <vul-end> , executable , <vul-start> , executable , <vul-end> manager -> manager_address <vul-start> , working_dir , <vul-end> port , working_dir <vul-start> , working_dir , <vul-end> port ) ;\n"
    ],
    "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> = manager -> cmd <vul-end> ; int i <vul-start> ; build_config ( <vul-end> server ) ; <vul-start>, BUF_SIZE, \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" <vul-end>, executable, <vul-start> manager -> manager_address <vul-end>, server -> <vul-start> server -> port ) ; snprintf ( cmd, BUF_SIZE, \" --acl %s\", manager -> acl\n"
  },
  {
    "id": 578,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> err = -\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> err = -\n"
  },
  {
    "id": 579,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <vul-start> if ( ! net_eq ( net , & init_net ) ) <vul-end> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (\n"
  },
  {
    "id": 580,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( \"REVALIDATION DEFERRED on port %d, pid:%d\\\\n\" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( \"REVALIDATING DOMAIN on port %d, pid:%d\\\\n\" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( \"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\\\n\" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> disco_mutex ) ; sas_probe_devices ( port ) ;\n"
  },
  {
    "id": 581,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , \"%s failure: config access disabled\\\\n\" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) { <vul-start> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <vul-end> if ( csum ) <vul-start> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <vul-end> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) dev -> hw_features |= NETIF_F_TSO ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) dev -> hw_features |= NETIF_F_TSO6 ; if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> NETIF_F_HW_CSUM | NETIF_F_SG <vul-end> ; if ( <vul-start> NETIF_F_HW_CSUM | NETIF_F_SG <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> hw_features |= <vul-end> NETIF_F_SG | NETIF_F_FRAGLIST <vul-start> -> features |= <vul-end> NETIF_F_SG | NETIF_F_FRAGLIST\n"
  },
  {
    "id": 582,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <vul-start> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <vul-end> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <vul-start> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <vul-end> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = VP8_BD_VALUE_SIZE - CHAR_BIT <vul-end> - ( count <vul-start> ( count + CHAR_BIT <vul-end> ) ; size_t <vul-start> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <vul-end> ; br ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = VP8_BD_VALUE_SIZE - <vul-end> ( count + <vul-start> + 8 ) * CHAR_BIT <vul-start> size_t n = ( bytes_left < 0 )? bytes_left : 0 <vul-end> ; br ->\n"
  },
  {
    "id": 583,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t coapClientWriteBody ( CoapClientRequest * request , const void * data , size_t length , size_t * written , bool_t last ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; if ( written != NULL ) * written = 0 ; while ( length > 0 || last ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapGetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> txBlockSzx ; } error = coapClientGetPayload ( requestMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( length > 0 && payloadLen < COAP_GET_BLOCK_SIZE ( blockSzx ) ) { n = MIN ( length , COAP_GET_BLOCK_SIZE ( blockSzx ) - payloadLen ) ; error = coapClientWritePayload ( requestMsg , data , n ) ; if ( error ) break ; data = ( uint8_t * ) data + n ; length -= n ; if ( written != NULL ) * written += n ; } else { if ( blockPos > 0 || length > 0 || ! last ) { COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; if ( length == 0 && last ) <vul-start> COAP_SET_BLOCK_M",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> && last ) { <vul-start> 0 ) ; } else { <vul-end> COAP_SET_BLOCK_M ( value <vul-start> 1 ) ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> && last ) { <vul-start> 0 ) ; } else { <vul-end> COAP_SET_BLOCK_SZX ( value <vul-start> 1 ) ; }\n"
  },
  {
    "id": 584,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void ourWriteOut ( CURL * curl , struct OutStruct * outs , const char * writeinfo ) { FILE * stream = stdout ; const char * ptr = writeinfo ; char * stringp = NULL ; long longinfo ; double doubleinfo ; while ( ptr && * ptr ) { <vul-start> if ( '%' == * ptr ) { <vul-end> if ( '%' == ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '{' == ptr [ 1 ] ) { bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( \"%{\" , stream ) ; continue ; } keepit = * end ; * end = 0 ; for ( i = 0 ; replacements [ i ] . name ; i ++ ) { if ( curl_strequal ( ptr , replacements [ i ] . name ) ) { match = TRUE ; switch ( replacements [ i ] . id ) { case VAR_EFFECTIVE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_EFFECTIVE_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_HTTP_CODE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_RESPONSE_CODE , & longinfo ) ) fprintf ( stream , \"%03ld\" , longinfo ) ; break ; case VAR_HTTP_CODE_PROXY : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_CONNECTCODE",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> == * ptr && ptr [ 1 ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ptr ) { char * s = NULL ; if ( NULL == ptr ) { fprintf ( stream, \"Error: invalid output buffer\\\\n\" ) ; ptr = writeinfo ; continue ; } s = strchr ( ptr, '{' ) ; if ( s == NULL ) { fputs ( \"Error: invalid output buffer\\\\n\", stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '}' == end ) { fputs ( '}', stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( s == NULL ) { fputs ( '}', stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '}' == end ) { fputs ( '}', stream ) ; ptr += 2 ; } else { char * end ; char keepit ; if ( end ) { strchr ( ptr, '}' ) ; ptr += 2 ; if ( end!= NULL ) { fputs ( '}', stream ) ; ptr += 2 ; } else { s = strchr ( ptr, '}' ) ; ptr += 2 ; if ( end!= NULL ) { fputs ( '}', stream ) ; ptr += 2 ; } else { s ++ ; } } } } ptr = s ; <vul-start> ; break ; case VAR_SECURE_SECURE_SECURE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl, CURLINFO_SECURE_SECURE_URL, & stringp ) ) && stringp ) fputs ( stringp, stream ) ; break ; case VAR_SECURE_SECURE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl, CURLINFO_SECURE_URL, & stringp ) ) && stringp ) fputs ( stringp, stream ) ; break ; case VAR_SECURE_SECURE_SECURE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl, CURLINFO_SECURE_URL, & stringp ) ) && stringp ) fputs ( stringp, stream ) ; break ; case VAR_SECURE_SECURE_SECURE_URL : if ( CURLE_OK == curl_easy_getinfo ( curl, CURLINFO_SECURE_URL, & stringp ) ) && stringp ) f"
  },
  {
    "id": 585,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( in ) <vul-end> dev -> in_pipe <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; <vul-end> if ( iso_in\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> tmp ; } dev -> in_pipe = usb_rcvbulkpipe ( udev, in -> desc. bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; dev -> out_pipe = usb_sndbulkpipe ( udev, out -> desc. bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> iso_out = & iso_out -> desc ; } else { dev -> iso_in = NULL ; dev -> out_iso_pipe = usb_sndisocpipe ( udev, iso_in -> desc. bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; <vul-end> if ( iso_out\n"
  },
  {
    "id": 586,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , \"%d bytes left\\\\n\" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , \"chunk too big\\\\n\" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , \"png: tag=%c%c%c%c length=%u\\\\n\" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >>",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> , y ; av_assert0 ( s -> bit_depth > 1 ) ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, y ; if (! s -> width ||! s -> height ) goto fail ;\n"
  },
  {
    "id": 587,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> ; if ( ! code <vul-end> || code == <vul-start> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> code == KRB5_PREAUTH_FAILED || code == KRB5_PREAUTH_FAILED_NO_CERT\n"
  },
  {
    "id": 588,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> void jslTokenAsString ( int token , char * str , size_t len ) { <vul-end> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <vul-start> case LEX_EOF : strncpy ( str , \"EOF\" , len ) ; return ; <vul-end> <vul-start> case LEX_ID : strncpy ( str , \"ID\" , len ) ; return ; <vul-end> <vul-start> case LEX_INT : strncpy ( str , \"INT\" , len ) ; return ; <vul-end> <vul-start> case LEX_FLOAT : strncpy ( str , \"FLOAT\" , len ) ; return ; <vul-end> <vul-start> case LEX_STR : strncpy ( str , \"STRING\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_STR : strncpy ( str , \"UNFINISHED STRING\" , len ) ; return ; <vul-end> <vul-start> case LEX_TEMPLATE_LITERAL : strncpy ( str , \"TEMPLATE LITERAL\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , \"UNFINISHED TEMPLATE LITERAL\" , len ) ; return ; <vul-end> <vul-start> case LEX_REGEX : strncpy ( str , \"REGEX\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_REGEX : strncpy ( str , \"UNFINISHED REGEX\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_COMMENT : strncpy ( str , \"UNFINISHED COMMENT\" , len ) ; return ; <vul-end> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> len ) { assert ( len > 28 ) ; <vul-start> case LEX_EOF : strcpy <vul-end> ( str , <vul-start> str , \"EOF\" <vul-end> ) ; return <vul-start> case LEX_ID : strcpy <vul-end> ( str , <vul-start> str , \"ID\" <vul-end> ) ; return <vul-start> case LEX_INT : strcpy <vul-end> ( str , <vul-start> str , \"INT\" <vul-end> ) ; return <vul-start> case LEX_FLOAT : strcpy <vul-end> ( str , <vul-start> str , \"FLOAT\" <vul-end> ) ; return <vul-start> case LEX_STR : strcpy <vul-end> ( str , <vul-start> str , \"STRING\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_STR : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED STRING\" <vul-end> ) ; return <vul-start> case LEX_TEMPLATE_LITERAL : strcpy <vul-end> ( str , <vul-start> str , \"TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_REGEX : strcpy <vul-end> ( str , <vul-start> str , \"REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_REGEX : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_COMMENT : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED COMMENT\" <vul-end> ) ; return <vul-start> 0 ) ; strcpy <vul-end> ( str , <vul-start> [ p ] <vul-end> ) ; return <vul-start> return ; } <vul-end> espruino_snprintf ( str\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, size_t len, jsl_buf * buf, size_t offset, size_t length <vul-start> case LEX_EOF : espruino_snprintf <vul-end> ( str, <vul-start> str, \"EOF\", offset, length <vul-end> ) ; return <vul-start> case LEX_ID : espruino_snprintf <vul-end> ( str, <vul-start> str, \"ID\", offset, length <vul-end> ) ; return <vul-start> case LEX_INT : espruino_snprintf <vul-end> ( str, <vul-start> str, \"INT\", offset, length <vul-end> ) ; return <vul-start> case LEX_FLOAT : espruino_snprintf <vul-end> ( str, <vul-start> str, \"FLOAT\", offset, length <vul-end> ) ; return <vul-start> case LEX_STR : espruino_snprintf <vul-end> ( str, <vul-start> str, \"STRING\", offset, length <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_STR : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED STRING\", offset <vul-end> ) ; return <vul-start> case LEX_TEMPLATE_LITERAL : espruino_snprintf <vul-end> ( str, <vul-start> str, \"TEMPLATE LITERAL\", offset <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED TEMPLATE LITERAL\", offset <vul-end> ) ; return <vul-start> case LEX_REGEX : espruino_snprintf <vul-end> ( str, <vul-start> str, \"REGEX\", offset <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_REGEX : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED REGEX\", offset <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_COMMENT : espruino_snprintf <vul-end> ( str,\n"
  },
  {
    "id": 589,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <vul-start> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <vul-end> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\\\n\" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , \"%s: Cannot handle tiled configuration w/bias image\\\\n\" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( void ) TIFFGetFieldDefaulted <vul-end> ( in ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int bychunk ; if ( samplesperpixel > 1 ) { fprintf ( stderr, \"%s: Invalid samplesperpixel value\\\\n\", TIFFFileName ( in ) ) ; return ( NULL ) ; }\n"
  },
  {
    "id": 590,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <vul-start> return SET_IVD_FATAL_ERROR ( e_error ) ; <vul-end> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <vul-end> ; } ps_dec\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = 0 ; ps_dec -> u2_vertical_size = 0 ; return IMPEG2D_FRM_HDR_DECODE_ERR ; }\n"
  },
  {
    "id": 591,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <vul-start> if ( ! offset ) { <vul-end> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , \"Modification of ArrayObject during sorting is prohibited\" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , \"Undefined index: %s\" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , \"Undefined index: %s\" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval )",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( ! offset || ! ht\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> (! offset ||! ht\n"
  },
  {
    "id": 592,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * create_principal_2_svc ( cprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , service_name ; <vul-end> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( \"kadm5_create_principal\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_principal ( ( void * ) handle , & arg -> rec , arg -> mask , arg -> passwd ) ; if ( ret .",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 593,
    "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto out_free_orig ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto out_free_orig ; } sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg (",
    "golden_answers": [
      "CWE-19 Fixed Code Lines are: <vul-start> = ext4_xattr_create_cache ( <vul-end> ) ; if <vul-start> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }\n"
    ],
    "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ext4_mballoc_ready ) { if ( ext4_has_feature_encryption ( sb ) ) { <vul-start> goto failed_mount_wq ; }\n"
  },
  {
    "id": 594,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <vul-start> sax -> sax25_family = AF_NETROM ; <vul-end> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { memset ( sax, 0, msg -> msg_namelen ) ;\n"
  },
  {
    "id": 595,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , \"early EOF\" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <vul-start> error = 0 ; <vul-end> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , \"report-status: Error reported: %s\" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p ->",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> error = 0 <vul-end> ; switch (\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> line_end ) ; if ( pkt == NULL ) continue ; error = 0 <vul-end> ; switch (\n"
  },
  {
    "id": 596,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_int32 now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; <vul-start> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <vul-end> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; <vul-start> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <vul-end> return KADM5_BAD_MASK ; <vul-start> if ( ( mask & ~ ALL_PRINC_MASK ) ) <vul-end> <vul-start> return KADM5_BAD_MASK ; <vul-end> if ( entry == NULL ) return EINVAL ; ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( entry == NULL ) return EINVAL ; if ( <vul-start> KADM5_POLICY ) && entry -> policy == NULL <vul-end> ) return KADM5_BAD_MASK <vul-start> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <vul-start> ) return KADM5_BAD_MASK <vul-end> ; ret =\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( mask & KADM5_MOD_TIME ) { if ( entry -> n_key_data == 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data == 1 ) return KADM5_BAD_MASK ; } if ( <vul-start> ( mask & <vul-end> KADM5_POLICY_CLR ) ) <vul-start> ; if ( mask & ~ ALL_PRINC_MASK ) return KADM5_BAD_MASK ; if ( <vul-start> & ~ ALL_PRINC_MASK ) return KADM5_BAD_MASK ; if ( mask & ~ ALL_TL_DATA\n"
  },
  {
    "id": 597,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadFAXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> storage_class = PseudoClass ; if ( image -> columns == 0 ) image -> columns = 2592 ; if ( image -> rows == 0 ) image -> rows = 3508 ; image -> depth = 8 ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, \"UnexpectedEndOfFile\" ) ;\n"
  },
  {
    "id": 598,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <vul-end> { hp_host_info_t __user * uarg = ( void __user * ) arg ; <vul-start> MPT_ADAPTER * ioc ; <vul-end> struct pci_dev * pdev ; char * pbuf = NULL ; dma_addr_t buf_dma ; hp_host_info_t karg ; CONFIGPARMS cfg ; <vul-start> ConfigPageHeader_t hdr ; <vul-end> int iocnum ; int rc , cim_rev ; ToolboxIstwiReadWriteRequest_t * IstwiRWRequest ; MPT_FRAME_HDR * mf = NULL ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - EFAULT ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \" \"Unable to read in hp_host_info struct @ %p\\\\n\" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <vul-start> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <vul-end> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\\\n\" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <vul-start> ) arg ; <vul-end> struct pci_dev * <vul-start> ; ConfigPageHeader_t hdr <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> dctlprintk ( ioc\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc, <vul-start> ) arg ; <vul-end> struct pci_dev * <vul-start> ; ConfigPageHeader_t hdr <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> dctlprintk ( ioc\n"
  },
  {
    "id": 599,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <vul-end> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
  },
  {
    "id": 600,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , \"RSDS\" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( \"Warning: Cannot read PE debug info\\\\n\" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , \"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( \"Truncated NB10 entry, not enough data to parse\\\\n\" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <vul-end> ; init_cv_nb10_header ( <vul-start> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <vul-start> 1 ) ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { SDebugInfo_t <vul-end> nb10_hdr ; init_cv_nb10_header <vul-start> guidstr ), \"%08x%08x\" <vul-end>, nb10_hdr. <vul-start> nb10_hdr. age, nb10_hdr. file_name\n"
  },
  {
    "id": 601,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , \"test%u.bson\" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( \"codewscope.bson\" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( \"empty_key.bson\" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( \"overflow2.bson\" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ; VALIDATE_TEST ( \"trailingnull.bson\" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ; VALIDATE_TEST ( \"dollarquery.bson\" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , \"keys cannot begin with \\\\\"$\\\\\": \\\\\"$query\\\\\"\" ) ; VALIDATE_TEST ( \"dotquery.bson\" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> \"corrupt BSON\" ) ; VALIDATE_TEST ( \"test59.bson\" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> \"corrupt BSON\" ) ; VALIDATE_TEST ( \"test55.bson\", BSON_VALIDATE_NONE, 12, BSON_VALIDATE_NONE, \"corrupt BSON\" ) ;\n"
  },
  {
    "id": 602,
    "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , \"/usr/bin/zsh\" ) == 0 || strcmp ( cfg . shell , \"/bin/zsh\" ) == 0 ) ) { if ( asprintf ( & fname , \"%s/.zshrc\" , homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <vul-start> if ( stat ( \"/etc/skel/.zshrc\" , & s ) == 0 ) { <vul-end> <vul-start> copy_file ( \"/etc/skel/.zshrc\" , fname , u , g , 0644 ) ; <vul-end> fs_logger ( \"clone /etc/skel/.zshrc\" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( \"touch\" , fname ) ; } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , \"/bin/csh\" ) == 0 ) { if ( asprintf ( & fname , \"%s/.cshrc\" , homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <vul-start> if ( stat ( \"/etc/skel/.cshrc\" , & s ) == 0 ) { <vul-end> <vul-start> copy_file ( \"/etc/skel/.cshrc\" , fname , u , g , 0644 ) ; <vul-end> fs_logger ( \"clone /etc/skel/.cshrc\" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( \"touch\" , fname ) ;",
    "golden_answers": [
      "CWE-269 Fixed Code Lines are: <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.zshrc\" , <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.cshrc\" , <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.bashrc\" ,\n"
    ],
    "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ; if ( is_copy_file ( fname, u, g, 0644 ) ) { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } else { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } free ( fname ) ; } else if (! arg_shell_none && strcmp ( cfg. shell, \"/bin/csh\" ) == 0 ) { if ( asprintf ( & fname, \"%s/.cshrc\", homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( <vul-start> 0 ) { if ( is_copy_file ( fname, u, g, 0644 ) ) { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } else { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname, \"%s/.bashrc\", homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname, & s ) == 0 ) { <vul-start> 0 ) { if ( is_copy_file ( fname, u, g, 0644 ) ) { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } free ( fname ) ; } else { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname, \"%s/.bashrc\", homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname, & s ) == 0 ) { <vul-start> 0 ) { if ( is_copy_file ( fname, u, g, 0644 ) ) { touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; } free ( fname ) ;"
  },
  {
    "id": 603,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) { rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; const char * fn = rpmfilesFN ( fi , ix ) ; struct stat sb ; rpmVerifyAttrs vfy = RPMVERIFY_NONE ; switch ( rpmfilesFState ( fi , ix ) ) { case RPMFILE_STATE_NETSHARED : case RPMFILE_STATE_NOTINSTALLED : goto exit ; break ; case RPMFILE_STATE_REPLACED : flags = RPMVERIFY_LSTATFAIL ; break ; case RPMFILE_STATE_WRONGCOLOR : flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; break ; case RPMFILE_STATE_NORMAL : case RPMFILE_STATE_MISSING : break ; } if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } <vul-start> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <vul-end> vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } if ( S_ISLNK ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_MODE ) ; else flags &= ~ ( RPMVERIFY_LINKTO ) ; if ( ! S_ISREG ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; if ( fileAttrs & RPMFILE_GHOST ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; if ( flags & RPMVERIFY_FILEDIGEST ) { const unsigned",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <vul-end> } if (\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> exit ; } flags |= RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_FAILURES ;\n"
  },
  {
    "id": 604,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { <vul-start> asdl_seq * body ; <vul-end> if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Module\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"Module field \\\\\"body\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , \"Module field \\\\\"body\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( body ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> asdl_seq * body ; asdl_seq * type_ignores <vul-start> ) ; } if ( _PyObject_LookupAttrId <vul-end> ( obj , <vul-start> ( obj , & PyId_type_ignores <vul-end> , & tmp <vul-start> ( PyExc_TypeError , \"required field \\\\\"type_ignores\\\\\" missing from Module\" <vul-end> ) ; return <vul-start> ( PyExc_TypeError , \"Module field \\\\\"type_ignores\\\\\" must be a list, not a %.200s\" <vul-end> , tmp -> <vul-start> tmp ) ; type_ignores <vul-end> = _Py_asdl_seq_new ( <vul-start> ; if ( type_ignores <vul-end> == NULL ) <vul-start> ++ ) { type_ignore_ty <vul-end> val ; res <vul-start> ; res = obj2ast_type_ignore <vul-end> ( PyList_GET_ITEM ( <vul-start> ( PyExc_RuntimeError , \"Module field \\\\\"type_ignores\\\\\" changed size during iteration\" <vul-end> ) ; goto <vul-start> } asdl_seq_SET ( type_ignores <vul-end> , i , <vul-start> * out = Module ( body , type_ignores <vul-end> , arena ) <vul-start> PyObject * ) Interactive_type <vul-end> ) ; if <vul-start> isinstance ) { asdl_seq * <vul-end> body ; if <vul-start> ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Interactive\" <vul-end> ) ; return <vul-start> ( PyExc_TypeError , \"Interactive field \\\\\"body\\\\\" must be a list, not a %.200s\" <vul-end> , tmp -> <vul-start> ( PyExc_RuntimeError , \"Interactive field \\\\\"body\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Expression\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"argtypes\\\\\" missing from FunctionType\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"FunctionType field \\\\\"argtypes\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Py_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , \"FunctionType field \\\\\"argtypes\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( argtypes , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"returns\\\\\" missing from FunctionType\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Suite\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"Suite field \\\\\"body\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> asdl_seq * body = NULL <vul-start> ( PyExc_TypeError, \"required field \\\\\"body\\\\\" missing from Module\" <vul-end> ) ; return <vul-start> ( PyExc_TypeError, \"Interactive field \\\\\"body\\\\\" missing from Interactive\" <vul-end> ) ; return <vul-start> ; body = _Py_asdl_seq_new ( len, arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp, i ), & val, arena ) ; if ( res!= 0 ) goto failed ; if ( len!= PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError, \"required field \\\\\"body\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( body, i, val ) ; } * out = Interactive ( body, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { int res ; res = obj2ast_seq_new ( len, arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp, i ), & val, arena ) ; if ( res!= 0 ) goto failed ; if ( len!= PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError, \"required field \\\\\"body\\\\\" missing size during iteration\" ) ; goto failed ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_RuntimeError, \"required field \\\\\"body\\\\\" missing size during iteration\" ) ; goto failed ; } else { int res ; res = obj2ast_expr ( tmp, & body, arena ) ; if ( res!= 0 ) goto failed ; if ( len!= PyList_GET_SIZE ( tmp ) ) { <vul-end> PyErr_SetString ( PyExc_RuntimeError <vul-start> ( PyExc_RuntimeError,"
  },
  {
    "id": 605,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , \"CLIENT_ERROR bad command line format\" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } <vul-start> it = item_get ( key , nkey , c , DO_UPDATE ) ; <vul-end> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes ,",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> } it = limited_get <vul-end> ( key , <vul-start> nkey , c <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> DO_UPDATE ) ; if ( it == NULL ) { STATS_LOCK ( ) ; stats. malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; return ; }\n"
  },
  {
    "id": 606,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; <vul-start> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <vul-end> if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , \"%s, ethertype %s (0x%04x), length %u: \" , tok2str ( chdlc_cast_values , \"0x%02x\" , p [ 0 ] ) , tok2str ( ethertype_values , \"Unknown\" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : <vul-start> if ( * ( p + 1 ) == 0x81 || <vul-end> * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"unknown CHDLC protocol (0x%04x)\" , proto ) )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <vul-start> : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <vul-start> CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , \"[|chdlc]\" ) ) ; return ndo -> ndo_snapend - bp ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u_int proto ; if ( length < CHDL_HDRLEN ) goto trunc ; <vul-start> case ETHERTYPE_ISO : ND_TCHECK_16BITS ( & p [ 2 ] ) ;\n"
  },
  {
    "id": 607,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 NOEXPORT char * parse_service_option ( CMD cmd , SERVICE_OPTIONS * * section_ptr , char * opt , char * arg ) { SERVICE_OPTIONS * section ; int endpoints = 0 ; # ifndef USE_WIN32 struct group * gr ; struct passwd * pw ; # endif section = section_ptr ? * section_ptr : NULL ; if ( cmd == CMD_SET_DEFAULTS || cmd == CMD_SET_COPY ) { section -> ref = 1 ; <vul-start> } else if ( cmd == CMD_FREE ) { <vul-end> <vul-start> if ( section == & service_options || section == & new_service_options ) <vul-end> <vul-start> s_log ( LOG_DEBUG , \"Deallocating section defaults\" ) ; <vul-end> else s_log ( LOG_DEBUG , \"Deallocating section [%s]\" , section -> servname ) ; } else if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , \" \" ) ; s_log ( LOG_NOTICE , \"Service-level options:\" ) ; } switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; name_list_dup ( & section -> local_addr . names , new_service_options . local_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> local_addr . names ) ; str_free ( section -> local_addr . addr ) ; str_free ( section -> local_fd ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , \"accept\" ) ) break ; section -> option . accept =",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start> = 1 ; if ( section == & service_options ) s_log ( LOG_ERR , \"INTERNAL ERROR: Initializing deployed section defaults\" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , \"Initializing inetd mode configuration\" ) ; else s_log ( LOG_INFO , \"Initializing service [%s]\" , section -> servname ) ; <vul-start> == & service_options ) s_log ( LOG_DEBUG , \"Deallocating deployed section defaults\" ) ; else if ( <vul-end> section == & <vul-start> ( LOG_DEBUG , \"Deallocating temporary section defaults\" <vul-end> ) ; else <vul-start> break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , \"securityLevel\" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return \"Illegal security level\" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , \"%-22s = %d\" , \"securityLevel\" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , \"%-22s = set the security level\" , \"securityLevel\" ) ; break ; } # endif <vul-start> \"verify\" ) ; <vul-end> break ; } <vul-start> == & service_options || section == & new_service_options\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE, \" \" ) ; s_log ( LOG_NOTICE, \"Service-level options:\" ) ; } else if ( cmd == <vul-start> CMD_FREE ) { <vul-end> s_log ( LOG_DEBUG <vul-start> ( LOG_DEBUG, \"Deallocating section defaults\" ) ; else s_log ( LOG_DEBUG, \"Deallocating section [%s]\", section -> servname <vul-end> ) ; } <vul-start> } else { <vul-end> s_log ( LOG_NOTICE <vul-start> ( LOG_NOTICE, \" \" <vul-end> ) ; }\n"
  },
  {
    "id": 608,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int btrfs_scrub_dev ( struct btrfs_fs_info * fs_info , u64 devid , u64 start , u64 end , struct btrfs_scrub_progress * progress , int readonly , int is_dev_replace ) { struct scrub_ctx * sctx ; int ret ; struct btrfs_device * dev ; unsigned int nofs_flag ; if ( btrfs_fs_closing ( fs_info ) ) return - EINVAL ; if ( fs_info -> nodesize > BTRFS_STRIPE_LEN ) { btrfs_err ( fs_info , \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\" , fs_info -> nodesize , BTRFS_STRIPE_LEN ) ; return - EINVAL ; } if ( fs_info -> sectorsize != PAGE_SIZE ) { btrfs_err_rl ( fs_info , \"scrub: size assumption sectorsize != PAGE_SIZE (%d != %lu) fails\" , fs_info -> sectorsize , PAGE_SIZE ) ; return - EINVAL ; } if ( fs_info -> nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info -> sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ) { btrfs_err ( fs_info , \"scrub: size assumption nodesize and sectorsize <= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\" , fs_info -> nodesize , SCRUB_MAX_PAGES_PER_BLOCK , fs_info -> sectorsize , SCRUB_MAX_PAGES_PER_BLOCK ) ; return - EINVAL ; } sctx = scrub_setup_ctx ( fs_info , is_dev_replace ) ; if ( IS_ERR ( sctx ) ) return PTR_ERR ( sctx ) ; mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ; <vul-start> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <vul-end> if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> NULL , NULL , true\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NULL, NULL, true\n"
  },
  {
    "id": 609,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 <vul-start> int sctp_verify_asconf ( const struct sctp_association * asoc , <vul-end> <vul-start> struct sctp_paramhdr * param_hdr , void * chunk_end , <vul-end> struct sctp_paramhdr * * errp ) { <vul-start> sctp_addip_param_t * asconf_param ; <vul-end> union sctp_params param ; <vul-start> int length , plen ; <vul-end> <vul-start> param . v = ( sctp_paramhdr_t * ) param_hdr ; <vul-end> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start>       bool <vul-end> sctp_verify_asconf ( const <vul-start> asoc , struct sctp_chunk * chunk , bool addr_param_needed <vul-end> , struct sctp_paramhdr <vul-start> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <vul-end> ; union sctp_params <vul-start> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <vul-end> param . v <vul-start> param . v != chunk -> chunk_end ) return false ; return true <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> asoc, struct sctp_chunkhdr * chunk, const <vul-start>, void * param_end_se, const <vul-end> struct sctp_paramhdr * <vul-start> errp ) { sctp_addip_param_t * addip = ( sctp_addip_param_t * ) chunk ; const sctp_paramhdr_t * param_hdr = ( sctp_paramhdr_t * ) param_hdr ; int length, plen ; param. v = ( sctp_paramhdr_t * ) param_hdr ; while ( param. v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param. p -> length ) ; * errp = param. p ; switch ( param. p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : addip -> param_hdr. length = sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length!= sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; default : break ; } } if ( param. p!= chunk_end ) return 0 ; addip -> param_hdr. v = ( sctp_paramhdr_t * ) param_hdr ; <vul-end> param. v <vul-start>. v = chunk_end - sizeof ( sctp_paramhdr_t ) ; if ( addip -> param_hdr. length < sizeof ( sctp_addip_param_t ) || param. v > chunk_end - sizeof ( sctp_paramhdr_t ) ) return 0 ; addip -> param_hdr. v += WORD_ROUND ( param. p -> param_hdr. length ) ; * errp = param. p ; if ( param. v!= chunk_end ) return 0 ; if ( addip -> param_hdr. v!= chunk_end ) return 0 ; if ( param. v!= chunk_end ) return 0 ; if ( addip -> param_hdr. v!="
  },
  {
    "id": 610,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ; <vul-start> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <vul-end> { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) { <vul-start> close ( fd ) ; <vul-end> return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , \"%s\" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <vul-start> unlink ( hdl -> c_path ) ; <vul-end> close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) { <vul-start> unlink ( hdl -> c_path ) ; <vul-end> close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * )",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <vul-start> ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <vul-end> ; } snprintf <vul-start> 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <vul-end> } if ( <vul-start> 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <vul-end> ; } memset <vul-start> 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <vul-end> ; } hdl <vul-start> = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ( fd = TEMP_FAILURE_RETRY ( <vul-start>, 0 ) ) <vul-start> 0 ) { TEMP_FAILURE_RETRY ( <vul-start> hdl -> c_path ) <vul-start> 0 ) { TEMP_FAILURE_RETRY ( <vul-start> hdl -> c_path ) <vul-start> 0 ) { TEMP_FAILURE_RETRY ( <vul-start> hdl -> c_path )\n"
  },
  {
    "id": 611,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int luaG_traceexec ( lua_State * L , const Instruction * pc ) { CallInfo * ci = L -> ci ; lu_byte mask = L -> hookmask ; <vul-start> int counthook ; <vul-end> if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) { ci -> u . l . trap = 0 ; return 0 ; } pc ++ ; ci -> u . l . savedpc = pc ; counthook = ( -- L -> hookcount == 0 && ( mask & LUA_MASKCOUNT ) ) ; if ( counthook ) resethookcount ( L ) ; else if ( ! ( mask & LUA_MASKLINE ) ) return 1 ; if ( ci -> callstatus & CIST_HOOKYIELD ) { ci -> callstatus &= ~ CIST_HOOKYIELD ; return 1 ; } if ( ! isIT ( * ( ci -> u . l . savedpc - 1 ) ) ) L -> top = ci -> top ; if ( counthook ) luaD_hook ( L , LUA_HOOKCOUNT , - 1 , 0 , 0 ) ; if ( mask & LUA_MASKLINE ) { <vul-start> const Proto * p = ci_func ( ci ) -> p ; <vul-end> int npci = pcRel ( pc , p ) ; if ( npci == 0 || <vul-start> pc <= L -> oldpc || <vul-end> <vul-start> changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) { <vul-end> int newline = luaG_getfuncline ( p , npci ) ; luaD_hook ( L , LUA_HOOKLINE , newline , 0 , 0 ) ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> hookmask ; const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 <vul-end> ; if ( <vul-start> LUA_MASKLINE ) { <vul-end> int npci = <vul-start> || pc <= invpcRel ( oldpc , p ) <vul-end> || changedline ( <vul-start> ( p , oldpc <vul-end> , npci ) <vul-start> -> oldpc = npci <vul-end> ; } if\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; int counthook ; int hashook = 0 <vul-start> LUA_MASKLINE ) { int npci = pcRel ( pc, <vul-end> ci_func ( ci <vul-start> ) -> p <vul-end> ) ; if <vul-start> -> oldpc || ( hashook = ( pcRel ( L -> oldpc, p ), npci ) ) ) { hashook = 1 ; <vul-end> int newline = <vul-start> ) ; } if ( hashook ) hook = 0 ;\n"
  },
  {
    "id": 612,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void test_modules ( ) { assert_true_rule ( <vul-start> \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.one + 1 == tests.constants.two \\\\\\n }\" , <vul-end> NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.empty == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.empty() == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[1].i == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 or true \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[0] == 0 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[1] == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,2) == 3 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.one + 1 == tests.constants.two \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.empty == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.empty() == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[1].i == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[0].i == 1 or true \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[0] == 0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[1] == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2) == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2,3) == 6 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) == tests.foobar(1) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) != tests.foobar(2) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.struct_array[0].i == 1 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.isum(1,1) == 3 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"foo\\\\\") == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"bar\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/i,\\\\\"FOO\\\\\\\\nBAR\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/is,\\\\\"FOO\\\\\\\\nBAR\\\\\") == 7\\\\\\n      }\" <vul-end> , NULL )\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,1) == 3 \\\\\\n }\" <vul-start> assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,1) == 3 \\\\\\n }\", NULL ) ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-start> assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition"
  },
  {
    "id": 613,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <vul-end> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; #",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
  },
  {
    "id": 614,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ; <vul-start> u64 start = offset >> PAGE_CACHE_SHIFT ; <vul-end> unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ; <vul-start> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <vul-end> pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && <vul-start> ! ( mode & FALLOC_FL_KEEP_SIZE ) )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int error ; unsigned int nr_blks ; sector_t lblock <vul-end> = offset >> <vul-start> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <vul-end> ( offset + <vul-start> offset + len <vul-end> > inode -> <vul-start> FALLOC_FL_KEEP_SIZE ) ) <vul-end> i_size_write ( inode <vul-start> , offset + len ) ; <vul-end> mark_inode_dirty ( inode <vul-start> mark_inode_dirty ( inode <vul-end> ) ; out <vul-start> ; out : brelse ( dibh ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int error ; pgoff_t start = ( offset >> PAGE_CACHE_SHIFT ) <vul-end> ; unsigned int <vul-start> ~ PAGE_CACHE_MASK ; pgoff_t end = ( <vul-end> offset + len <vul-start> len - 1 ) >> PAGE_CACHE_SHIFT ; bool skip_pinned_pages = ( offset + len > inode -> i_sb -> s_iflags -> s_iflags & SB_I_NOEXEC ) <vul-end> ; pgoff_t curr <vul-start> FALLOC_FL_KEEP_SIZE ) ) skip_pinned_pages =! ( mode & FALLOC_FL_NO_PINS ) ; if ( skip_pinned_pages ) { i_size_write ( inode, offset + to ) ; } <vul-end> } unlock_page ( <vul-start> 0 ; } if (! skip_pinned_pages ) { i_size_write ( inode, offset + to ) ; } <vul-start> ; out : if (! skip_pinned_pages ) { i_size_write ( inode, offset + to ) ; }\n"
  },
  {
    "id": 615,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , p + offset + 3 , <vul-end> tim . length <vul-start> - 3 ) ; offset += <vul-end> tim . length <vul-start> length - 3 ; length -= <vul-end> tim . length <vul-start> - 3 ; <vul-end> if ( !\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -= 3 ; if ( length < 3 ) return 0 ; <vul-start>, p + <vul-end> ( tim. <vul-start> length - 3 <vul-end>, ( tim <vul-start> tim. length <vul-end> ) ) ; <vul-start> ; length -= 3 ; memcpy ( & tim. bitmap, p + offset, ( tim. length - 3 ) ) ; offset += tim. length - 3 ; length -= <vul-start> length - 3 <vul-end> ; if (\n"
  },
  {
    "id": 616,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <vul-start> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; x86_pmu. <vul-end> er_flags |= ERF_HAS_RSP_1 <vul-start> ; x86_pmu. <vul-end> er_flags |= ERF_NO_HT_SHARING\n"
  },
  {
    "id": 617,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; <vul-start> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <vul-end> ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec ->",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, * ps_cur_poc ; ps_dec -> ps_dpb_mgr = NULL ; ps_dec -> ps_dpb_mgr_env. pv_codec_handle = ps_dec\n"
  },
  {
    "id": 618,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , \"DSD \" , 4 ) ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( \"%s is not a valid .DFF file (by total size)!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"file header indicated length = %lld\" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4096 ) { error_line ( \"%s is not a valid.DFF file!\", infilename ) ; return WAVPACK_SOFT_ERROR ; } buff\n"
  },
  {
    "id": 619,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = -",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <vul-start> ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> goto out_unlock ; WARN_ON (! ( vma -> vm_flags & VM_MAYWRITE ) ) ; <vul-start>. ctx && ( <vul-start> ctx!= ctx ) || (! ( vma -> vm_flags & VM_MAYWRITE ) )\n"
  },
  {
    "id": 620,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv .",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> >> 3 ; ( void ) mvcost ; <vul-start> this_offset , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> 8 ; # else ( void ) search_param ; # <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> >> 3 ; clamp_mv <vul-end> ( ref_mv, <vul-start>, this_offset, in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start>. col ; clamp_mv <vul-end> ( ref_mv, <vul-start>, this_offset, in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start>. col ; clamp_mv <vul-end> ( ref_mv, <vul-start>, this_offset, in_what_stride <vul-end> ) ; CHECK_BETTER\n"
  },
  {
    "id": 621,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void exif_mnote_data_olympus_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataOlympus * n = ( ExifMnoteDataOlympus * ) en ; ExifShort c ; size_t i , tcount , o , o2 , datao = 6 , base = 0 ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataOlympus\" , \"Short MakerNote\" ) ; return ; } o2 = 6 + n -> offset ; if ( CHECKOVERFLOW ( o2 , buf_size , 10 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataOlympus\" , \"Short MakerNote\" ) ; return ; } n -> version = exif_mnote_data_olympus_identify_variant ( buf + o2 , buf_size - o2 ) ; switch ( n -> version ) { case olympusV1 : case sanyoV1 : case epsonV1 : exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteDataOlympus\" , \"Parsing Olympus/Sanyo/Epson maker note v1...\" ) ; if ( buf [ o2 + 6 ] == 1 ) n -> order = EXIF_BYTE_ORDER_INTEL ; else if ( buf [ o2 + 6 + 1 ] == 1 ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ; o2 += 8 ; c = exif_get_short ( buf + o2 , n -> order ) ; if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) { if ( n -> order == EXIF_BYTE_ORDER_INTEL ) { n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> order = EXIF_BYTE_ORDER_INTEL ; } } break ; case olympusV2",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entry, 0, sizeof ( MnoteOlympusEntry ) ) ;\n"
  },
  {
    "id": 622,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , buffer , t2p -> tiff_datasize ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, & bufferoffset <vul-end>, i,\n"
  },
  {
    "id": 623,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <vul-end> vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) <vul-start> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <vul-end> if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <vul-start> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <vul-end> for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) <vul-start> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <vul-end> } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <vul-start> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <vul-end> for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) <vul-start> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <vul-end> ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <vul-end> ( w , <vul-start> >= ALLOW_32X32 ) vpx_write_bit <vul-end> ( w , <vul-start> { tx_counts_to_branch_counts_8x8 ( counts -> <vul-end> tx . p8x8 <vul-start> cm -> fc -> <vul-end> tx_probs . p8x8 <vul-start> { tx_counts_to_branch_counts_16x16 ( counts -> <vul-end> tx . p16x16 <vul-start> cm -> fc -> <vul-end> tx_probs . p16x16 <vul-start> { tx_counts_to_branch_counts_32x32 ( counts -> <vul-end> tx . p32x32 <vul-start> cm -> fc -> <vul-end> tx_probs . p32x32\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cm, vpx_writer * w, vpx_counts_t * counts <vul-end> ) { vpx_write_literal <vul-start> >= ALLOW_32X32 ) vpx_write_bit <vul-end> ( w, <vul-start> == TX_MODE_SELECT ) ; counts = * counts <vul-start> cm -> fc -> <vul-end> tx_probs. p8x8 <vul-start> cm -> fc -> <vul-end> tx_probs. p8x8 <vul-start> cm -> fc -> <vul-end> tx_probs. p16x16 <vul-start> cm -> fc -> <vul-end> tx_probs. p32x16\n"
  },
  {
    "id": 624,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int netlink_dump ( struct sock * sk ) { struct netlink_sock * nlk = nlk_sk ( sk ) ; struct netlink_callback * cb ; struct sk_buff * skb = NULL ; struct nlmsghdr * nlh ; <vul-start> int len , err = - ENOBUFS ; <vul-end> int alloc_min_size ; int alloc_size ; mutex_lock ( nlk -> cb_mutex ) ; if ( ! nlk -> cb_running ) { err = - EINVAL ; goto errout_skb ; } if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) goto errout_skb ; cb = & nlk -> cb ; alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; if ( alloc_min_size < nlk -> max_recvmsg_len ) { alloc_size = nlk -> max_recvmsg_len ; skb = alloc_skb ( alloc_size , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; } if ( ! skb ) { alloc_size = alloc_min_size ; skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; } if ( ! skb ) goto errout_skb ; skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; netlink_skb_set_owner_r ( skb , sk ) ; len = cb -> dump ( skb , cb ) ; if ( len > 0 ) { mutex_unlock ( nlk -> cb_mutex ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; return 0 ; } nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; if ( ! nlh ) goto",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> * nlh ; struct module * module ; <vul-start> = false ; module = cb -> module ; skb = cb -> skb ; <vul-start> ; module_put ( <vul-end> module ) ; <vul-start> ; consume_skb ( <vul-end> skb ) ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> * nlh ; struct module * module ; <vul-start> = false ; module = cb -> module ; <vul-start> cb_mutex ) ; consume_skb ( cb -> skb ) ; <vul-start> ; module_put ( <vul-end> module ) ; <vul-start> ; consume_skb ( <vul-end> skb ) ;\n"
  },
  {
    "id": 625,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( \"kadm5_chpass_principal\" , prime_arg , & client_name , &",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
  },
  {
    "id": 626,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <vul-start> DEFINE_WAKE_Q ( wake_q ) ; <vul-end> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked (",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ( wake_q ) ; if (! access_ok ( VERIFY_WRITE, uaddr1, sizeof ( key1 ) ) ) return - EFAULT\n"
  },
  {
    "id": 627,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; <vul-start> krb5_key_data * key_data ; <vul-end> if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; <vul-start> if ( key_data_in == NULL ) <vul-end> goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> krb5_key_data * key_data = NULL ; if ( n_key_data < <vul-end> 0 ) return <vul-start> ; if ( key_data <vul-end> == NULL ) <vul-start> = 0 ; ret [ i ] != NULL <vul-end> ; i ++ <vul-start> i ++ ) <vul-end> free ( ret\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> krb5_key_data * key_data ; int err_reg <vul-start> key_data_in == NULL || key_data [ i ]. key_data_kvno!= currkvno <vul-start> i ++ ) { err = krb5_set_error_string ( err, ret [ i ] -> bv_val, ret [ i ] -> bv_len ) ; if ( err!= 0 ) goto cleanup ; <vul-start> i ++ ) { err = krb5_set_error_string ( err, ret [ i ] -> bv_val, ret [ i ] -> bv_len ) ; if ( err!= 0 ) goto cleanup ; <vul-start> ]!= NULL ) free ( ret [ i ] ) ; free ( ret [ i ] ) ; } } <vul-end> free ( ret\n"
  },
  {
    "id": 628,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , \"{\\\\\"id\\\\\": %d, \\\\\"method\\\\\": \\\\\"mining.subscribe\\\\\", \\\\\"params\\\\\": [\\\\\"%s\\\\\"]}\" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , \"{\\\\\"id\\\\\": %d, \\\\\"method\\\\\": \\\\\"mining.subscribe\\\\\", \\\\\"params\\\\\": []}\" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , \"Failed to send s in initiate_stratum\" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , \"Timed out waiting for response in initiate_stratum\" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , \"JSON decode failed(%d): %s\" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , \"result\" ) ; err_val = json_object_get ( val , \"error\" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( n2size < 1 ) <vul-end> { applog (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( n2size < 1 ) <vul-end> { applog (\n"
  },
  {
    "id": 629,
    "question": "CWE-354 Code Input Vulnerable Code Is: CWE-354 void recovery_cipher_init ( bool passphrase_protection , bool pin_protection , const char * language , const char * label , bool _enforce_wordlist , uint32_t _auto_lock_delay_ms , uint32_t _u2f_counter , bool _dry_run ) { enforce_wordlist = _enforce_wordlist ; dry_run = _dry_run ; if ( ! dry_run ) { if ( pin_protection ) { if ( ! change_pin ( ) ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_ActionCancelled , \"PINs do not match\" ) ; layoutHome ( ) ; return ; } } else { storage_setPin ( \"\" ) ; } storage_setPassphraseProtected ( passphrase_protection ) ; storage_setLanguage ( language ) ; storage_setLabel ( label ) ; storage_setAutoLockDelayMs ( _auto_lock_delay_ms ) ; storage_setU2FCounter ( _u2f_counter ) ; } else if ( ! pin_protect ( \"Enter Your PIN\" ) ) { layoutHome ( ) ; return ; } if ( ! confirm ( ButtonRequestType_ButtonRequest_Other , dry_run ? \"Recovery Dry Run\" : \"Recovery\" , \"When entering your recovery seed, use the substitution cipher \" \"and check that each word shows up correctly on the screen.\" ) ) { fsm_sendFailure ( FailureType_Failure_ActionCancelled , \"Recovery cancelled\" ) ; if ( ! dry_run ) storage_reset ( ) ; layoutHome ( ) ; return ; } memset ( mnemonic , 0 , sizeof ( mnemonic ) / sizeof ( char ) ) ; awaiting_character = true ; <vul-start> next_character ( ) ; <vul-end> }",
    "golden_answers": [
      "CWE-354 Fixed Code Lines are: <vul-start> = true ; recovery_started = true ;\n"
    ],
    "generated_answer": "CWE-354 Fixed Code Lines are: <vul-start> = true ; recovery_started = true ;\n"
  },
  {
    "id": 630,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( \"%s unable to allocate buffer for packet.\" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) { <vul-start> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <vul-end> switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( \"%s unable to read from driver: %s\" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( \"%s end of file reached.\" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> btpan_cb . congest_packet ) <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> 1 , 0 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> 1, 0 ) <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start>. revents ) )\n"
  },
  {
    "id": 631,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { <vul-start> u_int16_t offset = 22 , buf_out_len = 0 ; <vul-end> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <vul-start> offset += 4 + len ; <vul-end> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <vul-start> if ( client_hash ) { <vul-end> <vul-start> offset += 4 ; <vul-end> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> client_hash ) { u_int32_t <vul-end> offset = 22 <vul-start> ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; #\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> offset = 22 ; u_int16_t buf_out_len = 0 ; if ( offset >= packet -> payload_packet_len ) goto invalid_payload <vul-start> ] ) ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> ] ) ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> client_hash ) { if ( offset >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> ] ) ; <vul-start> client_hash ) { if ( offset >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> ] ) ; <vul-start> client_hash ) { if ( offset >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> ] ) ; <vul-end> if ( offset <vul-start> client_hash ) { if ( offset >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> = ';' ; } else { <vul-start> += len ; } <vul-start> = ';' ; } <vul-start> += len ; } <vul-start> += len ; } else { <vul-start> = ';' ; } <vul-start> += len ; } <vul-start> += len ; } <vul-end> if ( offset\n"
  },
  {
    "id": 632,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <vul-start> pipe_buf_get ( ipipe , ibuf ) ; <vul-end> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> 1 ) ; if ( ! <vul-start> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <vul-end> obuf = opipe\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 1 ) ; if (! <vul-start>, ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <vul-end> obuf = opipe\n"
  },
  {
    "id": 633,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_bilinear_predict4x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 ; uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 ; <vul-start> uint32x2_t d28u32 , d29u32 , d30u32 ; <vul-end> uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 0 ) ; src_ptr += src_pixels_per_line ; d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 1 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 0 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 1 ) ; src_ptr += src_pixels_per_line ; d30u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d30u32 , 0 ) ; d28u8 = vreinterpret_u8_u32 ( d28u32 ) ; d29u8 = vreinterpret_u8_u32 ( d29u32 ) ; d30u8 = vreinterpret_u8_u32 ( d30u32 ) ; } else { d2u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d3u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d4u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d5u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <vul-end> d28u32 = vld1_lane_u32 <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> d29u32, d30u32 ; uint8x16_t q1u8, q2u8 <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset\n"
  },
  {
    "id": 634,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , \"%s - data bits = 5\\\\n\" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , \"%s - data bits = 6\\\\n\" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , \"%s - data bits = 7\\\\n\" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , \"%s - data bits = 8\\\\n\" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , \"%s -",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> ; } else { baud = min ( baud , 461550 ) ; <vul-start> baud ) ; }\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> ; } else { baud = min ( baud, edge_port -> baud_rate ) ; <vul-start> baud ) ; }\n"
  },
  {
    "id": 635,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <vul-start> long timeo ; <vul-end> lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ; long timeo ; msg -> msg_namelen = 0\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; long timeo ; msg -> msg_namelen = 0\n"
  },
  {
    "id": 636,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ; <vul-start> int bytes_returned , name_len ; <vul-end> __u16 params , byte_count ; cFYI ( 1 , \"In FindNext\" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; int bytes_returned ; unsigned int <vul-end> name_len ; __u16\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int bytes_returned <vul-end> ; __u16 params\n"
  },
  {
    "id": 637,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ; <vul-start> atomic_inc ( & sb -> s_active ) ; <vul-end> mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; br_write_unlock ( & vfsmount_lock ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ~ MNT_WRITE_HOLD ; mnt -> mnt. mnt_flags |= MNT_LOCK_NODEV ;\n"
  },
  {
    "id": 638,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int add_mibdir ( const char * dirname ) { <vul-start> FILE * ip ; <vul-end> const char * oldFile = File ; char * * filenames ; int count = 0 ; int filename_count , i ; <vul-start> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <vul-end> char * token ; char space ; char newline ; struct stat dir_stat , idx_stat ; char tmpstr [ 300 ] ; char tmpstr1 [ 300 ] ; # endif DEBUGMSGTL ( ( \"parse-mibs\" , \"Scanning directory %s\\\\n\" , dirname ) ) ; <vul-start> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <vul-end> token = netsnmp_mibindex_lookup ( dirname ) ; if ( token && stat ( token , & idx_stat ) == 0 && stat ( dirname , & dir_stat ) == 0 ) { if ( dir_stat . st_mtime < idx_stat . st_mtime ) { DEBUGMSGTL ( ( \"parse-mibs\" , \"The index is good\\\\n\" ) ) ; if ( ( ip = fopen ( token , \"r\" ) ) != NULL ) { fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ; while ( fscanf ( ip , \"%127s%c%299[^\\\\n]%c\" , token , & space , tmpstr , & newline ) == 4 ) { if ( space != ' ' || newline != '\\\\n' ) { snmp_log ( LOG_ERR , \"add_mibdir: strings scanned in from %s/%s \" \"are too large. count = %d\\\\n \" , dirname , \".index\" , count ) ; break ; } snprintf ( tmpstr1 , sizeof ( tmpstr1",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> dirname ) { <vul-end> const char * <vul-start> , i ; <vul-end> DEBUGMSGTL ( ( <vul-start> ) ) ; <vul-end> filename_count = scan_directory <vul-start> 0 ) { <vul-end> for ( i <vul-start> , '/' ) <vul-end> ) == 0 <vul-start> File = oldFile <vul-end> ; free (\n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> dirname ) { <vul-end> const char * <vul-start>, i ; <vul-end> DEBUGMSGTL ( ( <vul-start> ) ) ; <vul-end> token = netsnmp_mibindex_lookup <vul-start> 0 ) { <vul-end> for ( i <vul-start> ++ ) { char * p = <vul-end> strrchr ( filenames <vul-start>, '/' ) ; if ( p ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { p ++ ; } if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if ( * p == '.' ) { if ( * p == '.' ) p ++ ; } else if"
  },
  {
    "id": 639,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <vul-start> int just_opened = 0 ; <vul-end> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , \"No longer receiving playlist %d\\\\n\" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <vul-start> if ( ! v -> finished && <vul-end> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , \"Failed to reload playlist %d\\\\n\" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , \"skipping",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> ; int just_opened = 0 ; int reload_count <vul-start> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> just_opened = 0 ; int need_reload = 0 <vul-start> ; reload : need_reload = ( v -> finished || v -> started )? 1 : 0 ; <vul-start> ; if ( need_reload <vul-end> ) { if\n"
  },
  {
    "id": 640,
    "question": "CWE-862 Code Input Vulnerable Code Is: CWE-862 static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) { <vul-start> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <vul-end> bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , \"net\" ) ; if ( ofd < 0 ) { <vul-start> fprintf ( stderr , \"Failed opening network namespace path for \\'%d\\'.\" , getpid ( ) ) ; <vul-end> <vul-start> return - 1 ; <vul-end> } fd = lxc_preserve_ns ( pid , \"net\" ) ; if ( fd < 0 ) { <vul-start> fprintf ( stderr , \"Failed opening network namespace path for \\'%d\\'.\" , pid ) ; <vul-end> <vul-start> return - 1 ; <vul-end> } <vul-start> if ( setns ( fd , 0 ) < 0 ) { <vul-end> fprintf ( stderr , \"setns to container network namespace\\\\n\" ) ; goto out_err ; } <vul-start> close ( fd ) ; fd = - 1 ; <vul-end> if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; <vul-start> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <vul-end> fprintf ( stderr , \"failed to get netdev index\\\\n\" ) ; goto out_err ; } } <vul-start> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <vul-end> fprintf ( stderr , \"Error %d renaming netdev %s to %s in container\\\\n\" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) { <vul-start>",
    "golden_answers": [
      "CWE-862 Fixed Code Lines are: <vul-start> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <vul-end> = - 1 <vul-start> 1 , ret <vul-end> ; bool grab_newname <vul-start> 0 ) { usernic_error ( <vul-end> \"Failed opening network namespace path for \\'%d\\'.\" , getpid <vul-start> ) ; return fret <vul-end> ; } fd <vul-start> 0 ) { usernic_error ( <vul-end> \"Failed opening network namespace path for \\'%d\\'.\" , pid <vul-start> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( \"Failed to retrieve real, effective, and saved \" \"user IDs: %s\\\\n\" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <vul-end> setns ( fd <vul-start> ( fd , CLONE_NEWNET ) ; <vul-end> close ( fd <vul-start> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( \"Failed to setns() to the network namespace of \" \"the container with PID %d: %s.\\\\n\" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( \"Failed to drop privilege by setting effective \" \"user id and real user id to %d, and saved user \" \"ID to 0: %s.\\\\n\" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <vul-end> if ( ! <vul-start> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <vul-start> if ( ! ifindex ) { usernic_error ( \"Failed to get netdev index: %s.\\\\n\" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( \"Error %d renaming netdev %s to %s in container.\\\\n\" , ret , <vul-end> oldname , * <vul-start> * newnamep ) ; goto do_full_cleanup <vul-end> ; } if <vul-start> [ IFNAMSIZ ] ; char <vul-end> * namep = <vul-start> ) ) { usernic_error ( \"Failed to get new netdev name: %s.\\\\n\" , strerror ( errno ) ) ; goto do_full_cleanup <vul-end> ; } * <vul-start> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( \"Failed to restore privilege by setting effective \" \"user id to %d, real user id to %d, and saved user \" \"ID to %d: %s.\\\\n\" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <vul-end> setns ( ofd <vul-start> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( \"Failed to setns() to original network namespace \" \"of PID %d: %s.\\\\n\" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <vul-end> ofd ) ; <vul-start> ) ; return fret <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-862 Fixed Code Lines are: <vul-start> { int fd <vul-end> = - 1 <vul-start>, ret, ifname_out = - 1, newname_fd <vul-end> = - 1 <vul-start> 0 ) { lxc_error ( \"Failed to open network namespace path for \\'%d\\'.\", getpid ( ) ) ; close ( fd ) ; <vul-start> ) ; return <vul-end> 1 ; } <vul-start> 0 ) { lxc_error ( \"Failed opening network namespace path for \\'%d\\'.\", pid ) ; close ( fd ) ; return <vul-end> 1 ; } <vul-start> pid ) ; close ( fd ) ; fd = - 1 ; } if ( setns ( fd, 0 ) < 0 ) { fprintf ( stderr, \"setns to container network namespace\\\\n\" ) ; goto out_err ; } close ( fd ) ; fd = - 1 ; if (! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; if (! ( ifindex = if_nametoindex ( oldname ) ) ) { fprintf ( stderr, \"failed to get netdev index\\\\n\" ) ; goto out_err ; } } if ( ( ret = lxc_netdev_rename_by_name ( oldname, * newnamep ) ) < 0 ) { lxc_error ( \"Error %d renaming netdev %s to %s in container\\\\n\", ret, oldname, * newnamep ) ; goto out_err ; } if ( grab_newname ) { char ifname [ IFNAMSIZ ], * namep = ifname ; if (! lxc_open_ns ( pid, \"net\", namep ) ) { fprintf ( stderr, \"Failed to open network namespace path for \\'%d\\'.\", pid ) ; close ( fd ) ; goto out_err ; } * newnamep = strdup ( namep ) ; if (! * newnamep ) goto out_err ; } if ( setns ( ofd, 0 ) < 0 ) { fprintf ( stderr, \"Error returning to original netns\\\\n\" ) ; close ( ofd ) ; close ( fd ) ; goto out_err ; } if ( fd >= 0 ) close ( ofd ) ; if ( fd >= 0 ) close ( fd ) ; if ( fd >= 0 ) close ( fd ) ; return -"
  },
  {
    "id": 641,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void silk_NLSF_stabilize ( opus_int16 * NLSF_Q15 , const opus_int16 * NDeltaMin_Q15 , const opus_int L ) { opus_int i , I = 0 , k , loops ; opus_int16 center_freq_Q15 ; opus_int32 diff_Q15 , min_diff_Q15 , min_center_Q15 , max_center_Q15 ; silk_assert ( NDeltaMin_Q15 [ L ] >= 1 ) ; for ( loops = 0 ; loops < MAX_LOOPS ; loops ++ ) { min_diff_Q15 = NLSF_Q15 [ 0 ] - NDeltaMin_Q15 [ 0 ] ; I = 0 ; for ( i = 1 ; i <= L - 1 ; i ++ ) { diff_Q15 = NLSF_Q15 [ i ] - ( NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = i ; } } diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15 [ L - 1 ] + NDeltaMin_Q15 [ L ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = L ; } if ( min_diff_Q15 >= 0 ) { return ; } if ( I == 0 ) { NLSF_Q15 [ 0 ] = NDeltaMin_Q15 [ 0 ] ; } else if ( I == L ) { NLSF_Q15 [ L - 1 ] = ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ; } else { min_center_Q15 = 0 ; for ( k = 0 ; k < I ; k ++ ) { min_center_Q15 += NDeltaMin_Q15 [ k ] ; } min_center_Q15 += silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <vul-end> ) ; NLSF_Q15\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> i ], silk_min_int <vul-end> ( NLSF_Q15 [\n"
  },
  {
    "id": 642,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 bool_t enc624j600IrqHandler ( NetInterface * interface ) { bool_t flag ; uint16_t status ; flag = FALSE ; <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <vul-end> <vul-start> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <vul-end> <vul-start> if ( ( status & EIR_LINKIF ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ; <vul-end> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <vul-start> if ( ( status & EIR_PKTIF ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ; <vul-end> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <vul-start> if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <vul-end> flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <vul-start> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <vul-end> return flag ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <vul-end> ) ; status <vul-start> ( interface , ENC624J600_EIR <vul-end> ) ; if <vul-start> ( status & ENC624J600_EIR_LINKIF <vul-end> ) != 0 <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE <vul-end> ) ; interface <vul-start> ( status & ENC624J600_EIR_PKTIF <vul-end> ) != 0 <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE <vul-end> ) ; interface <vul-start> status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <vul-end> ) ) != <vul-start> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <vul-end> ) ; flag <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_INTIE <vul-end> ) ; status <vul-start> ( interface, ENC624J600_EIR ) ; if ( ( status & ENC624J600_EIR_LINKIF )!= 0 ) { enc624j600ClearBit ( interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE <vul-end> ) ; interface <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_PKTIE <vul-end> ) ; interface <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_TXABTIF <vul-end> ) )!= <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_TXABTIF <vul-end> ) ; flag <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_INTIE <vul-end> ) ; return\n"
  },
  {
    "id": 643,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <vul-start> int col_offset , end_col_offset ; <vul-end> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <vul-start> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <vul-end> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <vul-start> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <vul-start> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <vul-start> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> col_offset, end_col_offset ; int has_type_comment = 0 <vul-start> |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) { has_type_comment = 1 ; } <vul-start> -> p_tree ; if ( has_type_comment ) { <vul-start> = NULL ; } <vul-start> } if ( has_type_comment ) { if ( <vul-start> |= CO_FUTURE_TYPE_COMMENTS ; }\n"
  },
  {
    "id": 644,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 int do_adjtimex ( struct timex * txc ) { <vul-start> long mtemp , save_adjust , rem ; <vul-end> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> mtemp , save_adjust <vul-end> ; s64 freq_adj <vul-start> ; time_offset = div_s64 <vul-end> ( time_offset , <vul-start> time_offset , NTP_INTERVAL_FREQ <vul-end> ) ; time_offset\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> save_adjust, rem, rem_adj <vul-start> MAXFREQ_NSEC ) ; if ( txc -> freq == 0 ) { <vul-start>, NTP_INTERVAL_FREQ, & rem_adj ) ; } else { time_offset = div_u64_rem_signed ( time_offset, NTP_INTERVAL_FREQ, txc -> freq ) ; } <vul-end> time_offset <<= SHIFT_UPDATE\n"
  },
  {
    "id": 645,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static struct super_block * alloc_super ( struct file_system_type * type , int flags ) { struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; static const struct super_operations default_op ; int i ; if ( ! s ) return NULL ; if ( security_sb_alloc ( s ) ) goto fail ; <vul-start> # ifdef CONFIG_SMP <vul-end> s -> s_files = alloc_percpu ( struct list_head ) ; if ( ! s -> s_files ) goto fail ; <vul-start> for_each_possible_cpu ( i ) <vul-end> INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ; # else INIT_LIST_HEAD ( & s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) goto fail ; <vul-start> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <vul-end> & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; <vul-start> if ( list_lru_init ( & s -> s_dentry_lru ) ) <vul-end> goto fail ; <vul-start> if ( list_lru_init ( & s -> s_inode_lru ) ) <vul-end> goto",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <vul-end> ) goto fail <vul-start> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <vul-end> ) goto fail <vul-start> goto fail ; <vul-end> if ( list_lru_init <vul-start> & s -> s_inode_lru <vul-end> ) ) goto <vul-start> goto fail ; <vul-end> INIT_LIST_HEAD ( &\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> goto fail ; s -> s_files = alloc_percpu ( struct list_head ) ; if (! s -> s_files ) goto fail ; <vul-end> for ( i <vul-start> goto fail ; <vul-end> lockdep_init_map ( & <vul-start> i ], sb_writers_key [ i ], 0 ) ; } init_waitqueue_head ( & s -> s_writers. wait ) ; init_waitqueue_head ( & s -> s_writers. wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_LIST_HEAD ( & s -> s_writers. wait ) ; init_rwsem ( & s -> s_umount ) ; lockdep_set_class ( & s -> s_umount, & type -> s_umount_key ) ; down_write_nested ( & s -> s_umount, SINGLE_DEPTH_NESTING ) ; s -> s_count = 1 ; atomic_set ( & s -> s_active, 1 ) ; mutex_init ( & s -> s_dentry_mutex ) ; mutex_init ( & s -> s_dquot. dqio_mutex ) ; mutex_init ( & s -> s_dquot. dqonoff_mutex ) ; init_rwsem ( & s -> s_dquot. dqptr_sem ) ; s -> s_maxbytes = MAX_NON_LFS ; s -> s_shrink. seeks = DEFAULT_SEEKS ; s -> s_shrink. count_objects = super_cache_count ; s -> s_shrink. flags = SHRINKER_NUMA_AWARE ; return s ; fail : destroy_super ( s ) ; return NULL ; fail : destroy_io ( s ) ; return NULL ; fail : destroy_io ( s ) ; return NULL ; } <vul-end> }  \n"
  },
  {
    "id": 646,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , \"Internal error: directory cache info used in cg_write\\\\n\" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , \"tasks\" ) == 0 || strcmp ( f -> file , \"/tasks\" ) == 0 || strcmp ( f -> file , \"/cgroup.procs\" ) == 0 || strcmp ( f -> file , \"cgroup.procs\" ) == 0 ) <vul-start> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file ,",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> -> pid , fc -> uid ,\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> file, NULL,\n"
  },
  {
    "id": 647,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( \"index\" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( \"codec_name\" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ; } } else { print_str_opt ( \"codec_name\" , \"unknown\" ) ; if ( ! do_bitexact ) { print_str_opt ( \"codec_long_name\" , \"unknown\" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ; print_str ( \"profile\" , profile_num ) ; } else print_str_opt ( \"profile\" , \"unknown\" ) ; } s = av_get_media_type_string",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ) ) ; print_primaries ( w , <vul-end> par -> color_primaries <vul-start> par -> color_primaries <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) ) ; print_primaries ( w, <vul-end> par -> color_primaries\n"
  },
  {
    "id": 648,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( \"fork of unprivileged child failed\" ) ; } else if ( pid != 0 ) { debug2 ( \"Network child is on pid %ld\" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( \"Could not get agent socket: %s\" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ; <vul-start> monitor_sync ( pmonitor ) ; <vul-end> while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( \"%s: waitpid: %s\" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( \"%s: preauth child exited with status %d\" , __func__ , WEXITSTATUS ( status ) ) ; } else",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> pmonitor ) ; <vul-end> while ( waitpid\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> pmonitor ) ; <vul-end> while ( waitpid\n"
  },
  {
    "id": 649,
    "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , \"bin.demangle\" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , \"arm\" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , \"bin.lang\" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , \"bin\" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( \"[\" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"fs exports\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? \"\" : \"[Exports]\\\\n\" ) ; }",
    "golden_answers": [
      "CWE-78 Fixed Code Lines are: <vul-start> { r_cons_printf ( \"\\\\\"k bin/pe/%s/%d=%s.%s\\\\\"\\\\n\" <vul-end> , module , <vul-start> { r_cons_printf ( \"\\\\\"k bin/pe/%s/%d=%s\\\\\"\\\\n\" <vul-end> , module ,\n"
    ],
    "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> { r_cons_printf ( \"fs %s[%d]\\\\n\" <vul-end>, module, <vul-start> { r_cons_printf ( \"fs %s[%d]\\\\n\" <vul-end>, module,\n"
  },
  {
    "id": 650,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int <vul-start> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <vul-end> { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; <vul-start> struct sockaddr_in addr ; <vul-end> int rc = 0 ; <vul-start> char * server = private -> server ; <vul-end> int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks = <vul-start> { <vul-end> <vul-start> . dispatch = cib_remote_dispatch , <vul-end> <vul-start> . destroy = cib_remote_connection_destroy , <vul-end> } ; connection -> socket = 0 ; connection -> session = NULL ; <vul-start> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <vul-end> if ( sock == - 1 ) { crm_perror ( LOG_ERR , \"Socket creation failed\" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( \"Looking up %s\" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( \"getaddrinfo: %s\" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( \"Got",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> remote_connection_s * connection , gboolean event_channel <vul-start> -> variant_opaque ; <vul-end> int rc = <vul-start> = 0 ; int disconnected = 0 <vul-end> ; xmlNode * <vul-start> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <vul-end> . dispatch = <vul-start> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <vul-end> . destroy = <vul-start> destroy = cib_remote_connection_destroy <vul-end> ; connection -> <vul-start> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , \"remote tcp connection to %s:%d failed\" , private -> server , private -> port ) ; } connection -> socket = sock ; <vul-end> if ( connection <vul-start> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <vul-start> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <vul-end> ( sock , <vul-start> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( \"Session creation for %s:%d failed\" , private -> <vul-end> server , private <vul-start> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <vul-end> ; cib_tls_close ( <vul-start> login ) ; <vul-end> crm_recv_remote_msg ( connection <vul-start> -> session , & connection -> recv_buf , <vul-start> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <vul-start> ; } } free_xml ( answer ) ; answer = NULL ; <vul-start> cib ) ; return rc ; } crm_trace ( \"remote client connection established\" ) <vul-end> ; connection ->\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> cib, struct remote_connection <vul-end> * connection ) <vul-start> -> variant_opaque ; <vul-end> int rc = <vul-start> char * server <vul-end> ; int ret_ga <vul-start> cib_fd_callbacks = { } ; struct sockaddr_in addr ; struct sockaddr_storage addr ; struct sockaddr_storage addr2 ; struct sockaddr_storage addr3 ; struct sockaddr_storage addr4 ; struct socklen_storage addr6 ; struct socklen_storage addr7 ; int flags ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; int flags ; struct sockaddr_storage addr4 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr4 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; struct sockaddr_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; int flags ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6 ; struct socklen_storage addr6_un * recv_buf ; int len ; int len ; int flags ; struct socklen_storage * recv_buf ; int len ; int flags ; struct socklen_storage * recv_buf"
  },
  {
    "id": 651,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <vul-start> ALOGE ( \"b/26366256\" ) ; <vul-end> return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554 , \"26366256\"\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554, \"26366256\"\n"
  },
  {
    "id": 652,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <vul-start> ) ) { <vul-end> tlen = compile_length_tree\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } if ( len + SIZE_OP_JUMP >= len ) break ; if ( <vul-start> ) ) { tlen = compile_length_tree ( Else, reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } if ( len + SIZE_OP_JUMP >= len ) break ;\n"
  },
  {
    "id": 653,
    "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( \"Secure connection with TLS?\" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) return SMTP_ERR_WRITE ; <vul-start> rc = smtp_get_resp ( conn ) ; <vul-end> if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( \"Could not negotiate TLS connection\" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( \"SMTP server does not support authentication\" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }",
    "golden_answers": [
      "CWE-74 Fixed Code Lines are: <vul-start> rc = smtp_get_resp ( conn ) ; mutt_socket_empty\n"
    ],
    "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> ; rc = <vul-end> mutt_ssl_starttls ( conn\n"
  },
  {
    "id": 654,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <vul-start> while ( collen > 0 ) <vul-end> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <vul-start> while ( replen > 0 ) <vul-end> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width &&\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> while ( collen >= <vul-end> 0 ) { <vul-start> while ( replen >= <vul-end> 0 ) {\n"
  },
  {
    "id": 655,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic !=",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; number_pixels <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; bytes_per_line <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; bytes_per_line <vul-start> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , \"ImproperImageHeader\" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> \"ImproperImageHeader\" ) ; if ( AcquireMagickMemory ( sun_info. width, sun_info. depth ) == MagickFalse ) { ThrowFileException ( CorruptImageError, \"MemoryAllocationFailed\" ) ; } <vul-start> ; if ( ( <vul-start>!= ( size_t ) <vul-start>. length ) || ( ( size_t ) <vul-start>. width )!= <vul-end> bytes_per_line * sun_info <vul-start>. height ) )\n"
  },
  {
    "id": 656,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( \"%s called\\\\n\" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ; <vul-start> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <vul-end> if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL ) <vul-start> rc = - ENOMEM ; <vul-end> } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( \"Failed to request firmware %s\\\\n\" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> fname ) ; priv -> ctrl . fname = NULL ; <vul-start> == NULL ) return <vul-end> - ENOMEM ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> fname ) ; priv -> ctrl. fname = NULL ; <vul-start> = - ENOMEM <vul-end> ; } if\n"
  },
  {
    "id": 657,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int ca8210_probe ( struct spi_device * spi_device ) { struct ca8210_priv * priv ; struct ieee802154_hw * hw ; struct ca8210_platform_data * pdata ; int ret ; dev_info ( & spi_device -> dev , \"Inserting ca8210\\\\n\" ) ; hw = ieee802154_alloc_hw ( sizeof ( struct ca8210_priv ) , & ca8210_phy_ops ) ; if ( ! hw ) { dev_crit ( & spi_device -> dev , \"ieee802154_alloc_hw failed\\\\n\" ) ; ret = - ENOMEM ; goto error ; } priv = hw -> priv ; priv -> hw = hw ; priv -> spi = spi_device ; hw -> parent = & spi_device -> dev ; spin_lock_init ( & priv -> lock ) ; priv -> async_tx_pending = false ; priv -> hw_registered = false ; priv -> sync_up = 0 ; priv -> sync_down = 0 ; priv -> promiscuous = false ; priv -> retries = 0 ; init_completion ( & priv -> ca8210_is_awake ) ; init_completion ( & priv -> spi_transfer_complete ) ; init_completion ( & priv -> sync_exchange_complete ) ; spi_set_drvdata ( priv -> spi , priv ) ; if ( IS_ENABLED ( CONFIG_IEEE802154_CA8210_DEBUGFS ) ) { cascoda_api_upstream = ca8210_test_int_driver_write ; ca8210_test_interface_init ( priv ) ; } else { cascoda_api_upstream = NULL ; } ca8210_hw_setup ( hw ) ; ieee802154_random_extended_addr ( & hw -> phy -> perm_extended_addr ) ; pdata = kmalloc ( sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { ret = - ENOMEM ; goto error ; } <vul-start> ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; <vul-end> if",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> error ; } <vul-end> priv -> spi <vul-start> ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_get_platform_data failed\\\\n\" ) ; goto error ; } ret =\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> error ; } priv -> spi -> dev. platform_data = pdata ; <vul-start> ca8210_dev_com_init ( priv <vul-end> ) ; if\n"
  },
  {
    "id": 658,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = \"libevt_record_values_read_event\" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record values.\" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record data.\" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , \"%s: invalid record data size value exceeds maximum.\" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: record data size value out of bounds.\" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID data size value out of bounds.\" , function ) ; goto on_error ; } if ( <vul-start> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings size value out of bounds.\" , function ) ; goto on_error ; } <vul-start> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: data size value out of bounds.\" , function ) ; goto on_error ; } <vul-start> ( record_data [ record_data_offset <vul-end> ] ) ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> { if (! record_values -> user_security_identifier ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED, \"%s: invalid user security identifier.\", function ) ; goto on_error ; } if ( <vul-start> { if (! record_values -> user_security_identifier ) { libcerror_error_set ( error, LIBCERROR_ERROR_DOMAIN_RUNTIME, LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED, \"%s: invalid user security identifier.\", function ) ; goto on_error ; } if (\n"
  },
  {
    "id": 659,
    "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <vul-start> total_len = iov_length ( iov , nr_segs ) ; <vul-end> if ( unlikely ( total_len == 0 ) ) <vul-start> return 0 ; <vul-end> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <vul-start> void * addr ; <vul-end> <vul-start> size_t chars = buf -> len ; <vul-end> <vul-start> int error , atomic ; <vul-end> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <vul-start> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <vul-end> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic",
    "golden_answers": [
      "CWE-17 Fixed Code Lines are: <vul-start> size_t total_len ; struct iov_iter iter ; <vul-start> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <vul-start> -> ops ; <vul-end> size_t chars = <vul-start> buf -> len ; size_t written <vul-start> ; int error <vul-end> ; if ( <vul-start> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <vul-end> ; break ;\n"
    ],
    "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> size_t total_len ; size_t remaining ; <vul-start> 0 ) ) { if (! iov_count ( iov, nr_segs ) ) { ret = 0 ; break ; } else { remaining = iov_length ( iov, nr_segs ) ; } <vul-end> do_wakeup = 0 <vul-start> -> ops ; const struct iov_iter * iter = & pipe -> iov_iter ; <vul-start> buf -> len, remaining <vul-start> error, atomic ; if ( remaining < 0 ) { if ( remaining ) remaining = 0 ; error = - EFAULT ; break ; } remaining = remaining <vul-start> break ; } if ( remaining < 0 ) { ret = 0 ; break ; } <vul-start>, chars ) ; if (! iov_count ( iov, nr_segs ) ) { if ( ret ) ret = 0 ; break ; } remaining = iov_count ( iov, nr_segs )\n"
  },
  {
    "id": 660,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( \"check_rpcsec_auth: failed \" \"inquire_context, stat=%u\" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <vul-start> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <vul-end> &&",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> princ ) ; success = data_eq_string ( * realm , <vul-end> handle -> params <vul-start> params . realm ) && data_eq_string ( * c1 , \"kadmin\" ) && ! data_eq_string ( * c2 , \"history\" ) ; <vul-end> fail_princ : if\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; if ( realm -> length == 0 ||\n"
  },
  {
    "id": 661,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , \"Pixel format 0x%0x\" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> bpp <= 8 && c -> format != CHUNKY\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> c -> palette_size <vul-end> ) { avctx\n"
  },
  {
    "id": 662,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , \"initial",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> * ke ; <vul-end> char fromname [ <vul-start> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( \"Received Notify(%d): %s\" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( \"rejecting I1 from %s:%u, no KE payload present\" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <vul-end> \"rejecting I1 from %s:%u, invalid DH group=%u\" , fromname <vul-start> ) ; return STF_FAIL +\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> * ke ; st -> st_oakley. group = lookup_group ( <vul-end> md -> chain <vul-start> md -> chain [ ISAKMP_NEXT_v2KE ] -> payload. v2ke, <vul-end> ke -> isak_group <vul-start> ADDRTOT_BUF ) ; if ( st -> st_oakley. group == NULL ) { <vul-start> isak_group ) ; }\n"
  },
  {
    "id": 663,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ; <vul-start> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <vul-end> if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ; <vul-start> cpi -> kf_overspend_bits = 0 ; <vul-end> cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> common ; memset <vul-end> ( cpi , <vul-start> ; cpi -> temporal_layer_id = - 1 ; cpi -> <vul-start> endif cpi -> mse_source_denoised = 0 ; cpi -> <vul-start> / 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <vul-start> ) NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <vul-start> ; cpi -> force_maxqp = 0 ; cpi -> <vul-start> # endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( \"denoised.yuv\" , \"ab\" ) ; # endif # <vul-start> . sdf = vpx_sad16x16 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance16x16 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance16x16 <vul-end> ; cpi -> <vul-start> . svf_halfpix_h = vpx_variance_halfpixvar16x16_h <vul-end> ; cpi -> <vul-start> . svf_halfpix_v = vpx_variance_halfpixvar16x16_v <vul-end> ; cpi -> <vul-start> . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad16x16x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad16x16x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad16x16x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad16x8 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance16x8 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance16x8 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad16x8x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad16x8x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad16x8x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad8x16 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance8x16 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance8x16 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad8x16x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad8x16x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad8x16x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad8x8 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance8x8 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance8x8 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad8x8x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad8x8x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad8x8x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad4x4 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance4x4 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance4x4 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad4x4x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad4x4x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad4x4x4d <vul-end> ; # if\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> common ; memset <vul-end> ( cpi, <vul-start> endif cpi -> mb. ss, vpx_calloc ( sizeof ( search_site ), ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; CHECK_MEM_ERROR ( cpi -> mb. ss, vpx_calloc ( sizeof ( search_site ), ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; memcpy ( cpi -> <vul-start> ; cpi -> <vul-end> main_buffer_size = cpi <vul-start> ; cpi -> mb. mb_rows = cpi -> common. mb_cols ; cpi -> mb. mb_rows = cpi -> common. mb_rows ; cpi -> mb. mb_cols = cpi -> common. mb_cols ; cpi -> <vul-start> ; cpi -> mb. mb_rows = cpi -> common. mb_cols ; cpi -> mb.\n"
  },
  {
    "id": 664,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = \"nf_ct_dccp: not picking up existing connection \" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = \"nf_ct_dccp: invalid state transition \" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , \"%s\" , msg ) ; return false ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; BUG_ON\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, & dh <vul-end> ) ; state\n"
  },
  {
    "id": 665,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register PixelPacket * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , \"\\\\200\\\\052\\\\137\\\\327\" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> image_info -> ping != MagickFalse <vul-start> return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. lines_per_image ; ( void ) CopyMagickString ( property, cin. file. header, sizeof ( cin. file. header ) ) ; <vul-start> return ( image ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) { ThrowFileException ( exception, CorruptImageError, \"InsufficientImageDataInFile\"\n"
  },
  {
    "id": 666,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <vul-start> return tmp ; <vul-end> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> tmp ) { goto softfail <vul-end> ; } case <vul-start> ) ) { goto softfail <vul-end> ; } state <vul-start> end ) ; softfail : state -> offset = 0 ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { return ++ <vul-start> ) ) { if (! state -> ptr ) { return NULL ; } <vul-start> end ) ; if (! state -> ptr ) { return NULL ; }\n"
  },
  {
    "id": 667,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <vul-start> id = idr_alloc ( & ids -> ipcs_idr , new , <vul-end> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <vul-start> current_euid_egid ( & euid , & egid ) ; <vul-end> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <vul-start> in_use ++ ; <vul-end> if ( next_id\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> lock ) ; current_euid_egid ( & euid, & egid ) ; <vul-start> in_use ++ ; <vul-end> new -> cuid\n"
  },
  {
    "id": 668,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , \"Transfer-Encoding\" ) ; lenp = apr_table_get ( f -> r -> headers_in , \"Content-Length\" ) ; if ( tenc ) { if ( strcasecmp ( tenc , \"chunked\" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , \"chunked\" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <vul-start> \"Unknown Transfer-Encoding: %s;\" <vul-end> \" using read-until-close\"",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( 02555 ) \"Unknown Transfer-Encoding: %s; \" \"using read-until-close\" <vul-end> , tenc ) <vul-start> ) ; return APR_EINVAL <vul-end> ; } if <vul-start> bb ) ; apr_brigade_cleanup ( bb ) ; <vul-start> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <vul-end> : { rv <vul-start> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <vul-end> ) ; } <vul-start> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) \"Unexpected body state (%i)\" , ( int ) ctx -> state ) ; return APR_EGENERAL <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( 02555 ) \"Unknown Transfer-Encoding: %s; using read-until-close\" <vul-end>, tenc ) <vul-start> ; if ( f -> c -> output_filters == NULL ) { rv = APR_EGENERAL ; break ; } if (\n"
  },
  {
    "id": 669,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <vul-start> break ; <vul-end> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( !",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> tl2 ; } * tl_data_head = NULL ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> tl2 ; } if ( tl!= NULL ) break ;\n"
  },
  {
    "id": 670,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: \n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> numprcs ; if ( pi -> prcno >= pi -> pirlvl -> numprcs ) { continue ; }\n"
  },
  {
    "id": 671,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , \"%s()\\\\n\" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ; <vul-start> memcpy ( name , fp + n , name_len ) ; n += name_len ; <vul-end> name [ name_len ] = '\\\\0' ; <vul-start> attr_len = fp [ n ++ ] ; <vul-end> memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\\\0' ; IRDA_DEBUG ( 4 , \"LM-IAS: Looking up %s: %s\\\\n\" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , \"LM-IAS: Object %s not found\\\\n\" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , \"LM-IAS: found %s, id=%d\\\\n\" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , \"LM-IAS:",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <vul-start> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ++ ] ; if ( name_len > sizeof ( name ) ) { IRDA_DEBUG ( 2, \"LM-IAS: Too many attributes\\\\n\" ) ; iriap_getvaluebyclass_response ( self, 0x1235, IAS_CLASS_UNKNOWN, & irias_missing ) ; return ; } <vul-start> ++ ] ; if ( attr_len > sizeof ( attr ) ) { IRDA_DEBUG ( 2, \"LM-IAS: Too many attributes\\\\n\" ) ; iriap_getvaluebyclass_response ( self, 0x1235, IAS_CLASS_UNKNOWN, & irias_missing ) ; return ; }\n"
  },
  {
    "id": 672,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static void finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) { krb5_key_data * server_key ; krb5_keyblock * as_encrypting_key = NULL ; krb5_data * response = NULL ; const char * emsg = 0 ; int did_log = 0 ; loop_respond_fn oldrespond ; void * oldarg ; kdc_realm_t * kdc_active_realm = state -> active_realm ; krb5_audit_state * au_state = state -> au_state ; assert ( state ) ; oldrespond = state -> respond ; oldarg = state -> arg ; if ( errcode ) goto egress ; au_state -> stage = ENCR_REP ; if ( ( errcode = validate_forwardable ( state -> request , * state -> client , * state -> server , state -> kdc_time , & state -> status ) ) ) { errcode += ERROR_TABLE_BASE_krb5 ; goto egress ; } errcode = check_indicators ( kdc_context , state -> server , state -> auth_indicators ) ; if ( errcode ) { state -> status = \"HIGHER_AUTHENTICATION_REQUIRED\" ; goto egress ; } state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , - 1 , - 1 , 0 , & server_key ) ) ) { state -> status = \"FINDING_SERVER_KEY\" ; goto egress ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & state -> server_keyblock , NULL ) ) ) { state -> status = \"DECRYPT_SERVER_KEY\" ; goto egress ; } state -> reply . msg_type = KRB5_AS_REP ; state -> reply . client = state -> enc_tkt_reply . client",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> errcode != 0 && state -> status == NULL ) state -> status = \"UNKNOWN_REASON\" <vul-end> ; au_state ->\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> : if ( state -> preauth_err ) { errcode = KRB5KDC_ERR_ETYPE_NOSUPP ; goto egress ; } if (\n"
  },
  {
    "id": 673,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <vul-start> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <vul-end> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY )",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address <vul-start> , 1 , <vul-end> regs , address <vul-start> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <vul-end> , regs ,\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address <vul-start>, 1, <vul-end> regs, address\n"
  },
  {
    "id": 674,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <vul-start> spin_lock ( & desc -> iuspin ) ; <vul-end> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ENOENT\" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ECONNRESET\" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ESHUTDOWN\" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , \"nonzero urb status received: -EPIPE\\\\n\" ) ; break ; default : dev_err ( & desc -> intf -> dev , \"Unexpected error %d\\\\n\" , status ) ; break ; } } desc -> rerr = status ; <vul-start> desc -> reslength = urb -> actual_length ; <vul-end> <vul-start> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <vul-end> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> status ; int length = urb -> actual_length ; <vul-start> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <vul-end> memmove ( desc <vul-start> -> inbuf , length ) ; desc -> length += length ; <vul-start> desc -> reslength = length ; } } <vul-end> skip_error : wake_up\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> status ; size_t actual_length = urb -> actual_length ; <vul-start> -> iuspin ) ; if (! desc -> inbuf || desc -> length > actual_length ) goto skip_error <vul-start> = status ; <vul-end> memmove ( desc <vul-start> -> inbuf, actual_length ) ; desc -> length = actual_length <vul-end> ; skip_error :\n"
  },
  {
    "id": 675,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( \"inspecting content %\" PRIu32 \" buffer_len %\" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( \"det_ctx->buffer_offset %\" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd ->",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ) ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <vul-start> } if ( smd -> is_last ) { goto match <vul-end> ; } SCLogDebug <vul-start> ) ; } SCLogDebug ( \"no match for \\'next sm\\'\" ) ; <vul-start> -> discontinue_matching ) { SCLogDebug ( \"\\'next sm\\' said to discontinue this right now\" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( \"\\'next sm\\' does not depend on me, so we can give up\" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( \"\\'next sm\\' depends on me %p, lets see what we can do (flags %u)\" , cd , cd -> flags ) <vul-end> ; prev_offset =\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ) { goto match <vul-end> ; } else <vul-start> ) ) { goto match <vul-end> ; } else <vul-start> } } } if (! cd -> buffer_offset ) { SCLogError ( SC_ERR_INTERNAL_ERROR, \"detected content buffer is empty\" ) ; SCReturnInt ( 0 ) ; }\n"
  },
  {
    "id": 676,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <vul-start> if ( ret == - EEXIST ) <vul-end> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> == - EEXIST || ret == - EOVERFLOW\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> == - EEXIST || ret == - EOVERFLOW\n"
  },
  {
    "id": 677,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void fadst8 ( const int16_t * input , int16_t * output ) { <vul-end> <vul-start> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <vul-end> int x0 = input [ 7 ] ; <vul-start> int x1 = input [ 0 ] ; <vul-end> <vul-start> int x2 = input [ 5 ] ; <vul-end> <vul-start> int x3 = input [ 2 ] ; <vul-end> <vul-start> int x4 = input [ 3 ] ; <vul-end> <vul-start> int x5 = input [ 4 ] ; <vul-end> <vul-start> int x6 = input [ 1 ] ; <vul-end> <vul-start> int x7 = input [ 6 ] ; <vul-end> s0 = cospi_2_64 * x0 + cospi_30_64 * x1 ; s1 = cospi_30_64 * x0 - cospi_2_64 * x1 ; s2 = cospi_10_64 * x2 + cospi_22_64 * x3 ; s3 = cospi_22_64 * x2 - cospi_10_64 * x3 ; s4 = cospi_18_64 * x4 + cospi_14_64 * x5 ; s5 = cospi_14_64 * x4 - cospi_18_64 * x5 ; s6 = cospi_26_64 * x6 + cospi_6_64 * x7 ; s7 = cospi_6_64 * x6 - cospi_26_64 * x7 ; x0 = fdct_round_shift ( s0 + s4 ) ; x1 = fdct_round_shift ( s1 + s5 ) ; x2 = fdct_round_shift ( s2 + s6 ) ; x3 = fdct_round_shift ( s3 + s7 ) ; x4 = fdct_round_shift ( s0 - s4 ) ; x5 = fdct_round_shift ( s1 - s5 ) ; x6 = fdct_round_shift ( s2 - s6 ) ; x7 = fdct_round_shift ( s3 - s7 ) ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> fadst8 ( const tran_low_t * input , tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t <vul-end> x0 = input <vul-start> 7 ] ; tran_high_t <vul-end> x1 = input <vul-start> 0 ] ; tran_high_t <vul-end> x2 = input <vul-start> 5 ] ; tran_high_t <vul-end> x3 = input <vul-start> 2 ] ; tran_high_t <vul-end> x4 = input <vul-start> 3 ] ; tran_high_t <vul-end> x5 = input <vul-start> 4 ] ; tran_high_t <vul-end> x6 = input <vul-start> 1 ] ; tran_high_t <vul-end> x7 = input <vul-start> 0 ] = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> fad8 ( const tran_low_t <vul-end> * input, <vul-start> * input, tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0, s1 <vul-start> s7 ; int x0, x1, x2, x3, x4, x5, x6, x7 ; tran_high_t <vul-end> x0 = input <vul-start> 7 ] ; tran_high_t <vul-end> x2 = input <vul-start> 5 ] ; tran_high_t <vul-end> x3 = input <vul-start> 2 ] ; tran_high_t <vul-end> x4 = input <vul-start> 3 ] ; tran_high_t <vul-end> x5 = input <vul-start> 4 ] ; tran_high_t <vul-end> x6 = input <vul-start> 1 ] ; tran_high_t <vul-end> x7 = input <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
  },
  {
    "id": 678,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) { EAS_RESULT result ; EAS_U32 temp ; EAS_I32 size ; EAS_I32 endChunk ; EAS_I32 chunkPos ; EAS_I32 wsmpPos = 0 ; EAS_I32 fmtPos = 0 ; EAS_I32 dataPos = 0 ; EAS_I32 dataSize = 0 ; S_WSMP_DATA * p ; void * pSample ; S_WSMP_DATA wsmp ; chunkPos = pos + 12 ; if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) return result ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; if ( temp != CHUNK_WAVE ) { { } return EAS_ERROR_FILE_FORMAT ; } pos = chunkPos ; endChunk = pos + size ; while ( pos < endChunk ) { chunkPos = pos ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; switch ( temp ) { case CHUNK_WSMP : wsmpPos = chunkPos + 8 ; break ; case CHUNK_FMT : fmtPos = chunkPos + 8 ; break ; case CHUNK_DATA : dataPos = chunkPos + 8 ; dataSize = size ; break ; default : break ; } } <vul-start> if ( dataSize > MAX_DLS_WAVE_SIZE ) <vul-end> { return EAS_ERROR_SOUND_LIBRARY ; } if ( pDLSData -> pDLS == NULL ) p = & wsmp ; else p = & pDLSData -> wsmpData [ waveIndex ] ; p -> fineTune = 0",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> } if ( dataSize < 0 ||\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> if ( dataSize < p -> fineTune || dataSize\n"
  },
  {
    "id": 679,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; <vul-start> char * bufp , * commentp , * altp ; <vul-end> mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == ' ' ) commentp [ - 1 ] = '\\\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , \"finish\" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( \"No \\\\\"finish\\\\\"\" ) ; return 0 ; } ++ bufp ; if ( * bufp == ' ' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( \"Unknown sym keyword\" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof *",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0'\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start>, * altp <vul-end> ; if (\n"
  },
  {
    "id": 680,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int mi_repair ( MI_CHECK * param , register MI_INFO * info , <vul-start> char * name , int rep_quick ) <vul-end> { int error , got_error ; ha_rows start_records , new_header_length ; my_off_t del ; File new_file ; MYISAM_SHARE * share = info -> s ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; SORT_INFO sort_info ; MI_SORT_PARAM sort_param ; DBUG_ENTER ( \"mi_repair\" ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; start_records = info -> state -> records ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ; got_error = 1 ; new_file = - 1 ; sort_param . sort_info = & sort_info ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( \"- recovering (with keycache) MyISAM-table \\'%s\\'\\\\n\" , name ) ; printf ( \"Data records: %s\\\\n\" , llstr ( info -> state -> records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ; if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ; if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length ,",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> , int rep_quick , my_bool no_copy_stat <vul-start> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <vul-start> , DATA_TMP_EXT , flags <vul-end> ) || mi_open_datafile\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>, int rep_quick, my_bool no_copy_stat <vul-start> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_NO_COPY_STAT ; <vul-start>, llbuff2, flags <vul-end> ) ) <\n"
  },
  {
    "id": 681,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int dbConnect ( char * host , char * user , char * passwd ) { DBUG_ENTER ( \"dbConnect\" ) ; if ( verbose ) { fprintf ( stderr , \"# Connecting to %s...\\\\n\" , host ? host : \"localhost\" ) ; } mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <vul-start> # ifdef HAVE_OPENSSL <vul-end> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , \"program_name\" , \"mysqlcheck\" ) ; if ( ! ( sock = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 )",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <vul-end> if ( opt_protocol\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> NullS ) ; SSL_SET ( & mysql_connection ) ; <vul-end> if ( opt_protocol\n"
  },
  {
    "id": 682,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , \"metadata sets count %d\\\\n\" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , \"no material package found\\\\n\" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , \"material_package_umid\" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , \"material_package_name\" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> av_log ( mxf -> fc\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\\\n\" ) ; continue ; } if (! essence_data ) { av_log ( mxf -> fc, AV_LOG_ERROR, \"could not resolve essence container data\\\\n\" <vul-end> ) ; ret\n"
  },
  {
    "id": 683,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI ECFG\" ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI hole (32-bit)\" ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI hole (64-bit)\" ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pr_notice ( \"pci deinit %s\\\\n\"\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ops == NULL ) { pr_err ( \"%s: No PCI device for %s\\\\n\", __func__, fi -> fi_name ) ; ops = NULL ; continue ; } <vul-end> pr_notice ( \"pci deinit %s\\\\n\"\n"
  },
  {
    "id": 684,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <vul-start> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <vul-end> <vul-start> struct trusted_key_payload * new_p ; <vul-end> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ;",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <vul-start> 0 ] ; <vul-end> if ( !\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE, & key -> flags ) ) return - ENOKEY ; p <vul-start> 0 ] ; <vul-end> if ( datalen\n"
  },
  {
    "id": 685,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , \"Found constant of type %s where boolean was expected\\\\n\" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , \"true\" ) || istreq ( ident , \"yes\" ) || istreq ( ident , \"on\" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , \"false\" ) || istreq ( ident , \"no\" ) || istreq ( ident , \"off\" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , \"Identifier \\\\\"%s\\\\\" of type boolean is unknown\\\\n\" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , \"Default \\\\\"%s.%s\\\\\" of type boolean is unknown\\\\n\" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <vul-start> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <vul-end> if ( ok ) * set_rtrn =",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ctx , expr -> unary . child\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> : ok = expr -> boolean. set ; if (! ok ) { log_err ( ctx, \"Not allowed in boolean value\\\\n\" ) ; return false ; } ok =\n"
  },
  {
    "id": 686,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = \"this\" ; debug_locals [ argReg ] . descriptor = r_str_newf ( \"%s;\" ,",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> parameters_size ; } if ( p4 <= 0 ) { return ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> parameters_size ; } if (! ( params = dex_method_signature2 ( bin, MI ) ) ) { return ; } <vul-start> = * ( p4 <vul-end> ++ ) &\n"
  },
  {
    "id": 687,
    "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image ->",
    "golden_answers": [
      "CWE-835 Fixed Code Lines are: <vul-start> != '\\\\0' ) && ( c != EOF ) <vul-start> 2 ] ; if ( <vul-end> sscanf ( value <vul-start> 1 ] ) == 8 ) { <vul-end> image -> chromaticity <vul-start> 1 ] ; } <vul-start> , width ; if ( <vul-end> sscanf ( value <vul-start> & width ) == 2 ) { <vul-end> image -> columns <vul-start> ) height ; }\n"
    ],
    "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> ( void ) strncpy ( & chromaticity [ 0 ], & chromaticity [ 1 ], & chromaticity [ 2 ], & chromaticity [ 3 ], & chromaticity [ 4 ], & chromaticity [ 5 ], & white_point [ 0 ], & white_point [ 1 ] ) ; status = SetImageProperty ( image, tag, value, exception ) ; break ; case 'G' : case 'P' : { if ( LocaleCompare ( keyword, \"primaries\" ) == 0 ) { if ( <vul-start> 1 ] )!= 0 ) { p = ( char * ) NULL ; q = RelinquishQuantum ( q, white_point, MaxTextExtent ) ; if ( q == ( Quantum * ) NULL ) break ; } ( void ) SetImageProperty ( image, tag, value, exception ) ; break ; } <vul-end> switch ( *\n"
  },
  {
    "id": 688,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , int op_flag , unsigned int size , unsigned int __user * tlv ) { struct user_element * ue = kcontrol -> private_data ; int change = 0 ; void * new_data ; if ( op_flag > 0 ) { if ( size > 1024 * 128 ) return - EINVAL ; new_data = memdup_user ( tlv , size ) ; if ( IS_ERR ( new_data ) ) return PTR_ERR ( new_data ) ; <vul-start> change = ue -> tlv_data_size != size ; <vul-end> if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ; kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; ue -> tlv_data_size = size ; <vul-start> } else { <vul-end> if ( ! ue -> tlv_data_size || ! ue -> tlv_data ) <vul-start> return - ENXIO ; <vul-end> <vul-start> if ( size < ue -> tlv_data_size ) <vul-end> <vul-start> return - ENOSPC ; <vul-end> <vul-start> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <vul-end> <vul-start> return - EFAULT ; <vul-end> <vul-start> } <vul-end> return change ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <vul-start> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> -> tlv_data ) { ret = <vul-end> - ENXIO ; <vul-start> - ENXIO ; goto err_unlock ; } <vul-start> -> tlv_data_size ) { ret = <vul-end> - ENOSPC ; <vul-start> - ENOSPC ; goto err_unlock ; } <vul-start> tlv_data_size ) ) ret = <vul-end> - EFAULT ; <vul-start> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> new_data ) ; if ( ue -> tlv_data_size == size ) change = 1 ; else <vul-end> change = memcmp <vul-start> size ; } if ( change ) return - EINVAL ; <vul-end> if (! <vul-start> tlv_data ) return 0 <vul-end> ; if ( <vul-start> -> tlv_data_size ) { if ( copy_to_user ( tlv, ue -> tlv_data, ue -> tlv_data_size ) ) change = - EFAULT ; } else <vul-end> if ( copy_to_user <vul-start> tlv_data_size ) ) { if ( copy_to_user ( tlv, ue -> tlv_data, ue -> tlv_data_size ) ) change = <vul-end> - EFAULT ; <vul-start> - EFAULT ; <vul-end> return change ;\n"
  },
  {
    "id": 689,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <vul-start> } <vul-end> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"USBMS\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , \"USB Mass Storage\" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb ,",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MFC_MS_HIGHBITDEPTH ;\n"
  },
  {
    "id": 690,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void exif_mnote_data_pentax_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataPentax * n = ( ExifMnoteDataPentax * ) en ; size_t i , tcount , o , datao , base = 0 ; ExifShort c ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataPentax\" , \"Short MakerNote\" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 8 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataPentax\" , \"Short MakerNote\" ) ; return ; } if ( ! memcmp ( buf + datao , \"AOC\" , 4 ) ) { if ( ( buf [ datao + 4 ] == 'I' ) && ( buf [ datao + 5 ] == 'I' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_INTEL ; } else if ( ( buf [ datao + 4 ] == 'M' ) && ( buf [ datao + 5 ] == 'M' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> version = pentaxV2 ; } exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteDataPentax\" , \"Parsing Pentax maker note v%d...\" , ( int ) n -> version ) ; datao += 4 + 2 ; base = MNOTE_PENTAX2_TAG_BASE ; } else if ( ! memcmp ( buf + datao , \"QVC\" , 4 ) ) { exif_log (",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; if ( CHECKOVERFLOW <vul-end> ( o,\n"
  },
  {
    "id": 691,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d , <vul-start> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <vul-end> { ExifLong o , thumbnail_offset = 0 , thumbnail_length = 0 ; ExifShort n ; ExifEntry * entry ; unsigned int i ; ExifTag tag ; if ( ! data || ! data -> priv ) return ; if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= EXIF_IFD_COUNT ) ) return ; <vul-start> if ( recursion_depth > 12 ) { <vul-end> exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifData\" , <vul-start> \"Deep recursion detected!\" ) ; <vul-end> return ; } if ( ( offset + 2 < offset ) || ( offset + 2 < 2 ) || ( offset + 2 > ds ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifData\" , \"Tag data past end of buffer (%u > %u)\" , offset + 2 , ds ) ; return ; } n = exif_get_short ( d + offset , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Loading %hu entries...\" , n ) ; offset += 2 ; if ( offset + 12 * n > ds ) { n = ( ds - offset ) / 12 ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Short data; only loading %hu entries...\" , n )",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> , unsigned int recursion_cost <vul-end> ) { ExifLong <vul-start> ; if ( recursion_cost > 170 <vul-end> ) { exif_log <vul-start> , \"ExifData\" , \"Deep/expensive recursion detected!\" <vul-end> ) ; return <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, unsigned int * <vul-start> ; if ( * recursion_depth > 12 ) { exif_log ( data -> priv -> log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\", \"Deep recursion detected!\" ) ; return ; } if ( <vul-start>, o, * <vul-start> recursion_depth + 1, * recursion_depth <vul-start>, o, *\n"
  },
  {
    "id": 692,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) { <vul-start> int n ; <vul-end> int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <vul-start> long newbufsize ; <vul-end> long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( \"mem_write(%p, %p, %d)\\\\n\" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) { <vul-start> newbufsize <<= 1 ; <vul-end> assert ( newbufsize >= 0 ) ; } <vul-start> JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %z\\\\n\" , m -> bufsize_ , <vul-end> newbufsize ) ) ; JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %ul\\\\n\" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <vul-start> if ( m -> pos_ > m -> len_ ) { <vul-end> n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> cnt ) { size_t <vul-end> n ; int <vul-start> ) obj ; size_t newbufsize ; size_t <vul-end> newpos ; assert <vul-start> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <vul-end> JAS_DBGLOG ( 100 <vul-start> 100 , ( \"new buffer size would cause overflow\\\\n\" ) ) ; <vul-end> return - 1 <vul-start> ; } } JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %zu\\\\n\" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> cnt ) { ssize_t <vul-end> n ; int <vul-start> ) obj ; jas_sizesize_t <vul-end> newbufsize ; long <vul-start> newpos ) { if ( newbufsize > JAS_UINT32_MAX / sizeof ( jas_uchar_t ) ) { jas_eprintf ( \"mem_write overflow in jas_stream_memobj_t\\\\n\" ) ; } <vul-start> 100, ( \"mem_write resizing from %z to %z\\\\n\" <vul-end>, m -> <vul-start> } if ( cnt == 0 && <vul-start> len_ ) { jas_eprintf ( \"mem_write was not really designed to handle a buffer of size 0\\\\n\" ) ; }\n"
  },
  {
    "id": 693,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; <vul-start> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <vul-end> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> fs_info -> subvol_sem ) ; if (! inode_owner_or_capable ( dir -> d_inode ) ) goto out_up_read ; error = btrfs_check_dir_item_collision ( dir, dentry\n"
  },
  {
    "id": 694,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 <vul-start> int bind_ports ( void ) { <vul-end> SERVICE_OPTIONS * opt ; int listening_section ; # ifdef USE_LIBWRAP libwrap_init ( ) ; # endif s_poll_init ( fds , 1 ) ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { unsigned i ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) opt -> local_fd [ i ] = INVALID_SOCKET ; } listening_section = 0 ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { opt -> bound_ports = 0 ; if ( opt -> local_addr . num ) { unsigned i ; s_log ( LOG_DEBUG , \"Binding service [%s]\" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) { SOCKET fd ; fd = bind_port ( opt , listening_section , i ) ; opt -> local_fd [ i ] = fd ; if ( fd != INVALID_SOCKET ) { s_poll_add ( fds , fd , 1 , 0 ) ; ++ opt -> bound_ports ; } } if ( ! opt -> bound_ports ) { s_log ( LOG_ERR , \"Binding service [%s] failed\" , opt -> servname ) ; return 1 ; } ++ listening_section ; } else if ( opt -> exec_name && opt -> connect_addr . names ) { s_log ( LOG_DEBUG , \"Skipped exec+connect service [%s]\" , opt -> servname ) ; # ifndef OPENSSL_NO_TLSEXT } else if ( ! opt -> option",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start>       NOEXPORT\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start>       static\n"
  },
  {
    "id": 695,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 bool copyaudiodata ( AFfilehandle infile , AFfilehandle outfile , int trackid ) { int frameSize = afGetVirtualFrameSize ( infile , trackid , 1 ) ; <vul-start> const int kBufferFrameCount = 65536 ; <vul-end> <vul-start> void * buffer = malloc ( kBufferFrameCount * frameSize ) ; <vul-end> AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ; AFframecount totalFramesWritten = 0 ; bool success = true ; while ( totalFramesWritten < totalFrames ) { AFframecount framesToRead = totalFrames - totalFramesWritten ; if ( framesToRead > kBufferFrameCount ) framesToRead = kBufferFrameCount ; AFframecount framesRead = afReadFrames ( infile , trackid , buffer , framesToRead ) ; if ( framesRead < framesToRead ) { fprintf ( stderr , \"Bad read of audio track data.\\\\n\" ) ; success = false ; break ; } AFframecount framesWritten = afWriteFrames ( outfile , trackid , buffer , framesRead ) ; if ( framesWritten < framesRead ) { fprintf ( stderr , \"Bad write of audio track data.\\\\n\" ) ; success = false ; break ; } totalFramesWritten += framesWritten ; } free ( buffer ) ; return success ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> int kBufferFrameCount = <vul-start> kBufferFrameCount = 65536 ; int bufferSize ; while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2 <vul-start> = malloc ( bufferSize <vul-end> ) ; AFframecount\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> 1 ) ; if ( frameSize == 0 ) { fprintf ( stderr, \"Bad virtual frame size.\\\\n\" ) ; success = false ; break ; } <vul-start> = malloc ( ( size_t )\n"
  },
  {
    "id": 696,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vpx_scale_frame ( YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , unsigned char * temp_area , unsigned char temp_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i ; int dw = ( hscale - 1 + src -> y_width * hratio ) / hscale ; int dh = ( vscale - 1 + src -> y_height * vratio ) / vscale ; Scale2D ( ( unsigned char * ) src -> y_buffer , src -> y_stride , src -> y_width , src -> y_height , ( unsigned char * ) dst -> y_buffer , dst -> y_stride , dw , dh , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw < ( int ) dst -> y_width ) for ( i = 0 ; i < dh ; i ++ ) <vul-start> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <vul-end> if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ; i < ( int ) dst -> y_height ; i ++ ) <vul-start> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst ->\n"
  },
  {
    "id": 697,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 int htc_connect_service ( struct htc_target * target , struct htc_service_connreq * service_connreq , enum htc_endpoint_id * conn_rsp_epid ) { struct sk_buff * skb ; struct htc_endpoint * endpoint ; struct htc_conn_svc_msg * conn_msg ; int ret ; unsigned long time_left ; endpoint = get_next_avail_ep ( target -> endpoint ) ; if ( ! endpoint ) { dev_err ( target -> dev , \"Endpoint is not available for service %d\\\\n\" , service_connreq -> service_id ) ; return - EINVAL ; } endpoint -> service_id = service_connreq -> service_id ; endpoint -> max_txqdepth = service_connreq -> max_send_qdepth ; endpoint -> ul_pipeid = service_to_ulpipe ( service_connreq -> service_id ) ; endpoint -> dl_pipeid = service_to_dlpipe ( service_connreq -> service_id ) ; endpoint -> ep_callbacks = service_connreq -> ep_callbacks ; skb = alloc_skb ( sizeof ( struct htc_conn_svc_msg ) + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , \"Failed to allocate buf to send\" \"service connect req\\\\n\" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; conn_msg = skb_put ( skb , sizeof ( struct htc_conn_svc_msg ) ) ; conn_msg -> service_id = cpu_to_be16 ( service_connreq -> service_id ) ; conn_msg -> msg_id = cpu_to_be16 ( HTC_MSG_CONNECT_SERVICE_ID ) ; conn_msg -> con_flags = cpu_to_be16 ( service_connreq -> con_flags ) ; conn_msg -> dl_pipeid = endpoint -> dl_pipeid ; conn_msg -> ul_pipeid = endpoint -> ul_pipeid ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret )",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> service_id ) ; kfree_skb ( skb ) ;\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> service_id ) ; kfree_skb ( skb ) ;\n"
  },
  {
    "id": 698,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void cisco_autorp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) { int type ; int numrps ; int hold ; <vul-start> ND_TCHECK ( bp [ 0 ] ) ; <vul-end> ND_PRINT ( ( ndo , \" auto-rp \" ) ) ; type = bp [ 0 ] ; switch ( type ) { case 0x11 : ND_PRINT ( ( ndo , \"candidate-advert\" ) ) ; break ; case 0x12 : ND_PRINT ( ( ndo , \"mapping\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"type-0x%02x\" , type ) ) ; break ; } ND_TCHECK ( bp [ 1 ] ) ; numrps = bp [ 1 ] ; ND_TCHECK2 ( bp [ 2 ] , 2 ) ; ND_PRINT ( ( ndo , \" Hold \" ) ) ; hold = EXTRACT_16BITS ( & bp [ 2 ] ) ; if ( hold ) unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; else ND_PRINT ( ( ndo , \"FOREVER\" ) ) ; bp += 8 ; len -= 8 ; while ( numrps -- ) { int nentries ; char s ; <vul-start> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <vul-end> ND_PRINT ( ( ndo , \" RP %s\" , ipaddr_string ( ndo , bp ) ) ) ; <vul-start> ND_TCHECK ( bp [ 4 ] ) ; <vul-end> <vul-start> switch ( bp [ 4 ] & 0x3 ) { <vul-end> case 0 : ND_PRINT ( ( ndo , \" PIMv?\" ) ) ; break",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> int hold ; if ( len < 8 ) goto trunc ; <vul-start> char s ; if ( len < 4 ) goto trunc ; <vul-start> ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <vul-start> ( bp [ 0 <vul-end> ] ) ; <vul-start> ( bp [ 0 <vul-end> ] & 0x3 <vul-start> ( bp [ 0 <vul-end> ] & 0xfc <vul-start> , bp [ 0 <vul-end> ] & 0xfc <vul-start> ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <vul-start> ( bp [ 0 <vul-end> ] ) ; <vul-start> = bp [ 0 <vul-end> ] ; bp <vul-start> ; bp += 1 ; len -= 1 <vul-end> ; s = <vul-start> -- ) { if ( len < 6 ) goto trunc ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int hold ; u_int offs ; <vul-start> char s ; offs = len ; <vul-start> ) ) ; offs += 4 <vul-end> ; switch ( <vul-start> ; switch ( ( bp [ 4 ] & 0x3 ) ) { case 0 : ND_PRINT ( ( ndo, \" PIMv?\" ) ) ; break ; case 1 : ND_PRINT ( ( ndo, \" bidir\" ) ) ; break ; case 2 : ND_PRINT ( ( ndo, \" bidir+2\" ) ) ; break ; case 3 : ND_PRINT ( ( ndo, \" [rsvd=0x%02x]\", bp [ 4 ] & 0xfc ) ) ; bp += 4 ; len -= 4 ; s ='' ; for ( ; nentries ; nentries -- ) { ND_TCHECK2 ( bp [ 0 ], 6 ) ; ND_PRINT ( ( ndo, \"%c%s%s/%d\", s, bp [ 0 ] & 1? \"!\" : \"\", ipaddr_string ( ndo, & bp [ 2 ] ), bp [ 1 ] ) ) ; if ( bp [ 0 ] & 0x02 ) { ND_PRINT ( ( ndo, \" bidir\" ) ) ; } if ( bp [ 0 ] & 0xfc ) { ND_PRINT ( ( ndo, \"[rsvd=0x%02x]\", bp [ 0 ] & 0xfc ) ) ; } s = ',' ; bp += 6 ; len -= 6 ; } } return ; trunc : ND_PRINT ( ( ndo, \"[|autorp]\" ) ) ; bp += 6 ; len -= 6 ; s ='' ; for ( ; nentries ; nentries -- ) { ND_TCHECK2 ( bp [ 0 ], 6 ) ; ND_PRINT ( ( ndo, \"%c%s%s/%d\", s, bp [ 0 ] & 1? \"!\" : \"\", ipaddr_string ( ndo, & bp [ 2 ] ), bp [ 1 ] ) ) ; if ( bp [ 0 ] & 0x02 ) { ND_PRINT ( ( ndo, \" bidir\" ) ) ; } if ( bp [ 0 ] & 0xfc ) { ND_PRINT ( ( ndo, \"[rsvd=0x%02x]\""
  },
  {
    "id": 699,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> num < 0 || num >= 256\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> num < 0 || num >= 256\n"
  },
  {
    "id": 700,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_close_prepare ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; int clear_rd , clear_wr , clear_rdwr ; if ( nfs_wait_on_sequence ( calldata -> arg . seqid , task ) != 0 ) return ; clear_rd = clear_wr = clear_rdwr = 0 ; spin_lock ( & state -> owner -> so_lock ) ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { clear_rd |= test_and_clear_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { clear_wr |= test_and_clear_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } } spin_unlock ( & state -> owner -> so_lock ) ; if ( ! clear_rd && ! clear_wr && ! clear_rdwr ) { task -> tk_action = NULL ; return ; } nfs_fattr_init ( calldata -> res . fattr ) ; if ( test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ; <vul-start> calldata -> arg . open_flags = FMODE_READ ; <vul-end> } else if ( test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ; <vul-start> calldata -> arg . open_flags = FMODE_WRITE ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> = FMODE_READ ; <vul-start> -> arg . fmode <vul-end> = FMODE_WRITE ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> NFSPRO4_CLNT_OPEN_DOWNGRADE ] ; set_bit ( NFS_O_RDONLY, & state -> flags ) ; <vul-start> NFSPRO4_CLNT_OPEN_DOWNGRADE ] ; set_bit ( NFS_O_WRONLY, & state -> flags ) ;\n"
  },
  {
    "id": 701,
    "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image <vul-start> * image ; <vul-end> MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , <vul-start> padding , <vul-end> value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , \"#define %32s %u\" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name",
    "golden_answers": [
      "CWE-834 Fixed Code Lines are: <vul-start> Image * image ; int c <vul-start> length , padding <vul-end> , version , <vul-start> ) ) { c <vul-end> = XBMInteger ( <vul-start> , hex_digits ) ; if ( c < 0 ) break <vul-start> unsigned char ) c <vul-end> ; if ( <vul-start> char ) ( c <vul-end> >> 8 ) <vul-start> hex_digits ) ; if ( c < 0 ) break ; <vul-start> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) <vul-end> ; } p <vul-start> byte = ( unsigned int <vul-end> ) ( *\n"
    ],
    "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> Image * image ; ImageList * list <vul-start> length, padding ; short int value <vul-start> version, width ; list = ( ImageList * ) NULL <vul-start> ; if ( ( list!= ( ImageList * ) NULL ) && ( <vul-start> )!= ( ImageList * ) NULL ) ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( data == ( <vul-start> ) NULL ) break ; } if ( ( list!= ( ImageList * ) NULL ) && ( <vul-end> value!= ( <vul-start> version!= ( ImageList * ) NULL ) ) { data = RelinquishMagickMemory ( data ) ; if ( data == ( ImageList * ) NULL ) break ; } if ( ( data!= ( ImageList * ) NULL ) <vul-start> ) ; } if ( list!= ( ImageList * ) NULL ) { RelinquishMagickMemory ( data ) ; }\n"
  },
  {
    "id": 702,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ; <vul-start> } <vul-end>",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ) break ; <vul-end> tp -> copied_seq <vul-start> = seq ; } tp -> copied_seq = seq ;\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) break ; if (! desc -> count ) break ; <vul-start> = seq ; if ( copied > 0 )\n"
  },
  {
    "id": 703,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( \"-->%s()\\\\n\" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } <vul-start> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <vul-end> pr_devel ( \"replace in slot %d\\\\n\" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( \"<--%s() = ok [replace]\\\\n\" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( \"insert in free slot %d\\\\n\" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( \"<--%s() =",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> } if ( assoc_array_ptr_is_leaf ( ptr ) &&\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( assoc_array_ptr_is_leaf ( ptr ) &&\n"
  },
  {
    "id": 704,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , \"plain\" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && *",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <vul-end> ; } else\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> sasl_password ) { if ( conn -> sasl_username!= NULL ) { g_free ( conn -> sasl_username ) ; conn -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; }\n"
  },
  {
    "id": 705,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , \"imap@%s\" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , \"Couldn\\'t get service name for [%s]\\\\n\" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , \"Using service name [%s]\\\\n\" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int *",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> buf + 2 , sizeof ( buf2 ) <vul-start> buf + 2 , sizeof ( buf2 )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> bail ; } if ( request_buf. length < 0 ) { mutt_debug ( 1, \"Invalid AUTH line buffer length.\\\\n\" ) ; gss_release_buffer ( & min_stat, & send_token ) ; goto err_abort_cmd ; } <vul-start> bail ; } if ( request_buf. length < 0 ) { mutt_debug ( 1, \"Invalid AUTH line buffer length.\\\\n\" ) ; gss_release_buffer ( & min_stat, & send_token ) ; goto err_abort_cmd ; }\n"
  },
  {
    "id": 706,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <vul-start> int ret = 0 ; <vul-end> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ret = 0 ; if (! key_check_positive ( key, prep ) ) return - EINVAL\n"
  },
  {
    "id": 707,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , \"DSD \" , 4 ) ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( \"%s is not a valid .DFF file (by total size)!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"file header indicated length = %lld\" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"got PROP chunk of %d bytes total\" , ( int ) dff_chunk_header . ckDataSize ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> * prop_chunk = calloc ( <vul-end> ( size_t )\n"
  },
  {
    "id": 708,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void filter_selectively_horiz ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; int count ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= count ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; count = 1 ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { if ( ( mask_16x16 & 3 ) == 3 ) { <vul-start> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , 2 ) ; count = 2 ; } else { <vul-start> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , 1 ) ; } } else if ( mask_8x8 & 1 ) { if ( ( mask_8x8 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; <vul-start> vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { <vul-start> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <vul-end> lfi -> lim , lfi -> hev_thr , lfin ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 3 ) { vpx_lpf_horizontal_16 <vul-end> ( s , <vul-start> } else { vpx_lpf_horizontal_16 <vul-end> ( s , <vul-start> 1 ) ; vpx_lpf_horizontal_8_dual <vul-end> ( s , <vul-start> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> 1 ) ; vpx_lpf_horizontal_4_dual <vul-end> ( s , <vul-start> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <vul-end> ( s +\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 3 ) { vpx_lpf_horizontal_16 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_16 <vul-end> ( s, <vul-start> 1 ) ; vpx_lpf_horizontal_8_dual <vul-end> ( s, <vul-start> 3 ) { vpx_lpf_horizontal_4_dual <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_8 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_8 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_4 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_4 <vul-end> ( s,\n"
  },
  {
    "id": 709,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) { jpc_siz_t * siz ; jpc_cod_t * cod ; jpc_qcd_t * qcd ; int i ; long startoff ; long mainhdrlen ; jpc_enc_cp_t * cp ; jpc_qcc_t * qcc ; jpc_enc_tccp_t * tccp ; uint_fast16_t cmptno ; jpc_tsfb_band_t bandinfos [ JPC_MAXBANDS ] ; jpc_fix_t mctsynweight ; jpc_enc_tcp_t * tcp ; jpc_tsfb_t * tsfb ; jpc_tsfb_band_t * bandinfo ; uint_fast16_t numbands ; uint_fast16_t bandno ; uint_fast16_t rlvlno ; uint_fast16_t analgain ; jpc_fix_t absstepsize ; char buf [ 1024 ] ; jpc_com_t * com ; cp = enc -> cp ; startoff = jas_stream_getrwcount ( enc -> out ) ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOC ) ) ) { return - 1 ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( \"cannot write SOC marker\\\\n\" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SIZ ) ) ) { return - 1 ; } siz = & enc -> mrk -> parms . siz ; siz -> caps = 0 ; siz -> xoff = cp -> imgareatlx ; siz -> yoff = cp -> imgareatly ; siz -> width = cp -> refgrdwidth ; siz -> height = cp -> refgrdheight ; siz -> tilexoff = cp -> tilegrdoffx ; siz -> tileyoff = cp -> tilegrdoffy ; siz -> tilewidth = cp -> tilewidth ; siz ->",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> = JAS_CAST ( jas_uchar <vul-end> * , jas_strdup\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = JAS_CAST ( jas_uchar <vul-end> *, jas_strdup\n"
  },
  {
    "id": 710,
    "question": "CWE-755 Code Input Vulnerable Code Is: CWE-755 int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { int rc = SQLITE_OK ; if ( p -> pWin && p -> pPrior == 0 && ( p -> selFlags & SF_WinRewrite ) == 0 ) { Vdbe * v = sqlite3GetVdbe ( pParse ) ; sqlite3 * db = pParse -> db ; Select * pSub = 0 ; SrcList * pSrc = p -> pSrc ; Expr * pWhere = p -> pWhere ; ExprList * pGroupBy = p -> pGroupBy ; Expr * pHaving = p -> pHaving ; ExprList * pSort = 0 ; ExprList * pSublist = 0 ; Window * pMWin = p -> pWin ; Window * pWin ; Table * pTab ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) { <vul-start> return SQLITE_NOMEM ; <vul-end> } p -> pSrc = 0 ; p -> pWhere = 0 ; p -> pGroupBy = 0 ; p -> pHaving = 0 ; p -> selFlags &= ~ SF_Aggregate ; p -> selFlags |= SF_WinRewrite ; pSort = sqlite3ExprListDup ( db , pMWin -> pPartition , 0 ) ; pSort = exprListAppendList ( pParse , pSort , pMWin -> pOrderBy , 1 ) ; if ( pSort && p -> pOrderBy && p -> pOrderBy -> nExpr <= pSort -> nExpr ) { int nSave = pSort -> nExpr ; pSort -> nExpr = p -> pOrderBy -> nExpr ; if ( sqlite3ExprListCompare ( pSort , p -> pOrderBy , - 1 ) == 0 )",
    "golden_answers": [
      "CWE-755 Fixed Code Lines are: <vul-start> ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <vul-end> ; } p <vul-start> ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }\n"
    ],
    "generated_answer": "CWE-755 Fixed Code Lines are: <vul-start> ) { return SQLITE_NOMEM_BKPT <vul-end> ; } p <vul-start> ) ; } if ( p -> pTab ) sqlite3VdbeAddOp ( v, OP_Close, 0, p -> pTab -> a [ 0 ] -> selFlags ) ;\n"
  },
  {
    "id": 711,
    "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( \"+\" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , ' ' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == ' ' ) pos_args ++ ; argv = weechat_string_split ( pos_args , \" \" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\\\0' ; new_args [ 0",
    "golden_answers": [
      "CWE-120 Fixed Code Lines are: <vul-start> chanmode ) { if ( ! chanmode_found ) { <vul-start> } } } }\n"
    ],
    "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> chanmode ) { <vul-end> if ( set_flag <vul-start> } } } chanmode_found = 1 ;\n"
  },
  {
    "id": 712,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { FILE * infile , * outfile [ NUM_ENCODERS ] ; <vul-start> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; <vul-end> vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ; <vul-start> vpx_codec_pts_t frame_cnt = 0 ; <vul-end> vpx_image_t raw [ NUM_ENCODERS ] ; vpx_codec_err_t res [ NUM_ENCODERS ] ; int i ; long width ; long height ; <vul-start> int frame_avail ; <vul-end> int got_data ; int flags = 0 ; <vul-start> int arg_deadline = VPX_DL_REALTIME ; <vul-end> int show_psnr = 0 ; <vul-start> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; <vul-end> uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ; <vul-start> int psnr_count [ NUM_ENCODERS ] = { 0 } ; <vul-end> unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ; <vul-start> if ( argc != ( 5 + NUM_ENCODERS ) ) <vul-end> <vul-start> die ( \"Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\\\\n\" , <vul-end> argv [ 0 ] ) ; printf ( \"Using %s\\\\n\" , vpx_codec_iface_name ( interface ) ) ; width = strtol ( argv [ 1 ] , NULL , 0 ) ; <vul-start> height = strtol ( argv [ 2 ] , NULL , 0 ) ; <vul-end> if ( width < 16 || width",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> NUM_ENCODERS ] ; FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ; <vul-start> NUM_ENCODERS ] ; int <vul-end> frame_cnt = 0 <vul-start> height ; int length_frame ; int <vul-start> 0 ; int layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int <vul-start> = 0 ; int key_frame_insert = 0 ; <vul-start> { 0 } ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv <vul-start> } } ; unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; <vul-start> argc != ( 7 + 3 * <vul-end> NUM_ENCODERS ) ) <vul-start> ) die ( \"Usage: %s <width> <height> <frame_rate>  <infile> <outfile(s)> \" \"<rate_encoder(s)> <temporal_layer(s)> <key_frame_insert> <output psnr?> \\\\n\" <vul-end> , argv [ <vul-start> argv [ 2 ] , NULL , 0 ) ; framerate = strtol ( argv [ 3 <vul-start> ( argv [ 4 <vul-end> ] , \"rb\" <vul-start> , argv [ 4 <vul-end> ] ) ; <vul-start> [ i + 5 <vul-end> ] , \"wb\" <vul-start> ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ] <vul-end> = strtol ( <vul-start> [ NUM_ENCODERS + 5 + i <vul-end> ] , NULL <vul-start> 0 ) ; } <vul-start> ++ ) { num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( \"Invalid temporal layers: %d, Must be 1, 2, or 3. \\\\n\" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , \"ds%d.yuv\" , NUM_ENCODERS - i ) < 0 ) { <vul-end> return EXIT_FAILURE ; <vul-start> EXIT_FAILURE ; } downsampled_input [ i ] = fopen ( filename , \"wb\" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( \"Failed to get config: %s\\\\n\" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <vul-start> 0 ] . rc_dropframe_thresh = 0 <vul-end> ; cfg [ <vul-start> . rc_min_quantizer = 2 <vul-end> ; cfg [ <vul-start> . rc_undershoot_pct = 100 <vul-end> ; cfg [ <vul-start> . rc_overshoot_pct = 15 <vul-end> ; cfg [ <vul-start> vpx_codec_enc_cfg_t ) ) <vul-end> ; cfg [ <vul-start> ++ ; } cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ; <vul-start> 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; } <vul-start> ; if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; if ( <vul-start> ] , \"Failed to set cpu_used\" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , \"Failed to set static threshold\" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , \"Failed to set noise_sensitivity\" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , \"Failed to set noise_sensitivity\" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , \"Failed to set static threshold\" <vul-start> { unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) <vul-end> ; if ( <vul-start> i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct <vul-end> ) ) die_codec <vul-start> ] , \"Failed to set static threshold\" <vul-end> ) ; } <vul-start> 1 ) ; length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ; <vul-end> if ( vpx_codec_encode <vul-start> , 1 , 0 <vul-end> , arg_deadline ) <vul-start> arg_deadline ) ) { <vul-start> ] , \"Failed to encode frame\" ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec <vul-start> ? \"K\" : \"\" <vul-end> ) ; fflush <vul-start> printf ( \"\\\\n\" ) ; printf ( \"FPS for encoding %d %f %f \\\\n\" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; vpx_codec_enc_cfg_t cfg <vul-start> ; vpx_codec_pts_t frame_cnt [ NUM_ENCODERS ] ; vpx_codec_pts_t frame_shift <vul-start> ; int frame_avail ; int got_data ; int arg_deadline = VPX_DL_REALTIME ; int show_psnr [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_samples_total [ NUM_ENCODERS ] = { 0, 0 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] ; int i ; long target_bitrate [ NUM_ENCODERS ] ; int framerate = 30 ; vpx_rational_t dsf_default [ NUM_ENCODERS ] ; int i ; long target_bitrate [ NUM_ENCODERS ] ; int i ; long width ; long height ; long frame_shift ; int flags = 0 ; int arg_deadline = VPX_DL_REALTIME ; int show_psnr = 0 ; int psnr_sse_total [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int framerate = 30 ; vpx_rational_t dsf_default [ NUM_ENCODERS ] ; int i ; int i ; long width ; long height ; long height ; long width ; long height ; int flags ; int arg_deadline = VPX_DL_REALTIME ; int show_psnr = 0 ; int psnr_sse_total [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0, 0 } ; int psnr_count [ NUM_ENCODERS ] = { 0,"
  },
  {
    "id": 713,
    "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 void test_parser ( void ) { <vul-start> int i , retval ; <vul-end> bzrtpPacket_t * zrtpPacket ; bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ; bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ; context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256",
    "golden_answers": [
      "CWE-254 Fixed Code Lines are: <vul-start> void ) { test_parser_param ( <vul-end> 0 ) ; <vul-start> ) ; } <vul-end>      \n"
    ],
    "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> i, retval ; int num = 0 <vul-start> 0 ) ; num ++ ; <vul-start> ) ; } if ( retval!= 0 ) { CU_FAIL ( \"Unable to build packet\" ) ; }\n"
  },
  {
    "id": 714,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <vul-start> number_threads ; <vul-end> <vul-start> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <vul-end> <vul-start> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <vul-end> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <vul-start> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <vul-end> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <vul-start> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <vul-end> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <vul-end> ( size_t ) <vul-start> ( ThreadResource ) ) <vul-start> ) AcquireQuantumMemory ( rows , <vul-end> sizeof ( * <vul-start> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <vul-end> ; i < <vul-start> ( ssize_t ) rows <vul-end> ; i ++\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_t columns, rows ; rows = MagickMax ( GetImageListLength ( images ), <vul-end> ( size_t ) <vul-start> ( ThreadResource ) ) <vul-start> ) AcquireQuantumMemory ( rows, <vul-end> sizeof ( * <vul-start> NULL ) ; columns = images -> columns ; for ( next = images ; next!= ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns, columns ) ; for ( i = 0 <vul-end> ; i < <vul-start> ( ssize_t ) rows <vul-end> ; i ++\n"
  },
  {
    "id": 715,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; struct rds_transport * otrans = trans ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) goto new_conn ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; new_conn : conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR (",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; } } if (! trans ) { kmem_cache_free ( rds_conn_slab, conn ) ; conn = ERR_PTR ( - EINVAL ) ; goto out ; }\n"
  },
  {
    "id": 716,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int http_connect ( http_subtransport * t ) { int error ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , \"git_stream\" ) ; apply_proxy_config ( t ) ; error = git_stream_connect ( t -> io ) ; if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <vul-start> int is_valid ; <vul-end> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <vul-start> giterr_clear ( ) ; <vul-end> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; int is_valid = ( error == GIT_OK ) <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> * cert ; <vul-end> if ( ( <vul-start> return error ; <vul-end> error = t\n"
  },
  {
    "id": 717,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , \" who-are-you request\" ) ) ; break ; } ND_PRINT ( ( ndo , \" node information query\" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , \" (\" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , \"noop\" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , \"supported qtypes\" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , \" [%s]\" , ( i & 0x01 ) ? \"C\" : \"\" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , \"DNS name\" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , \"node addresses\" ) ) ; i",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <vul-start> ) + 4 ; ND_TCHECK ( cp [ 0 ] )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> icmp6_nodeinfo * ) ( dp + 1 ) <vul-end> ; ND_PRINT ( <vul-start> ; ND_PRINT ( ( ndo, \"%s\", <vul-end> icmp6_tstr ) ) <vul-start> ; ND_PRINT ( ( ndo, \"%s\", <vul-end> icmp6_tstr ) )\n"
  },
  {
    "id": 718,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int Unpickler_set_memo ( UnpicklerObject * self , PyObject * obj ) { PyObject * * new_memo ; <vul-start> Py_ssize_t new_memo_size = 0 ; <vul-end> Py_ssize_t i ; if ( obj == NULL ) { PyErr_SetString ( PyExc_TypeError , \"attribute deletion is not supported\" ) ; return - 1 ; } if ( Py_TYPE ( obj ) == & UnpicklerMemoProxyType ) { UnpicklerObject * unpickler = ( ( UnpicklerMemoProxyObject * ) obj ) -> unpickler ; new_memo_size = unpickler -> memo_size ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; <vul-start> for ( i = 0 ; i < new_memo_size ; i ++ ) { <vul-end> Py_XINCREF ( unpickler -> memo [ i ] ) ; new_memo [ i ] = unpickler -> memo [ i ] ; } } else if ( PyDict_Check ( obj ) ) { Py_ssize_t i = 0 ; PyObject * key , * value ; new_memo_size = PyDict_GET_SIZE ( obj ) ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; while ( PyDict_Next ( obj , & i , & key , & value ) ) { Py_ssize_t idx ; if ( ! PyLong_Check ( key ) ) { PyErr_SetString ( PyExc_TypeError , \"memo key must be integers\" ) ; goto error ; } idx = PyLong_AsSsize_t ( key ) ; if ( idx == - 1 && PyErr_Occurred ( ) ) goto error ; if ( idx < 0 ) { PyErr_SetString ( PyExc_ValueError , \"memo key must be positive",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * new_memo ; size_t new_memo_size = 0 <vul-end> ; if ( <vul-start> ; for ( size_t <vul-start> new_memo_size ) { for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i -- <vul-end> ) { Py_XDECREF\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; Py_ssize_t new_memo_size = 0 ; Py_ssize_t memo_size <vul-start> - 1 ; memo_size = PyDict_GET_SIZE ( obj ) ; if ( memo_size < 0 ) { PyErr_SetString ( PyExc_ValueError, \"memo key must be negative\" ) ; return - 1 ; } <vul-start> new_memo_size ) { if ( memo_size < 0 ) { Py_XDECREF ( unpickler -> memo [ memo_size ] ) ; new_memo [ memo_size ] = unpickler -> memo [ memo_size ] ; }\n"
  },
  {
    "id": 719,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int send_parameters ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; j = cJSON_CreateObject ( ) ; if ( j == NULL ) { i_errno = IESENDPARAMS ; r = - 1 ; } else { if ( test -> protocol -> id == Ptcp ) cJSON_AddTrueToObject ( j , \"tcp\" ) ; else if ( test -> protocol -> id == Pudp ) cJSON_AddTrueToObject ( j , \"udp\" ) ; <vul-start> cJSON_AddIntToObject ( j , \"omit\" , test -> omit ) ; <vul-end> if ( test -> server_affinity != - 1 ) <vul-start> cJSON_AddIntToObject ( j , \"server_affinity\" , test -> server_affinity ) ; <vul-end> if ( test -> duration ) cJSON_AddIntToObject ( j , \"time\" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddIntToObject ( j , \"num\" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddIntToObject ( j , \"blockcount\" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddIntToObject ( j , \"MSS\" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , \"nodelay\" ) ; cJSON_AddIntToObject ( j , \"parallel\" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , \"reverse\" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddIntToObject ( j , \"window\" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddIntToObject ( j , \"len\"",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> \"udp\" ) ; cJSON_AddNumberToObject <vul-end> ( j , <vul-start> - 1 ) cJSON_AddNumberToObject ( j , \"server_affinity\" , test -> server_affinity ) ; if ( test -> duration ) cJSON_AddNumberToObject ( j , \"time\" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j , \"num\" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j , \"blockcount\" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddNumberToObject ( j , \"MSS\" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , \"nodelay\" ) ; cJSON_AddNumberToObject ( j , \"parallel\" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , \"reverse\" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j , \"window\" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j , \"len\" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddNumberToObject ( j , \"bandwidth\" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddNumberToObject ( j , \"burst\" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddNumberToObject ( j , \"TOS\" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddNumberToObject ( j , \"flowlabel\" , test -> settings -> flowlabel ) ; if ( test -> title ) cJSON_AddStringToObject ( j , \"title\" , test -> title ) ; if ( test -> congestion ) cJSON_AddStringToObject ( j , \"congestion\" , test -> congestion ) ; if ( test -> get_server_output ) << << << < HEAD <vul-start> ( j , \"get_server_output\" , iperf_get_test_get_server_output ( test ) ) ; == == == = cJSON_AddNumberToObject ( j , \"get_server_output\" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , \"udp_counters_64bit\" , iperf_get_test_udp_counters_64bit ( test ) ) ; if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , \"no_fq_socket_pacing\" , iperf_get_no_fq_socket_pacing ( test ) ) ; <vul-end> cJSON_AddStringToObject ( j <vul-start> ( j , \"client_version\" , IPERF_VERSION ) ; >> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a <vul-end> if ( test\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"udp\" ) ; if ( test -> settings -> num_temporal_layers ) cJSON_AddNumberToObject ( j, \"num_temporal_layers\", test -> settings -> num_temporal_layers ) ; <vul-start> test -> server_affinity ) ; if ( test -> settings -> addr_format ) cJSON_AddNumberToObject ( j, \"addr_format\", test -> settings -> addr_format\n"
  },
  {
    "id": 720,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <vul-start> spin_lock_irq ( & tu -> qlock ) ; <vul-end> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <vul-start> schedule ( ) ; <vul-end> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <vul-start> mutex_lock ( & tu -> ioctl_lock ) ; <vul-end> if ( tu -> tread ) { if ( copy_to_user (",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <vul-end> ) ; spin_lock_irq <vul-start> qlock ) ; <vul-end> if ( tu <vul-start> EFAULT ; } <vul-end> spin_lock_irq ( & <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; mutex_lock ( & tu -> ioctl_lock ) ; <vul-start> result > 0 && mutex_lock ( & tu -> ioctl_lock )\n"
  },
  {
    "id": 721,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 xmlAttrPtr xsltAttrTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attr ) { const xmlChar * value ; xmlAttrPtr ret ; if ( ( ctxt == NULL ) || ( attr == NULL ) || ( target == NULL ) ) return ( NULL ) ; if ( attr -> type != XML_ATTRIBUTE_NODE ) return ( NULL ) ; # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) return ( NULL ) ; # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) return ( NULL ) ; # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: The children of an attribute node of a \" \"literal result element are not in the expected form.\\\\n\" ) ; return ( NULL ) ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ; ret = target -> properties ; while ( ret != NULL ) { if ( ( ( attr -> ns != NULL ) == ( ret -> ns != NULL ) ) && xmlStrEqual ( ret -> name , attr -> name ) && ( (",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> -> dict ) && xmlDictOwns ( ctxt -> dict , value )\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> dict ) && xmlDictOwns ( ctxt -> dict, value )\n"
  },
  {
    "id": 722,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static NPError g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( \"NPN_GetValue instance=%p, variable=%d [%s]\\\\n\" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( \"WARNING: NPN_GetValue not called from the main thread\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; # if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( \"WARNING: NS_GetServiceManager failed\\\\n\" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( \"WARNING: %s is not supported by NPN_GetValue()\\\\n\" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; # endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( \"ERROR: NPNVnetscapeWindow requires a non NULL instance\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR )",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NPNVPluginElementNPObject : return g_NPN_GetValue <vul-end> ( instance,\n"
  },
  {
    "id": 723,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> u1_num_mbs ++ ; <vul-end> u1_num_mbs_next = i2_pic_wdin_mbs <vul-start> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> u2_total_mbs_coded ++ ; ps_dec -> ps_dpb_cmds -> u2_total_mbs_coded += u1_num_mbs <vul-start> ) ; } ps_dec -> ps_dpb_cmds -> u2_total_mbs_coded += u1_num_mbs ;\n"
  },
  {
    "id": 724,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <vul-start> memcpy ( new , ours , sizeof ( * new ) ) ; <vul-end> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , \"X.25: rejecting reverse charging request\\\\n\" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , \"X.25: inbound throughput negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , \"X.25: outbound throughput negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; memset ( new -> facilities, 0, sizeof ( theirs ) ) ;\n"
  },
  {
    "id": 725,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <vul-start> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <vul-end> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> c -> tile_width <vul-end> , 16 ) <vul-start> , 16 ) * 3\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> c -> tile_width + 15 <vul-end>, 16 )\n"
  },
  {
    "id": 726,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( \"begin processing:\\\\n\" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest ->",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ) == 0 && p -> pWin == 0\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ) == 0 && p -> selFlags & SF_Distinct\n"
  },
  {
    "id": 727,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"nreslevels %d is invalid\\\\n\" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"cblk size invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <vul-start> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <vul-end> if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"extra cblk styles %X\\\\n\" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , \"cblk size > 64\" ) ; return AVERROR_PATCHWELCOME ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> s -> g ) ; if ( c -> cblk_style == 0 && c -> log2_cblk_width > c -> max_width || c -> log2_cblk_height > c -> max_height ) { av_log ( s -> avctx, AV_LOG_ERROR, \"cblk size invalid\\\\n\"\n"
  },
  {
    "id": 728,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col , <vul-start> BLOCK_SIZE bsize , int use_rd ) { <vul-end> const VP9_COMMON * const cm = & cpi -> common ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; const int block_index = mi_row * cm -> mi_cols + mi_col ; <vul-start> const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ; <vul-end> int new_map_value = cr -> map [ block_index ] ; int x = 0 ; int y = 0 ; <vul-start> if ( mbmi -> segment_id > 0 && ! refresh_this_block ) <vul-end> mbmi -> segment_id = 0 ; <vul-start> if ( mbmi -> segment_id == 1 ) { <vul-end> new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] == 1 ) new_map_value = 0 ; } else { new_map_value = 1 ; } for ( y = 0 ; y < ymis ; y ++ ) for ( x = 0 ; x < xmis ; x ++ ) { <vul-start> cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; <vul-end> <vul-start> cpi -> segmentation_map [ block_index +",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip <vul-end> ) { const <vul-start> , mbmi , rate , dist , bsize <vul-end> ) ; int <vul-start> ; if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] <vul-end> == 1 ) <vul-start> == 1 ) <vul-end> new_map_value = 0 <vul-start> ++ ) { int map_offset = <vul-end> block_index + y <vul-start> mi_cols + x ; cr -> map [ map_offset <vul-start> -> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <vul-end> }    \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, BLOCK_SIZE bsize <vul-end> ) { const <vul-start>, mbmi, mi_col, <vul-start> ; if ( cpi <vul-end> -> segment_id > <vul-start> > 0 && cpi <vul-end> -> segment_id == <vul-start> ; if ( cpi <vul-end> -> segment_id == <vul-start> ++ ) { cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = mbmi -> segment_id ; } for ( y = 0 ; y < ymis ; y ++ ) { <vul-start> = new_map_value ; } <vul-end> } if (\n"
  },
  {
    "id": 729,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 struct tcp_sock_t * tcp_open ( uint16_t port ) { struct tcp_sock_t * this = calloc ( 1 , sizeof * this ) ; if ( this == NULL ) { <vul-start> ERR ( \"callocing this failed\" ) ; <vul-end> goto error ; } this -> sd = - 1 ; <vul-start> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <vul-end> if ( this -> sd < 0 ) { <vul-start> ERR ( \"sockect open failed\" ) ; <vul-end> goto error ; } struct sockaddr_in6 addr ; memset ( & addr , 0 , sizeof addr ) ; <vul-start> addr . sin6_family = AF_INET6 ; <vul-end> addr . sin6_port = htons ( port ) ; <vul-start> addr . sin6_addr = in6addr_any ; <vul-end> if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) { if ( g_options . only_desired_port == 1 ) <vul-start> ERR ( \"Bind on port failed. \" <vul-end> \"Requested port may be taken or require root permissions.\" ) ; goto error ; } if ( listen ( this -> sd , HTTP_MAX_PENDING_CONNS ) < 0 ) { <vul-start> ERR ( \"listen failed on socket\" ) ; <vul-end> goto error ; } return this ; error : if ( this != NULL ) { if ( this -> sd != - 1 ) { close ( this -> sd ) ; } free ( this ) ; } return NULL ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> { ERR ( \"IPv4: callocing this failed\" <vul-end> ) ; goto <vul-start> = socket ( AF_INET <vul-end> , SOCK_STREAM , <vul-start> { ERR ( \"IPv4 socket open failed\" ) ; goto error ; } struct sockaddr_in <vul-end> addr ; memset <vul-start> ; addr . sin_family = AF_INET ; addr . sin_port <vul-end> = htons ( <vul-start> ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) <vul-end> ; if ( <vul-start> ) ERR ( \"IPv4 bind on port failed. \" <vul-end> \"Requested port may be taken or require root permissions.\" ) ; <vul-start> { ERR ( \"IPv4 listen failed on socket\" <vul-end> ) ; goto\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NULL ) { FATAL <vul-end> ( \"callocing this failed\" ) <vul-start> -> sd = TEMP_FAILURE_RETRY ( <vul-start>, SOCK_STREAM, IPPROTO_TCP ) ) <vul-end> ; } struct <vul-start> 0 ) { FATAL <vul-end> ( \"sockect open failed\" ) <vul-start> addr ) ; memset ( & addr, 0, sizeof addr ) ; <vul-start> sin6_addr = in6addr_any ; addr. sin6_family = AF_INET6 <vul-start> ) ERR ( \"Bind on port failed. \" \"Requested port may be taken or require root permissions.\" <vul-end> ) ; goto <vul-start> 0 ) { FATAL <vul-end> ( \"listen failed on socket\" )\n"
  },
  {
    "id": 730,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void freeClient ( redisClient * c ) { listNode * ln ; sdsfree ( c -> querybuf ) ; c -> querybuf = NULL ; if ( c -> flags & REDIS_BLOCKED ) unblockClientWaitingData ( c ) ; unwatchAllKeys ( c ) ; listRelease ( c -> watched_keys ) ; pubsubUnsubscribeAllChannels ( c , 0 ) ; pubsubUnsubscribeAllPatterns ( c , 0 ) ; dictRelease ( c -> pubsub_channels ) ; listRelease ( c -> pubsub_patterns ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_READABLE ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_WRITABLE ) ; listRelease ( c -> reply ) ; freeClientArgv ( c ) ; close ( c -> fd ) ; ln = listSearchKey ( server . clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . clients , ln ) ; if ( c -> flags & REDIS_IO_WAIT ) { <vul-start> redisAssert ( server . vm_enabled ) ; <vul-end> if ( listLength ( c -> io_keys ) == 0 ) { ln = listSearchKey ( server . io_ready_clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . io_ready_clients , ln ) ; } else { while ( listLength ( c -> io_keys ) ) { ln = listFirst ( c -> io_keys ) ; dontWaitForSwappedKey ( c , ln -> value ) ; } } <vul-start> server . vm_blocked_clients -- ; <vul-end> } listRelease ( c -> io_keys ) ; if ( c -> flags & REDIS_SLAVE ) { if",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( server . ds_enabled <vul-end> ) ; if <vul-start> } server . cache_blocked_clients <vul-end> -- ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( server. ds_enabled <vul-end> ) ; if <vul-start> } server. cache_blocked_clients <vul-end> -- ; }\n"
  },
  {
    "id": 731,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 <vul-start> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <vul-end> <vul-start> int length , int offset , int total_size ) <vul-end> { struct oz_port * port = hport ; struct urb * urb ; int err = 0 ; oz_dbg ( ON , \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\\\n\" , length , offset , total_size ) ; urb = oz_find_urb_by_id ( port , 0 , req_id ) ; if ( ! urb ) return ; if ( status == 0 ) { <vul-start> int copy_len ; <vul-end> <vul-start> int required_size = urb -> transfer_buffer_length ; <vul-end> if ( required_size > total_size ) required_size = total_size ; copy_len = required_size - offset ; if ( length <= copy_len ) copy_len = length ; memcpy ( urb -> transfer_buffer + offset , desc , copy_len ) ; offset += copy_len ; if ( offset < required_size ) { struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) ) err = - ENOMEM ; else if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) ) { oz_dequeue_ep_urb ( port , 0 , 0 , urb ) ; err = - ENOMEM ; } if ( err",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> u8 req_id , u8 <vul-end> status , const <vul-start> * desc , u8 length , u16 offset , u16 <vul-end> total_size ) { <vul-start> 0 ) { unsigned <vul-start> int copy_len ; unsigned\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> u8 req_id, u32 <vul-end> status, const <vul-start> * desc, u32 length, u32 offset, u32 <vul-end> total_size ) { <vul-start> 0 ) { u32 <vul-end> required_size = urb\n"
  },
  {
    "id": 732,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ...",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> vfio_irq_set hdr ; size_t size ; <vul-start> NULL ; int max , <vul-start> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <vul-start> - EINVAL ; <vul-end> max = vfio_pci_get_irq_count <vul-start> ; if ( <vul-end> hdr . start <vul-start> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> vfio_irq_set hdr ; struct vfio_device_set_args args = { 0 } ; <vul-start> ret = 0 ; int i <vul-start> VFIO_PCI_NUM_IRQS || hdr. argsz < 0 || hdr. argsz > VFIO_PCI_SET_ARGS_MAX ) return - EINVAL ; args. buf = ( void __user * ) arg ; if ( args <vul-start>. buf, args. buf, args. bufsz <vul-end> ) ) return\n"
  },
  {
    "id": 733,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ;",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( h_env -> envc >= MAX_ENVC ) { obuf -> in_under = 0 ; return 1 ; } if (\n"
  },
  {
    "id": 734,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <vul-start> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <vul-end> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> * F_SECT_PER_TRACK ; raw_cmd -> flags |= FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_SEEK ;\n"
  },
  {
    "id": 735,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <vul-start> if ( copy_from_user ( & sas , optval , len ) ) <vul-end> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <vul-start> -> rto_min ; <vul-end> if ( put_user\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, len ) || ( len > sizeof ( sas ) ) ) return - EINVAL ; if ( ( len > sizeof ( sas ) ) || ( sizeof ( sas ) > sizeof ( sas_stats_t ) ) <vul-start> -> rto_min ; if ( copy_to_user ( optval, & sas, sizeof ( sas ) ) ) return - EFAULT ;\n"
  },
  {
    "id": 736,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; int ret = - ENOMEM , i ; if ( npages == 0 ) npages = 1 ; if ( npages > ARRAY_SIZE ( pages ) ) return - ERANGE ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; dprintk ( \"%s buf %p buflen %zu npages %d args.acl_len %zu\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <vul-start> acl_len ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> acl_len ) ; <vul-end> _copy_from_pages ( buf <vul-start> acl_len ) ; if ( buf ) _copy_from_pages ( buf, pages, res. acl_data_offset, res. acl_len ) ;\n"
  },
  {
    "id": 737,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; <vul-start> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <vul-end> ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <vul-start> copy_from_user ( buf + sizeof ( hdr ) <vul-start> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <vul-end> ) ) {\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( hdr. size_in > size ) { ret = - EINVAL ; goto out ; } if (\n"
  },
  {
    "id": 738,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <vul-end> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , *",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> , message ) \\\\\\n{ <vul-end> if ( info <vul-start> ) ) ; \\\\\\n} <vul-end> char explicit_vr [ <vul-start> break ; } if ( <vul-end> fputc ( c <vul-start> , file ) != c ) break\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, message ) \\\\\\n{ <vul-end> if ( info <vul-start> ) ) ; \\\\\\n} <vul-end> char explicit_vr [ <vul-start> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError, \"InsufficientImageDataInFile\" ) ; if (\n"
  },
  {
    "id": 739,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static rfbBool webSocketsHandshake ( rfbClientPtr cl , char * scheme ) { char * buf , * response , * line ; int n , linestart = 0 , len = 0 , llen , base64 = TRUE ; char prefix [ 5 ] , trailer [ 17 ] ; char * path = NULL , * host = NULL , * origin = NULL , * protocol = NULL ; char * key1 = NULL , * key2 = NULL , * key3 = NULL ; char * sec_ws_origin = NULL ; char * sec_ws_key = NULL ; char sec_ws_version = 0 ; ws_ctx_t * wsctx = NULL ; buf = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! buf ) { rfbLogPerror ( \"webSocketsHandshake: malloc\" ) ; return FALSE ; } response = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! response ) { free ( buf ) ; rfbLogPerror ( \"webSocketsHandshake: malloc\" ) ; return FALSE ; } while ( len < WEBSOCKETS_MAX_HANDSHAKE_LEN - 1 ) { if ( ( n = rfbReadExactTimeout ( cl , buf + len , 1 , WEBSOCKETS_CLIENT_SEND_WAIT_MS ) ) <= 0 ) { if ( ( n < 0 ) && ( errno == ETIMEDOUT ) ) { break ; } if ( n == 0 ) rfbLog ( \"webSocketsHandshake: client gone\\\\n\" ) ; else rfbLogPerror ( \"webSocketsHandshake: read\" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } len += 1 ; llen = len - linestart ; if ( (",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> = base64 ; hybiDecodeCleanup ( wsctx ) ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = base64 ; wsctx -> wsctx_flags |= WS_CTX_NOREF ;\n"
  },
  {
    "id": 740,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <vul-end> put_page ( page\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ptl ) ; <vul-end> if ( vm_shared\n"
  },
  {
    "id": 741,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int csnmp_read_table ( host_definition_t * host , data_definition_t * data ) { struct snmp_pdu * req ; struct snmp_pdu * res = NULL ; struct variable_list * vb ; const data_set_t * ds ; size_t oid_list_len = data -> values_len + 1 ; oid_t oid_list [ oid_list_len ] ; _Bool oid_list_todo [ oid_list_len ] ; int status ; size_t i ; csnmp_list_instances_t * instance_list_head ; csnmp_list_instances_t * instance_list_tail ; csnmp_table_values_t * * value_list_head ; csnmp_table_values_t * * value_list_tail ; DEBUG ( \"snmp plugin: csnmp_read_table (host = %s, data = %s)\" , host -> name , data -> name ) ; if ( host -> sess_handle == NULL ) { DEBUG ( \"snmp plugin: csnmp_read_table: host->sess_handle == NULL\" ) ; return ( - 1 ) ; } ds = plugin_get_ds ( data -> type ) ; if ( ! ds ) { ERROR ( \"snmp plugin: DataSet `%s\\' not defined.\" , data -> type ) ; return ( - 1 ) ; } if ( ds -> ds_num != data -> values_len ) { ERROR ( \"snmp plugin: DataSet `%s\\' requires %zu values, but config talks \" \"about %zu\" , data -> type , ds -> ds_num , data -> values_len ) ; return ( - 1 ) ; } assert ( data -> values_len > 0 ) ; memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ; if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> DEBUG ( \"snmp plugin: all variables have left their subtree\" ) ; snmp_free_pdu ( req <vul-start> = NULL ; <vul-end> sfree ( errstr <vul-start> ; if ( <vul-end> status == 0\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> 0 ) { if ( req!= NULL ) <vul-start> = NULL ; <vul-end> sfree ( errstr\n"
  },
  {
    "id": 742,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 int context_init ( SERVICE_OPTIONS * section ) { # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) section -> ctx = SSL_CTX_new ( TLS_client_method ( ) ) ; else section -> ctx = SSL_CTX_new ( TLS_server_method ( ) ) ; if ( ! SSL_CTX_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) { s_log ( LOG_ERR , \"Failed to set the minimum protocol version 0x%X\" , section -> min_proto_version ) ; return 1 ; } if ( ! SSL_CTX_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) { s_log ( LOG_ERR , \"Failed to set the maximum protocol version 0x%X\" , section -> max_proto_version ) ; return 1 ; } # else if ( section -> option . client ) section -> ctx = SSL_CTX_new ( section -> client_method ) ; else section -> ctx = SSL_CTX_new ( section -> server_method ) ; # endif if ( ! section -> ctx ) { sslerror ( \"SSL_CTX_new\" ) ; return 1 ; } if ( ! SSL_CTX_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) { sslerror ( \"SSL_CTX_set_ex_data\" ) ; return 1 ; } current_section = section ; <vul-start> if ( section -> cipher_list ) { <vul-end> s_log ( LOG_DEBUG , \"Ciphers: %s\" , section -> cipher_list ) ; if ( ! SSL_CTX_set_cipher_list ( section -> ctx , section -> cipher_list ) ) { sslerror ( \"SSL_CTX_set_cipher_list\" ) ; return 1 ; } } # ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) { s_log ( LOG_DEBUG , \"TLSv1.3 ciphersuites: %s\" , section -> ciphersuites",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start> = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , \"User-specified security level set: %d\" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , \"stunnel default security level set: %d\" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , \"OpenSSL security level is used: %d\" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <vul-start> return 1 ; # ifndef OPENSSL_NO_TLSEXT <vul-start> . client ) <vul-end> SSL_CTX_set_tlsext_servername_callback ( section <vul-start> ; # endif <vul-end> return 0 ;\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ; if ( <vul-end> section -> option <vul-start> option. client &&! SSL_CTX_set_cipher_list ( section -> ctx, section -> cipher_list ) ) { sslerror ( \"SSL_CTX_set_cipher_list\" ) ; return 1 ; } # ifndef OPENSSL_NO_TLSEXT SSL_CTX_set_tlsext_servername_callback ( section -> ctx, servername_cb ) ; # endif # ifndef OPENSSL_NO_ECDH ecdh_init ( section ) ; # endif } # ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) { s_log ( LOG_DEBUG, \"TLSv1.3 ciphersuites: %s\", section -> ciphersuites ) ; if (! SSL_CTX_set_tlsext_servername_callback ( section -> ctx, servername_cb ) ) { sslerror ( \"SSL_CTX_set_tlsext_servername\" ) ; return 1 ; } # endif <vul-end> # ifndef OPENSSL_NO_DH <vul-start> ; # endif <vul-end> return 0 ;\n"
  },
  {
    "id": 743,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void calc_pframe_target_size ( VP8_COMP * cpi ) { int min_frame_target ; int old_per_frame_bandwidth = cpi -> per_frame_bandwidth ; if ( cpi -> current_layer > 0 ) cpi -> per_frame_bandwidth = cpi -> layer_context [ cpi -> current_layer ] . avg_frame_size_for_layer ; min_frame_target = 0 ; if ( cpi -> pass == 2 ) { min_frame_target = cpi -> min_frame_bandwidth ; if ( min_frame_target < ( cpi -> av_per_frame_bandwidth >> 5 ) ) min_frame_target = cpi -> av_per_frame_bandwidth >> 5 ; } else if ( min_frame_target < cpi -> per_frame_bandwidth / 4 ) min_frame_target = cpi -> per_frame_bandwidth / 4 ; if ( ( cpi -> common . refresh_alt_ref_frame ) && ( cpi -> oxcf . number_of_layers == 1 ) ) { if ( cpi -> pass == 2 ) { cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ; cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } } else { if ( cpi -> pass == 2 ) { cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } else { int Adjustment ; if ( cpi -> kf_overspend_bits > 0 ) { Adjustment = ( cpi -> kf_bitrate_adjustment <= cpi -> kf_overspend_bits ) ? cpi -> kf_bitrate_adjustment : cpi -> kf_overspend_bits ; if ( Adjustment > ( cpi -> per_frame_bandwidth - min_frame_target ) ) Adjustment = ( cpi -> per_frame_bandwidth - min_frame_target ) ; cpi -> kf_overspend_bits -= Adjustment ; cpi -> this_frame_target = cpi -> per_frame_bandwidth - Adjustment ; if ( cpi -> this_frame_target < min_frame_target ) cpi -> this_frame_target = min_frame_target ; } else cpi -> this_frame_target = cpi ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ) { Adjustment = <vul-end> ( cpi -> <vul-start> ) * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <vul-end> else cpi ->\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) * ( Adjust >> 1 ) <vul-end> ) ; else\n"
  },
  {
    "id": 744,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = \"INVALID AS OPTIONS\" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = \"CLIENT EXPIRED\" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = \"CLIENT KEY EXPIRED\" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = \"SERVICE EXPIRED\" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = \"REQUIRED PWCHANGE\" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = \"POSTDATE NOT ALLOWED\" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( kdc_active_realm , client . princ <vul-end> , request ->\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } if ( isflagset ( request -> kdc_options, KDC_OPT_TRUSTED ) ) { * status = \"TRUSTED\" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } if (\n"
  },
  {
    "id": 745,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; <vul-start> if ( ! capable ( CAP_NET_ADMIN ) ) <vul-end> <vul-start> return - EPERM ; <vul-end> if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( \"get_ctl: len %u < %u\\\\n\" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } <vul-start> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <vul-end> return - EFAULT ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , \"IP Virtual Server version %d.%d.%d (size=%d)\" , NVERSION ( IP_VS_VERSION_CODE ) , IP_VS_CONN_TAB_SIZE ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = IP_VS_CONN_TAB_SIZE ; info . num_services = ip_vs_num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; unsigned int copylen ; <vul-start> return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <vul-start> EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <vul-start> , user , copylen <vul-end> ) != 0\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; struct ip_vs_cmd_entry * cmd = ( struct ip_vs_cmd_entry * ) arg ; <vul-start> return - EPERM ; if (! access_ok ( VERIFY_WRITE, user, get_arglen [ GET_CMDID ( cmd ) ] ) ) return - EFAULT <vul-start>, user, sizeof ( cmd -> arg ) )!= 0 ) return - EFAULT ; cmd -> arglen = sizeof ( cmd -> arg ) ; memset ( arg, 0, sizeof ( arg ) ) ; cmd -> user = arg ; ret = __ip_vs_get_dest_entries ( get, user ) ; } break ; case IP_VS_SO_GET_CMDID : { struct ip_vs_ctl_entry * entry ; entry = ( struct ip_vs_ctl_entry * ) arg ; if ( entry -> protocol == IP_VS_COMMAND_CODE ) { entry -> protocol = IP_VS_COMMAND_CODE ; entry -> size = IP_VS_CONN_TAB_SIZE ; if ( copy_to_user ( user, & entry -> arg, sizeof ( entry -> arg ) )!= 0 ) ret = - EFAULT ; goto out ; } ret = __ip_vs_get_cmd_entries ( get, user ) ; break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_daemon_user d ; d. state = IP_VS_STATE_MASTER ; d. mcast_ifn = ip_vs_master_mcast_ifn ; d. syncid = ip_vs_master_syncid ; if ( copy_to_user ( user, & d, sizeof ( d ) )!= 0 ) ret = - EFAULT ; goto out ; } ret = __ip_vs_get_daemon_user ( get, user ) ; break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_service_entry * d ; d. num_services = ip_vs_num_services ; if ( copy_to_user ( user, & d, sizeof ( d ) )!= 0 ) ret = - EFAULT ; goto out ; } ret = __ip_vs_get_service_entries ( get, user ) ; if ( copy_to_user ( user, & d, sizeof ( d"
  },
  {
    "id": 746,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s > %s.%s: \" , ip6addr_string ( ndo , & ip6 ->",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , \" [|OPT]\" ) ) ; return ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> return ; } ND_TCHECK ( * bp ) ;\n"
  },
  {
    "id": 747,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , <vul-start> int * returnrate , int64_t * returndist , <vul-end> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; <vul-start> int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ; <vul-end> int y_skip = 0 , uv_skip = 0 ; <vul-start> int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = { 0 } ; <vul-end> TX_SIZE max_uv_tx_size ; x -> skip_encode = 0 ; ctx -> skip = 0 ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; <vul-start> if ( bsize >= BLOCK_8X8 ) { <vul-end> if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly , <vul-start> & dist_y , & y_skip , bsize , tx_cache , <vul-end> best_rd ) >= best_rd ) { <vul-start> * returnrate = INT_MAX ; <vul-end> <vul-start> return ; <vul-end> } <vul-start> max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ; <vul-end> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , <vul-start> & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ; <vul-end> <vul-start> } else { <vul-end> y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { * returnrate",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * x , RD_COST * rd_cost , <vul-end> BLOCK_SIZE bsize , <vul-start> -> e_mbd ; struct macroblockd_plane * const pd = xd -> plane ; <vul-start> dist_uv = 0 <vul-end> ; TX_SIZE max_uv_tx_size <vul-start> = INTRA_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; <vul-start> , bsize , <vul-end> best_rd ) >= <vul-start> best_rd ) { rd_cost -> rate <vul-end> = INT_MAX ; <vul-start> ; return ; } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } <vul-start> tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y <vul-start> & uv_skip , MAX ( BLOCK_8X8 , bsize ) , <vul-end> max_uv_tx_size ) ; <vul-start> max_uv_tx_size ) ; <vul-end> if ( y_skip <vul-start> uv_skip ) { rd_cost -> rate <vul-end> = rate_y + <vul-start> 1 ) ; rd_cost -> dist <vul-end> = dist_y + <vul-start> + dist_uv ; } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } ctx -> mic = * xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * x, <vul-end> BLOCK_SIZE bsize, <vul-start> rate_y_tokenonly = 0 ; int64_t dist_y = 0 ; int64_t dist_uv = 0 ; TX_SIZE max_uv_tx_size ; x -> skip_encode = 0 ; ctx -> skip = 0 ; x -> skip = 0 ; x -> skip = 0 ; x -> skip_skip = 0 ; x -> skip_encode = 0 ; x -> skip_skip = 0 ; x -> skip_encode = 0 ; x -> skip = 0 ; x -> skip_skip = 0 ; x -> skip_encode = 0 ; x -> skip = 0 ; x -> skip_skip = 0 ; x -> skip_encode = 0 ; x -> skip_mode = 0 ; x -> skip_skip = 0 ; x -> skip_skip = 0 ; x -> skip_encode = 0 ; x -> skip_encode = 0 ; x -> skip_encode = 0 ; x -> skip_encode = 0 ; x -> skip_mode = 0 ; x -> skip_skip = 0 ; x -> skip_skip = 0 ; x -> skip_skip = 0 ; x -> skip_skip = 0 ; x -> skip_skip_mode = 0 ; x -> skip_mode_search_method = USE_FULL_RD ; x -> mic = * xd -> mi [ 0 ] ; } else { int i ; * returnrate = rate_y + rate_uv ; <vul-end> rate_y_tokenonly, & <vul-start> rate_y_tokenonly, & rate_uv, & <vul-start> dist_y, & uv_skip, bsize, max_uv_tx_size ) ; } if ( cpi -> sf. tx_size_search_method == USE_FULL_RD ) for ( i = 0 ; i < TX_MODES ; i ++ ) { if ( tx_cache [ i ] < INT64_MAX ) ctx -> tx_rd_diff [ i ] = tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ; else ctx -> tx_rd_diff [ i ] = 0 ; } } else { int i ; * returnrate = rate_y + rate_uv ; * returndist = dist_y + dist_uv ; if ( cpi -> sf. tx_size_search_method == USE"
  },
  {
    "id": 748,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> != EOF ) if ( <vul-end> fputc ( c <vul-start> , file ) != c ) break\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>!= EOF ) if ( <vul-end> fputc ( c <vul-start>, file )!= c ) break\n"
  },
  {
    "id": 749,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> ( ! npages || base_gfn != old . base_gfn\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> out_free ; } new. userspace_addr = mem -> userspace_addr ;\n"
  },
  {
    "id": 750,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; <vul-start> assert ( bidx <= PCI_BARMAX ) ; <vul-end> <vul-start> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <vul-end> <vul-start> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <vul-end> assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> ) arg2 ; if ( addr + size > <vul-end> pdi -> bar <vul-start> bidx ] . addr + <vul-end> pdi -> bar <vul-start> bidx ] . size ) { printf ( \"%s, Out of emulated memory range.\\\\n\" , __func__ ) ; return - ESRCH ; } <vul-end> offset = addr\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ) arg2 ; if <vul-end> ( bidx <= <vul-start> <= PCI_BARMAX ) return 0 <vul-start> type == PCIBAR_MEM32 ) ; if ( <vul-end> pdi -> bar <vul-start> type == PCIBAR_MEM64 ) return 0\n"
  },
  {
    "id": 751,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( \"%s: asoc:%p, timeo:%ld, msg_len:%zu\\\\n\" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <vul-start> if ( sk != asoc -> base . sk ) <vul-end> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> current_timeo ) ; <vul-end> lock_sock ( sk\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> base. sk ||! net_eq ( current_net ( ), sock_owned_by_user ( sk ) )\n"
  },
  {
    "id": 752,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> image_info -> ping != MagickFalse <vul-start> goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ( clone_info = DestroyImageInfo ( clone_info ) ) == ( ImageInfo * ) NULL ) goto NoMemory ; if (\n"
  },
  {
    "id": 753,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , \"Error, can\\'t read tile at %lu %lu\" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf ,",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint32 col ; if ( imagewidth < tilew ) { TIFFError ( TIFFFileName ( in ), \"Error, can\\'t read tile at %lu %lu\", ( unsigned long ) col, ( unsigned long ) row ) ; status = 0 ; goto done ; }\n"
  },
  {
    "id": 754,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) != 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> * sizeof ( <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> ; pixels =\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> rows * ( size_t ) <vul-start> -> rows * ( size_t )\n"
  },
  {
    "id": 755,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; <vul-start> * sent = 0 ; <vul-end> if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , \"sends on sock %p stuck for 15 \" \"seconds\" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> sent = 0 <vul-end> ; smb_msg .\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> -> ssocket ; if ( ssocket == NULL ) return - ENOTSOCK ; <vul-start> sent = 0 <vul-end> ; smb_msg.\n"
  },
  {
    "id": 756,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parsestr ( struct compiling * c , const node * n , int * bytesmode , int * rawmode , PyObject * * result , const char * * fstr , Py_ssize_t * fstrlen ) { size_t len ; const char * s = STR ( n ) ; int quote = Py_CHARMASK ( * s ) ; int fmode = 0 ; * bytesmode = 0 ; * rawmode = 0 ; * result = NULL ; * fstr = NULL ; if ( Py_ISALPHA ( quote ) ) { while ( ! * bytesmode || ! * rawmode ) { if ( quote == 'b' || quote == 'B' ) { quote = * ++ s ; * bytesmode = 1 ; } else if ( quote == 'u' || quote == 'U' ) { quote = * ++ s ; } else if ( quote == 'r' || quote == 'R' ) { quote = * ++ s ; * rawmode = 1 ; } else if ( quote == 'f' || quote == 'F' ) { quote = * ++ s ; fmode = 1 ; } else { break ; } } } if ( fmode && * bytesmode ) { PyErr_BadInternalCall ( ) ; return - 1 ; } if ( quote != '\\\\'' && quote != \\'\\\\\"\\' ) { PyErr_BadInternalCall ( ) ; return - 1 ; } s ++ ; len = strlen ( s ) ; if ( len > INT_MAX ) { PyErr_SetString ( PyExc_OverflowError , \"string to parse is too long\" )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: \n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; } } if ( fmode && * fstr ) { * fstr = s ; * fstrlen = len ; return 0 ; }\n"
  },
  {
    "id": 757,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <vul-start> if ( ! stream ) <vul-end> <vul-start> fatal ( \"Failed to allocate new stream.\" ) ; <vul-end> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <vul-start> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <vul-end> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( \"Failed to get config: %s\\\\n\" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <vul-start> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <vul-end> <vul-start> stream -> config . write_webm = 1 ; <vul-end> # if CONFIG_WEBM_IO <vul-start> stream -> ebml . last_pts_ms = - 1 ; <vul-end> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ; if ( stream == NULL ) { <vul-end> fatal ( \"Failed to allocate new stream.\" <vul-start> \"Failed to allocate new stream.\" ) ; } <vul-start> -> codec -> codec_interface <vul-end> ( ) , <vul-start> -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <vul-start> ; stream -> ebml . last_pts_ns <vul-end> = - 1 <vul-start> = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>! stream ) { <vul-start> \"Failed to allocate new stream.\" ) ; } <vul-start> vpx_codec_err_t res ; # if CONFIG_FP_MB_STATS stream -> config. frame_parallel_decode = 1 ; # endif <vul-start> -> codec -> codec_interface ( ), & stream -> config, global -> usage ) ; if ( res ) { <vul-end> fatal ( \"Failed to get config: %s\\\\n\" <vul-start> ) ) ; } <vul-start> write_webm = 1 ; stream -> ebml. last_pts_ms = - 1 ; # endif <vul-end> stream -> ebml <vul-start> -> ebml. cfg. g_input_bit_depth = 0 ; stream -> ebml.\n"
  },
  {
    "id": 758,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s option (%u), length %u (%u): \" , tok2str ( icmp6_opt_values , \"unknown\" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ( ndo , \"%s\" , icmp6_tstr <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ndo, \"%s\", istr <vul-end> ) ) ;\n"
  },
  {
    "id": 759,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <vul-start> u8 smac [ ETH_ALEN ] ; <vul-end> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> , ret ; <vul-end> listen_id = cm_id <vul-start> goto err3 ; <vul-end> mutex_lock ( & <vul-start> ( & lock <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ret ; u8 * psmac = NULL ; u8 * palt_smac = NULL ; int is_iboe = 0 ; if ( rdma_is_port_usable ( cm_id -> device ) ) { psmac = kmalloc ( sizeof ( * psmac ), GFP_KERNEL ) ; if (! psmac ) goto err3 ; palt_smac = kmalloc ( sizeof ( * palt_smac ), GFP_KERNEL ) ; if (! palt_smac ) goto err3 ; <vul-start> goto err3 ; <vul-end> if ( ib_event <vul-start> NULL ; } psmac = psmac -> sgid ; palt_smac = palt_smac -> sgid ; <vul-start> ( & lock <vul-end> ) ; if\n"
  },
  {
    "id": 760,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , \"client authentication failure\\\\n\" ) ; credssp_free ( transport -> credssp ) ; <vul-start> return FALSE ; <vul-end> } return TRUE ; }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
  },
  {
    "id": 761,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <vul-end> { u8 obuf [ 3 ] = { 0xe , 0x87 , 0 } ; u8 ibuf [ ] = { 0 } ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x86 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x80 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> msleep ( 50 ) ; <vul-end> obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x80 ; obuf [ 2 ] = 1 ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> <vul-start> err ( \"command 0x0e transfer failed.\" ) ; <vul-end> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 0 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; msleep ( 50 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0x51 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> ) err ( <vul-end> \"command 0x51 transfer failed.\" ) ; <vul-start> \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <vul-end> -> fe_adap [ <vul-start> & d -> <vul-end> i2c_adap , NULL <vul-start> ; if ( adap <vul-end> -> fe_adap [ <vul-start> ( tda18271_attach , adap <vul-end> -> fe_adap [ <vul-start> , & d <vul-end> -> i2c_adap ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> dvb_usb_adapter * d, struct dvb_usb_device * dev <vul-start>, 1, dev -> priv <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> = 0xe ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> = 0x86 ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> = 1 ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> ( d -> <vul-end> dev, obuf <vul-start>, 3, & <vul-start>, 1, dev -> priv <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> ( d -> <vul-end> dev, obuf <vul-start>, 3, & <vul-start>, 1, dev -> priv <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> ( d -> <vul-end> dev, obuf <vul-start>, 3, & <vul-start>, 1, dev -> priv <vul-end> ) < 0 <vul-start> \"command 0x0e transfer failed.\" ) ; if ( dev -> priv -> flags & DVB_DEV_FLAG_TENTATIVE ) err ( \"t220 frontend: Tailing out of memory.\" ) ; <vul-start> ( d -> <vul-end> dev, obuf <vul-start>, & tda18271_config, d -> dev -> i2c_adap, NULL ) ; if ( d -> fe_adap [ 0 ]. fe!= NULL ) { if ("
  },
  {
    "id": 762,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size , int cpu_id ) { struct ring_buffer_per_cpu * cpu_buffer ; unsigned long nr_pages ; int cpu , err = 0 ; if ( ! buffer ) return size ; if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ; <vul-start> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <vul-end> size *= BUF_PAGE_SIZE ; if ( size < BUF_PAGE_SIZE * 2 ) size = BUF_PAGE_SIZE * 2 ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( atomic_read ( & buffer -> resize_disabled ) ) return - EBUSY ; mutex_lock ( & buffer -> mutex ) ; if ( cpu_id == RING_BUFFER_ALL_CPUS ) { for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; if ( cpu_buffer -> nr_pages_to_update <= 0 ) continue ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu ) ) { err = - ENOMEM ; goto out_err ; } } get_online_cpus ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( ! cpu_online ( cpu ) ) { rb_update_pages ( cpu_buffer ) ; cpu_buffer -> nr_pages_to_update = 0 ; } else { schedule_work_on ( cpu , & cpu_buffer -> update_pages_work ) ; } } for_each_buffer_cpu ( buffer ,",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> return size ; nr_pages = DIV_ROUND_UP ( size, BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE ; if ( size < nr_pages * 2 ) size = nr_pages * 2 ; if ( size > MAX_RING_BUFFER_SIZE ) { err = - EMSGSIZE ; goto out_err ; } <vul-start> ( size, <vul-end> BUF_PAGE_SIZE ) ;\n"
  },
  {
    "id": 763,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <vul-start> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <vul-end> duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows must be unconditional and \" \"use the STANDARD target with \" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct arpt_entry ) > limit || ( unsigned char * ) e + e -> next_offset > limit - sizeof ( struct xt_entry_target )\n"
  },
  {
    "id": 764,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , \"Error, can\\'t write tile",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint32 col ; if ( imagewidth < tilew ) { TIFFError ( TIFFFileName ( out ), \"Error, can\\'t write tile #%u\", ( unsigned long ) row ) ; _TIFFfree ( obuf ) ; return 0 ; }\n"
  },
  {
    "id": 765,
    "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int setup_ttydir_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console , char * ttydir ) { char path [ MAXPATHLEN ] , lxcpath [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , \"%s/dev/%s\" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( path ) ) return - 1 ; ret = mkdir ( path , 0755 ) ; if ( ret && errno != EEXIST ) { SYSERROR ( \"failed with errno %d to create %s\" , errno , path ) ; return - 1 ; } INFO ( \"created %s\" , path ) ; ret = snprintf ( lxcpath , sizeof ( lxcpath ) , \"%s/dev/%s/console\" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( \"console path too long\" ) ; return - 1 ; } snprintf ( path , sizeof ( path ) , \"%s/dev/console\" , rootfs -> mount ) ; ret = unlink ( path ) ; if ( ret && errno != ENOENT ) { SYSERROR ( \"error unlinking %s\" , path ) ; return - 1 ; } ret = creat ( lxcpath , 0660 ) ; if ( ret == - 1 && errno != EEXIST ) { SYSERROR ( \"error %d creating %s\" , errno , lxcpath ) ; return - 1 ; } if ( ret >= 0 ) close ( ret ) ; if ( console -> master < 0 ) { INFO ( \"no console\"",
    "golden_answers": [
      "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount ( console -> name , lxcpath , \"none\" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , <vul-end> console -> name <vul-start> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , \"%s/console\" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( \"lxc/console path too long\" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( \"failed to create symlink for console\" ) ; return - 1 ; } INFO ( \"console has been setup on %s\" , lxcpath ) ; return 0 <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount <vul-end> ( console ->\n"
  },
  {
    "id": 766,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> static void nsc_decode ( NSC_CONTEXT * context ) <vul-end> { UINT16 x ; UINT16 y ; <vul-start> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <vul-end> <vul-start> BYTE shift = context -> ColorLossLevel - 1 ; <vul-end> <vul-start> BYTE * bmpdata = context -> BitmapData ; <vul-end> for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_decode ( NSC_CONTEXT <vul-start> ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <vul-start> 8 ) ; <vul-end> shift = context <vul-start> - 1 ; <vul-end> bmpdata = context <vul-start> context -> BitmapData ; if ( ! bmpdata ) return FALSE <vul-start> - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <vul-start> ; } } return TRUE ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_decode ( NSC_CONTEXT <vul-start> UINT16 y ; const <vul-start> 8 ) ; const <vul-start> context -> BitmapData ; if (! context -> priv ) return FALSE <vul-start> ; } } return TRUE ;\n"
  },
  {
    "id": 767,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <vul-start> if ( REMAIN > INT_MAX ) <vul-end> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> if ( REMAIN == 0 || REMAIN\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( REMAIN > UINT_MAX <vul-end> ) return GSS_S_DEFECTIVE_TOKEN\n"
  },
  {
    "id": 768,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , \"BPF_NEG uses reserved fields\\\\n\" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , \"BPF_END uses reserved fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d pointer arithmetic prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> dst_reg ) ; coerce_reg_to_size <vul-end> ( & regs <vul-start> -> dst_reg ] , 4\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> dst_reg ) ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <vul-start> 4 ) ; } else { regs [ insn -> dst_reg ]. var_off = tnum_cast ( ( u32 ) insn -> dst_reg, 4 ) ; }\n"
  },
  {
    "id": 769,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , <vul-end> UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; <vul-start> WORD32 ret ; <vul-end> ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; <vul-start> ps_dec -> u2_total_mbs_coded = 0 ; <vul-end> { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> dec_struct_t * ps_dec <vul-end> ) { dec_slice_params_t <vul-start> ; WORD32 ret <vul-end> ; { dec_err_status_t <vul-start> return ret ; <vul-end> H264_MUTEX_UNLOCK ( &\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>       WORD16 <vul-end> ih264d_end_of_pic ( dec_struct_t <vul-start> -> ps_cur_slice ; WORD16 <vul-end> ret ; ps_dec <vul-start> ; ps_dec -> ps_total_mbs_coded <vul-end> = 0 ;\n"
  },
  {
    "id": 770,
    "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof (",
    "golden_answers": [
      "CWE-674 Fixed Code Lines are: <vul-start> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <vul-start> & sParse , <vul-end> pSelect , 0\n"
    ],
    "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> pSelect ) { Select * pSelect = sParse. pNewTable -> pSelect ; <vul-start> = SQLITE_OK ; assert ( pSelect -> selFlags & SF_View ) ; <vul-start> pSelect, 0 ) ; assert ( pSelect -> selFlags & SF_View\n"
  },
  {
    "id": 771,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int i915_gem_do_execbuffer ( struct drm_device * dev , void * data , struct drm_file * file , struct drm_i915_gem_execbuffer2 * args , struct drm_i915_gem_exec_object2 * exec ) { drm_i915_private_t * dev_priv = dev -> dev_private ; struct list_head objects ; struct eb_objects * eb ; struct drm_i915_gem_object * batch_obj ; struct drm_clip_rect * cliprects = NULL ; struct intel_ring_buffer * ring ; u32 exec_start , exec_len ; u32 seqno ; u32 mask ; int ret , mode , i ; if ( ! i915_gem_check_execbuffer ( args ) ) { DRM_DEBUG ( \"execbuf with invalid offset/length\\\\n\" ) ; return - EINVAL ; } ret = validate_exec_list ( exec , args -> buffer_count ) ; if ( ret ) return ret ; switch ( args -> flags & I915_EXEC_RING_MASK ) { case I915_EXEC_DEFAULT : case I915_EXEC_RENDER : ring = & dev_priv -> ring [ RCS ] ; break ; case I915_EXEC_BSD : if ( ! HAS_BSD ( dev ) ) { DRM_DEBUG ( \"execbuf with invalid ring (BSD)\\\\n\" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ VCS ] ; break ; case I915_EXEC_BLT : if ( ! HAS_BLT ( dev ) ) { DRM_DEBUG ( \"execbuf with invalid ring (BLT)\\\\n\" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ BCS ] ; break ; default : DRM_DEBUG ( \"execbuf with unknown ring: %d\\\\n\" , ( int ) ( args -> flags & I915_EXEC_RING_MASK ) ) ; return - EINVAL ; } mode = args -> flags & I915_EXEC_CONSTANTS_MASK ; mask = I915_EXEC_CONSTANTS_MASK ; switch (",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> DRM_DEBUG ( \"clip rectangles are only valid with the render ring\\\\n\" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( \"execbuf with %u cliprects\\\\n\" , args -> num_cliprects\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> DRM_DEBUG ( \"clip rectangles are only valid with the render ring\\\\n\" ) ; return - EINVAL ; } if ( args -> num_cliprects > DRM_CXGB_KFMT_MAX ) { DRM_DEBUG ( \"invalid number of cliprects (%d)\\\\n\", args -> num_cliprects\n"
  },
  {
    "id": 772,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; <vul-start> other = unix_peer_get ( sk ) ; <vul-end> if ( other ) { <vul-start> if ( unix_peer ( other ) != sk ) { <vul-end> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <vul-start> if ( unix_recvq_full ( other ) ) <vul-end> writable = 0 ; <vul-start> } <vul-end> sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM |",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <vul-end> other ) != <vul-start> ) != sk && <vul-end> unix_recvq_full ( other <vul-start> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <vul-start> = 0 ; unix_state_unlock ( sk <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> = unix_peer_get ( sk ) ; if ( writable <vul-end> ) { if <vul-start> { if (! unix_dgram_peer_wake_disconnect_wakeup ( sk, other ) ) goto peer_wake_disconnect ; <vul-end> sock_poll_wait ( file <vul-start> ; if ( unix_dgram_peer_wake_disconnect ( sk, other ) ) goto peer_wake_disconnect ; } unix_dgram_peer_wake_disconnect ( sk, other <vul-end> ) ; } <vul-start> = 0 ; <vul-end> sock_put ( other\n"
  },
  {
    "id": 773,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static ssize_t ucma_process_join ( struct ucma_file * file , struct rdma_ucm_join_mcast * cmd , int out_len ) { struct rdma_ucm_create_id_resp resp ; struct ucma_context * ctx ; struct ucma_multicast * mc ; struct sockaddr * addr ; int ret ; u8 join_state ; if ( out_len < sizeof ( resp ) ) return - ENOSPC ; addr = ( struct sockaddr * ) & cmd -> addr ; if ( cmd -> addr_size != rdma_addr_size ( addr ) ) return - EINVAL ; if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) join_state = BIT ( FULLMEMBER_JOIN ) ; else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; else return - EINVAL ; ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; if ( IS_ERR ( ctx ) ) return PTR_ERR ( ctx ) ; mutex_lock ( & file -> mut ) ; mc = ucma_alloc_multicast ( ctx ) ; if ( ! mc ) { ret = - ENOMEM ; goto err1 ; } mc -> join_state = join_state ; mc -> uid = cmd -> uid ; memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , join_state , mc ) ; if ( ret ) goto err2 ; resp . id = mc -> id ; if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , & resp , sizeof ( resp ) ) ) { ret = - EFAULT ;",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> err3 ; } mutex_lock ( & mut ) ; list_del ( & mc -> list ) ; kfree ( mc ) ;\n"
  },
  {
    "id": 774,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int selectExpander ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i , j , k ; SrcList * pTabList ; ExprList * pEList ; struct SrcList_item * pFrom ; sqlite3 * db = pParse -> db ; Expr * pE , * pRight , * pExpr ; u16 selFlags = p -> selFlags ; u32 elistFlags = 0 ; p -> selFlags |= SF_Expanded ; if ( db -> mallocFailed ) { return WRC_Abort ; } assert ( p -> pSrc != 0 ) ; if ( ( selFlags & SF_Expanded ) != 0 ) { return WRC_Prune ; } if ( pWalker -> eCode ) { p -> selId = ++ pParse -> nSelect ; } pTabList = p -> pSrc ; pEList = p -> pEList ; sqlite3WithPush ( pParse , p -> pWith , 0 ) ; sqlite3SrcListAssignCursors ( pParse , pTabList ) ; for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab ; assert ( pFrom -> fg . isRecursive == 0 || pFrom -> pTab != 0 ) ; if ( pFrom -> fg . isRecursive ) continue ; assert ( pFrom -> pTab == 0 ) ; # ifndef SQLITE_OMIT_CTE if ( withExpand ( pWalker , pFrom ) ) return WRC_Abort ; if ( pFrom -> pTab ) { } else # endif if ( pFrom -> zName == 0 ) { # ifndef SQLITE_OMIT_SUBQUERY Select * pSel",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> } if ( pParse -> nErr ||\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> } if ( pParse -> nErr ) goto fail ; if (\n"
  },
  {
    "id": 775,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <vul-start> u64 msr_data ; <vul-end> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; <vul-start> cs . dpl = 3 ; <vul-end> ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; <vul-start> break ; <vul-end> } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <vul-start>",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; u64 msr_data , rcx , rdx <vul-start> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <vul-start> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <vul-start> -> _eip = rdx <vul-end> ; * reg_write <vul-start> VCPU_REGS_RSP ) = rcx <vul-end> ; return X86EMUL_CONTINUE\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, ss ; int usermode ; u16 cs_sel = 0, ss_sel = 0 ; unsigned long eip <vul-end> ; if ( <vul-start> = X86EMUL_MODE_PROT32 ; eip = 3 ; ss. dpl = 3 ; <vul-start> = 1 ; eip = 1 ; <vul-start> VCPU_SREG_SS ) ; if (! ( msr_data & 0xfffc ) ) return emulate_gp ( ctxt, 0 ) ; <vul-start> -> _eip = eip <vul-end> ; * reg_write <vul-start> VCPU_SSP ) = eip <vul-end> ; return X86EMUL_CONTINUE\n"
  },
  {
    "id": 776,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <vul-start> struct packet_sock * po = pkt_sk ( sk ) ; <vul-end> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <vul-start> if ( ! po -> running ) <vul-end> <vul-start> return - EINVAL ; <vul-end> if ( po -> fanout ) <vul-start> return - EALREADY ; <vul-end> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <vul-start> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <vul-end> <vul-start> if ( ! po -> rollover ) <vul-end> return - ENOMEM ; <vul-start> atomic_long_set ( & po -> rollover -> num , 0 ) ; <vul-end> <vul-start> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <vul-end> <vul-start> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <vul-end> <vul-start> } <vul-end> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) { struct packet_rollover * rollover = NULL ; struct <vul-start> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <vul-start> -> running ) goto out ; err = - EALREADY <vul-end> ; if ( <vul-start> -> fanout ) goto out <vul-end> ; if ( <vul-start> ) ) { err = - ENOMEM ; <vul-end> rollover = kzalloc <vul-start> sizeof ( * <vul-end> rollover ) , <vul-start> if ( ! rollover ) goto out <vul-end> ; atomic_long_set ( <vul-start> atomic_long_set ( & <vul-end> rollover -> num <vul-start> atomic_long_set ( & <vul-end> rollover -> num_huge <vul-start> atomic_long_set ( & <vul-end> rollover -> num_failed <vul-start> 0 ) ; po -> rollover = rollover ; } <vul-end> match = NULL <vul-start> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <vul-start> fanout_mutex ) ; <vul-end> return err ;\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ( sk ) ; struct packet_fanout * rollover <vul-start> EINVAL ; } mutex_lock ( & fanout_mutex ) ; <vul-start> -> running ) { err = <vul-end> - EINVAL ; <vul-start> - EINVAL ; goto out ; } <vul-start> -> fanout ) { err = <vul-end> - EALREADY ; <vul-start> ; if ( err ) goto out ; <vul-end> rollover = kzalloc <vul-start> ; if ( <vul-end> rollover ) return <vul-start> - ENOMEM ; } <vul-start> 0 ) ; } err = 0 ; <vul-end> mutex_unlock ( & <vul-start> fanout_mutex ) ; <vul-end> return err ;\n"
  },
  {
    "id": 777,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ; <vul-start> return fd ; <vul-end> } } return - 1 ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> = hash ; sr -> fd_is_fdt = MK_TRUE ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = hash ; sr -> vhost_fdt_unhash = 0 ;\n"
  },
  {
    "id": 778,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <vul-start> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <vul-end> <vul-start> if ( ret <= 0 ) { <vul-end> <vul-start> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <vul-end> <vul-start> \"Failed to expand key %s: %s\" , key -> key -> key , error ) ; <vul-end> return - 1 ; } <vul-start> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <vul-end> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s = %s\" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , \"Failed to lookup key %s: %s\" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s not found,",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <vul-end> , & error <vul-start> if ( ret > <vul-end> 0 ) { <vul-start> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s = %s\" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <vul-start> , AUTH_SUBSYS_DB , \"Failed to lookup key %s: %s\" , str_c ( path ) <vul-end> , error ) <vul-start> 1 ; } <vul-end> else if (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) ; if ( iter -> var_expand_table == NULL ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, \"Lookup: No such key %s\", str_c ( path ) ) ; return - 1 ; } <vul-start> <= 0 ) <vul-end> return - 1 <vul-start>, AUTH_SUBSYS_DB, \"Failed to expand key %s: %s\" <vul-end>, key -> <vul-start> key -> key <vul-end>, error ) <vul-start> 1 ; } if (! iter -> var_expand_table ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, \"Lookup: No such key %s\", str_c ( path ) ) ; return - 1 ; }\n"
  },
  {
    "id": 779,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( \"SSH2_MSG_KEXINIT received\" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; <vul-start> ptr = sshpkt_ptr ( ssh , & dlen ) ; <vul-end> if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex ->",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return SSH_ERR_INVALID_ARGUMENT ; if ( ( r = kex_verify_peer ( kex, NULL ) )!= 0 ) return r ;\n"
  },
  {
    "id": 780,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd <",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <vul-end> ) ; if <vul-start> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <vul-start> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <vul-end> ) ; mutex_unlock <vul-start> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <vul-end> ) ; mutex_unlock\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> move_group ) { if (! ctx -> task ) goto err_locked ; <vul-start> } else { if (! ctx -> task ) goto err_locked ;\n"
  },
  {
    "id": 781,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int connection_exit_begin_conn ( cell_t * cell , circuit_t * circ ) { edge_connection_t * n_stream ; relay_header_t rh ; char * address = NULL ; uint16_t port = 0 ; <vul-start> or_circuit_t * or_circ = NULL ; <vul-end> const or_options_t * options = get_options ( ) ; begin_cell_t bcell ; int rv ; uint8_t end_reason = 0 ; assert_circuit_ok ( circ ) ; <vul-start> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <vul-end> <vul-start> or_circ = TO_OR_CIRCUIT ( circ ) ; <vul-end> relay_header_unpack ( & rh , cell -> payload ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) return - END_CIRC_REASON_TORPROTOCOL ; if ( ! server_mode ( options ) && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay begin cell at non-server. Closing.\" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , NULL ) ; return 0 ; } rv = begin_cell_parse ( cell , & bcell , & end_reason ) ; if ( rv < - 1 ) { return - END_CIRC_REASON_TORPROTOCOL ; } else if ( rv == - 1 ) { tor_free ( bcell . address ) ; <vul-start> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <vul-end> return 0 ; } if ( ! bcell . is_begindir ) { address = bcell . address ; port = bcell . port ; if ( or_circ && or_circ -> p_chan ) { if ( ! options -> AllowSingleHopExits && ( or_circ -> is_first_hop || ( ! connection_or_digest_is_known_relay ( or_circ -> p_chan -> identity_digest ) && should_refuse_unknown_exits (",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <vul-start> circ ) ) { <vul-start> circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <vul-start> , end_reason , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_NOTDIRECTORY , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_INTERNAL , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_EXITPOLICY , layer_hint <vul-end> ) ; return <vul-start> CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <vul-end> ) ; log_info <vul-start> , END_STREAM_REASON_DONE , layer_hint <vul-end> ) ; connection_free\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> = 0 ; stream_id_t * st = NULL ; <vul-start> circ ) ; st = tor_new_stream ( <vul-end> ) ; relay_header_unpack <vul-start>, circ, END_STREAM_REASON_NOTDIRECTORY <vul-end>, NULL ) <vul-start>, circ, END_STREAM_REASON_INTERNAL <vul-end>, NULL )\n"
  },
  {
    "id": 782,
    "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { <vul-start> umode_t mode = inode -> i_mode ; <vul-end> retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ; <vul-start> else { <vul-end> struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ;",
    "golden_answers": [
      "CWE-285 Fixed Code Lines are: <vul-start> acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <vul-end> ) goto err_out <vul-start> goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <vul-end> iattr . ia_valid <vul-start> iattr ) ; <vul-end> } break ;\n"
    ],
    "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> { umode_t mode ; retval = posix_acl_update_mode ( inode, & mode, & acl ) ; if ( retval ) goto err_out ; else { struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr. ia_mode <vul-start> iattr ) ; <vul-end> } break ;\n"
  },
  {
    "id": 783,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file .",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" )\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>. directory [ icon_info.\n"
  },
  {
    "id": 784,
    "question": "CWE-290 Code Input Vulnerable Code Is: CWE-290 static int valid_host ( cupsd_client_t * con ) { cupsd_alias_t * a ; cupsd_netif_t * netif ; const char * end ; char * ptr ; strlcpy ( con -> clientname , httpGetField ( con -> http , HTTP_FIELD_HOST ) , sizeof ( con -> clientname ) ) ; if ( ( ptr = strrchr ( con -> clientname , ':' ) ) != NULL && ! strchr ( ptr , ']' ) ) { * ptr ++ = '\\\\0' ; con -> clientport = atoi ( ptr ) ; } else con -> clientport = con -> serverport ; if ( httpAddrLocalhost ( httpGetAddress ( con -> http ) ) ) { return ( ! _cups_strcasecmp ( con -> clientname , \"localhost\" ) || ! _cups_strcasecmp ( con -> clientname , \"localhost.\" ) || <vul-start> # ifdef __linux <vul-end> ! _cups_strcasecmp ( con -> clientname , \"localhost.localdomain\" ) || # endif ! strcmp ( con -> clientname , \"127.0.0.1\" ) || ! strcmp ( con -> clientname , \"[::1]\" ) ) ; } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) if ( ( end = strrchr ( con -> clientname , '.' ) ) != NULL && end > con -> clientname && ! end [ 1 ] ) { for ( end -- ; end > con -> clientname && * end != '.' ; end -- ) ; } if ( end && ( ! _cups_strcasecmp ( end , \".local\" ) || ! _cups_strcasecmp ( end , \".local.\" ) ) ) return ( 1 ) ; # endif",
    "golden_answers": [
      "CWE-290 Fixed Code Lines are: <vul-start> \"localhost.\" ) || <vul-end> ! strcmp (\n"
    ],
    "generated_answer": "CWE-290 Fixed Code Lines are: <vul-start> \"localhost.\" ) || <vul-end>! strcmp (\n"
  },
  {
    "id": 785,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <vul-start> EVP_MD_CTX_init ( & ctx ) ; <vul-end> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; }",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ( & ctx ) ; memset ( & ctx, 0, sizeof ( ctx )\n"
  },
  {
    "id": 786,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void receive_carbon ( void * * state ) { prof_input ( \"/carbons on\" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( \"<iq id=\\'*\\' type=\\'set\\'><enable xmlns=\\'urn:xmpp:carbons:2\\'/></iq>\" ) ) ; stbbr_send ( \"<presence to=\\'stabber@localhost\\' from=\\'buddy1@localhost/mobile\\'>\" \"<priority>10</priority>\" \"<status>On my mobile</status>\" \"</presence>\" ) ; assert_true ( prof_output_exact ( \"Buddy1 (mobile) is online, \\\\\"On my mobile\\\\\"\" ) ) ; prof_input ( \"/msg Buddy1\" ) ; assert_true ( prof_output_exact ( \"unencrypted\" ) ) ; stbbr_send ( <vul-start> \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" <vul-end> \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'jabber:client\\' type=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</received>\" \"</message>\" ) ; assert_true ( prof_output_regex ( \"Buddy1/mobile: .+test carbon from recipient\" ) ) ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'stabber@localhost\\'>\" <vul-end> \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'jabber:client\\' type=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\"\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</message>\" ) ; assert_true ( prof_input_regex ( \"Buddy1/mobile:.+test carbon from recipient\" ) ) ; assert_true ( prof_output_regex ( \"Buddy1/mobile:.+test carbon from recipient\" ) ) ; stbbr_send ( \"</message>\" ) ; assert_true ( prof_input_regex ( \"Buddy1/mobile:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"Buddy1/user:.+test carbon from recipient\" ) ) ; assert_true ( prof_input_regex ( \"B"
  },
  {
    "id": 787,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , \"Error, can\\'t write tile",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> uint32 col ; uint32 tilew = tilew - nrow ; if ( tilew > 0xFFFFFFFFU - tw ) { tilew = 0xFFFFFFFFU - tw ; cpStripToTile ( obuf, bufp + colb, nrow, tilew, 0, iskew ) ; } else { tilew = tilew - tw ; cpStripToTile ( obuf, bufp + colb, nrow, tilew, 0, iskew ) ; }\n"
  },
  {
    "id": 788,
    "question": "CWE-191 Code Input Vulnerable Code Is: CWE-191 int rad_packet_recv ( int fd , struct rad_packet_t * * p , struct sockaddr_in * addr ) { struct rad_packet_t * pack ; struct rad_attr_t * attr ; struct rad_dict_attr_t * da ; struct rad_dict_vendor_t * vendor ; uint8_t * ptr ; int n , id , len , vendor_id ; socklen_t addr_len = sizeof ( * addr ) ; * p = NULL ; pack = rad_packet_alloc ( 0 ) ; if ( ! pack ) return 0 ; ptr = mempool_alloc ( buf_pool ) ; if ( ptr == MAP_FAILED ) { log_emerg ( \"radius:packet: out of memory\\\\n\" ) ; goto out_err ; } pack -> buf = ptr ; clock_gettime ( CLOCK_MONOTONIC , & pack -> tv ) ; while ( 1 ) { if ( addr ) n = recvfrom ( fd , pack -> buf , REQ_LENGTH_MAX , 0 , addr , & addr_len ) ; else n = read ( fd , pack -> buf , REQ_LENGTH_MAX ) ; if ( n < 0 ) { rad_packet_free ( pack ) ; if ( errno == EAGAIN ) return 1 ; if ( errno != ECONNREFUSED ) log_ppp_error ( \"radius:packet:read: %s\\\\n\" , strerror ( errno ) ) ; return - 1 ; } break ; } if ( n < 20 ) { log_ppp_warn ( \"radius:packet: short packed received (%i)\\\\n\" , n ) ; goto out_err ; } pack -> code = * ptr ; ptr ++ ; pack -> id = * ptr ; ptr ++ ; pack -> len = ntohs ( * ( uint16_t * ) ptr",
    "golden_answers": [
      "CWE-191 Fixed Code Lines are: <vul-start> -> len ; if ( len < 0 ) { log_ppp_warn ( \"radius:packet invalid vendor attribute len received\\\\n\" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( \"radius:packet: too long vendor attribute received (%i, %i)\\\\n\" , id , len ) ; goto out_err ; }\n"
    ],
    "generated_answer": "CWE-191 Fixed Code Lines are: <vul-start> len ; } if ( len < 0 ) { log_ppp_warn ( \"radius:packet: too long attribute len received\\\\n\" ) ; goto out_err ; }\n"
  },
  {
    "id": 789,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( \"cmd %x arg %p\" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <vul-start> } <vul-end> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <=",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> err ; } ca. device [ sizeof ( ca. device ) - 1 ] = 0 ;\n"
  },
  {
    "id": 790,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int unix_dgram_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( iocb ) ; struct scm_cookie tmp_scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; struct sk_buff * skb ; int err ; int peeked , skip ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) <vul-start> goto out ; <vul-end> msg -> msg_namelen = 0 ; err = mutex_lock_interruptible ( & u -> readlock ) ; if ( err ) { err = sock_intr_errno ( sock_rcvtimeo ( sk , noblock ) ) ; goto out ; } skip = sk_peek_offset ( sk , flags ) ; skb = __skb_recv_datagram ( sk , flags , & peeked , & skip , & err ) ; if ( ! skb ) { unix_state_lock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && err == - EAGAIN && ( sk -> sk_shutdown & RCV_SHUTDOWN ) ) err = 0 ; unix_state_unlock ( sk ) ; goto out_unlock ; } wake_up_interruptible_sync_poll ( & u -> peer_wait , POLLOUT | POLLWRNORM | POLLWRBAND ) ; if ( msg -> msg_name ) unix_copy_addr ( msg , skb -> sk ) ; if ( size > skb -> len - skip ) size = skb -> len - skip ; else if ( size < skb -> len - skip ) msg -> msg_flags",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ) goto out <vul-end> ; err =\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) goto out <vul-end> ; err =\n"
  },
  {
    "id": 791,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <vul-start> if ( len < tcp_hdrlen ) <vul-end> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( \"unknown or invalid path-MTU (%u)\\\\n\" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <vul-start> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; if ( tcp_hdrlen < sizeof ( struct tcphdr ) ) return - 1 ; if ( <vul-start> ; if ( tcp_hdrlen < sizeof ( struct tcphdr ) ) return - 1 ; if (\n"
  },
  {
    "id": 792,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { <vul-start> up_read ( & card -> controls_rwsem ) ; <vul-end> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , <vul-start> & control -> id ) ; <vul-end> return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> 0 ) { struct snd_ctl_elem_id id = control -> id ; <vul-start> , SNDRV_CTL_EVENT_MASK_VALUE , & <vul-end> id ) ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 0 ) { struct snd_ctl_elem_id id = control -> id ; <vul-start> SNDRV_CTL_EVENT_MASK_VALUE, & <vul-end> id ) ;\n"
  },
  {
    "id": 793,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <vul-start> tok -> level = 0 ; <vul-end> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <vul-start> return tok ; <vul-end> }",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> level = 0 <vul-end> ; tok -> <vul-start> = 0 ; tok -> async_always = 0 ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> level = 1 ; tok -> type_comments = 0 ; tok -> type_comments_type = <vul-start> = 0 ; tok -> type_comments_type = 0 ;\n"
  },
  {
    "id": 794,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static zend_always_inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , zend_long elements , int objprops ) { while ( elements -- > 0 ) { zval key , * data , d , * old_data ; zend_ulong idx ; ZVAL_UNDEF ( & key ) ; if ( ! php_var_unserialize_internal ( & key , p , max , NULL , classes ) ) { zval_dtor ( & key ) ; return 0 ; } data = NULL ; ZVAL_UNDEF ( & d ) ; if ( ! objprops ) { if ( Z_TYPE ( key ) == IS_LONG ) { idx = Z_LVAL ( key ) ; numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_index_update ( ht , idx , & d ) ; } else { data = zend_hash_index_add_new ( ht , idx , & d ) ; } } else if ( Z_TYPE ( key ) == IS_STRING ) { if ( UNEXPECTED ( ZEND_HANDLE_NUMERIC ( Z_STR ( key ) , idx ) ) ) { goto numeric_key ; } if ( UNEXPECTED ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else { zval_dtor ( & key",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> 0 ; } <vul-end> var_push_dtor ( var_hash <vul-start> data ) ; <vul-end> zval_dtor ( &\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 0 ; } <vul-end> var_push_dtor ( var_hash <vul-start> data ) ; <vul-end> zval_dtor ( &\n"
  },
  {
    "id": 795,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 <vul-start> static void print_bpf_insn ( struct bpf_insn * insn ) <vul-end> { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( \"(%02x) %sr%d %s %sr%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> src_reg ) ; else verbose ( \"(%02x) %sr%d %s %s%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( \"(%02x) *(%s *)(r%d %+d) = r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( \"(%02x) lock *(%s *)(r%d %+d) += r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( \"BUG_%02x\\\\n\" , insn -> code ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> void print_bpf_insn ( const struct bpf_verifier_env * env , const <vul-start> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( \"(%02x) r%d = 0x%llx\\\\n\" , insn -> code , <vul-end> insn -> dst_reg <vul-start> -> dst_reg , ( unsigned long long ) <vul-end> imm ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> bpf_insn * insn, u32 insn_size <vul-start> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == insn_size <vul-start> -> code, bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ], <vul-start> -> dst_reg, bpf_jmp_string [ BPF_SIZE ( insn -> code ) >> 4 ],\n"
  },
  {
    "id": 796,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int irda_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct irda_sock * self ; <vul-start> if ( net != & init_net ) <vul-end> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_STREAM : case SOCK_SEQPACKET : case SOCK_DGRAM : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_IRDA , GFP_KERNEL , & irda_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; self = irda_sk ( sk ) ; pr_debug ( \"%s() : self is %p\\\\n\" , __func__ , self ) ; init_waitqueue_head ( & self -> query_wait ) ; switch ( sock -> type ) { case SOCK_STREAM : sock -> ops = & irda_stream_ops ; self -> max_sdu_size_rx = TTP_SAR_DISABLE ; break ; case SOCK_SEQPACKET : sock -> ops = & irda_seqpacket_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; case SOCK_DGRAM : switch ( protocol ) { # ifdef CONFIG_IRDA_ULTRA case IRDAPROTO_ULTRA : sock -> ops = & irda_ultra_ops ; self -> max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER ; self -> max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER ; break ; # endif case IRDAPROTO_UNITDATA : sock -> ops = & irda_dgram_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } sock_init_data ( sock , sk ) ; sk -> sk_family = PF_IRDA ; sk",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 ||\n"
  },
  {
    "id": 797,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <vul-start> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <vul-end> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( \"\" , \"TIFF scanline size is zero!\" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( \"\" , \"Strip %d: read %lu bytes, strip size %lu\" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( \"\" , \"Error reading strip %lu after %lu rows\" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> = 0 ; uint32 <vul-end> strip , nstrips\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = 0 ; int32 <vul-end> strip, nstrips\n"
  },
  {
    "id": 798,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <vul-start> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <vul-end> <vul-start> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <vul-end> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> desc_ptr dt ; unsigned long cr4 ; <vul-start> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <vul-end> ; vmcs_write16 (\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> desc_ptr dt ; # ifdef CONFIG_X86_64 vmcs_writel ( HOST_CR0, read_cr0 ( ) & ~ X86_CR0_TS ) ; # else <vul-start> X86_CR0_TS ) ; # endif\n"
  },
  {
    "id": 799,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <vul-start> s = tcp_recv ( NULL , 4 ) ; <vul-end> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <vul-start> if ( ! ber_in_header ( s , & tagval , & length ) || <vul-end> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <vul-start> in_uint8s ( s , length ) ; <vul-end> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> int tagval ; struct stream packet ; <vul-start> length ) ; packet = * s ; <vul-start> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cssp_read_tsrequest(), consume of version from stream would overrun\" , & packet ) ; } <vul-start> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cssp_read_tsrequest(), consume of token from stream would overrun\" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <vul-end> ; out_uint8p (\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> int tagval ; struct stream packet = * s ; <vul-start>, & length, & packet <vul-start> return False ; if (! s_check_rem ( s, length ) ) return False ;\n"
  },
  {
    "id": 800,
    "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) <vul-start> return ret ; <vul-end> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }",
    "golden_answers": [
      "CWE-772 Fixed Code Lines are: <vul-start> != 0 ) { kfree ( bo ) ; return ret ; } <vul-end> bo -> dumb\n"
    ],
    "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start>!= 0 ) goto err_bo_init <vul-end> ; bo ->\n"
  },
  {
    "id": 801,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; <vul-start> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <vul-end> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = \"/\" ; else path1 = cgdir ; <vul-start> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <vul-end> <vul-start> ret = - EACCES ; <vul-end> goto out ; } <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <vul-end> ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( \"cgfs_create returned %d for %s %s\\\\n\" , ret , controller , cgroup ) ; out : free ( cgdir ) ; <vul-start> return ret ; <vul-end> }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> , * controller , * next = NULL <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <vul-end> ) ) { <vul-start> ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <vul-end> ; goto out <vul-start> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <vul-start> cgdir ) ; free ( next ) ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, * controller, * caller <vul-start> O_RDWR ) ) <vul-end> goto out ; <vul-start> out ; } caller = caller_get_cgroup ( fc -> pid, controller, path1 ) ; if (! caller ) <vul-end> ret = cgfs_create <vul-start> ; return ret < 0? ret : - EPERM\n"
  },
  {
    "id": 802,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t nicSendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { error_t error ; <vul-start> bool_t status ; <vul-end> netContext . entropy += netGetSystemTickCount ( ) ; <vul-start> # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) <vul-end> size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( \"Sending packet (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , length ) ; TRACE_DEBUG_NET_BUFFER ( \" \" , buffer , offset , length ) ; # endif if ( interface -> configured && interface -> nicDriver != NULL ) { if ( interface -> nicDriver -> type == NIC_TYPE_LOOPBACK ) { status = TRUE ; } else { status = osWaitForEvent ( & interface -> nicTxEvent , NIC_MAX_BLOCKING_TIME ) ; } if ( status ) { interface -> nicDriver -> disableIrq ( interface ) ; error = interface -> nicDriver -> sendPacket ( interface , buffer , offset , ancillary ) ; if ( interface -> configured ) { interface -> nicDriver -> enableIrq ( interface ) ; } } else { error = NO_ERROR ; } } else { error = ERROR_INVALID_INTERFACE ; } return error ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> bool_t status ; # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( \"Sending packet (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , length ) ; TRACE_DEBUG_NET_BUFFER ( \"  \" , buffer , offset , length ) ; # endif <vul-start> ( ) ; <vul-end> if ( interface\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; bool_t status <vul-end> ; # if <vul-start> TRACE_LEVEL >= TRACE_LEVEL_DEBUG && netBufferGetLength ( buffer ) - offset > 0\n"
  },
  {
    "id": 803,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; } <vul-start> if ( av1 -> av1_config ) { <vul-end> GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> av1 -> av1_config && av1 -> av1_config -> config\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> maxBitrate ; } av1 -> emul_esd -> decoderConfig -> num_samples = 1 ;\n"
  },
  {
    "id": 804,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( \"dbfilename\" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , \"dbfilename can\\'t be a path, just a filename\" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( \"requirepass\" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"masterauth\" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"cluster-announce-ip\" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"maxclients\" ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { int class = <vul-end> getClientTypeByName ( v <vul-start> j ] ) ; if ( class <vul-start> == - 1 || class == CLIENT_TYPE_MASTER\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( clientHasNoArg ( c, <vul-start> j ] ) ) <vul-end> { sdsfreesplitres (\n"
  },
  {
    "id": 805,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , \"ID-kaart\" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , \"AS Sertifitseerimiskeskus\" ) ; sc_format_path ( \"3f00eeee5044\" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , \"select esteid PD failed\" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , \"read document number failed\" ) ; <vul-start> buff [ r ] = '\\\\0' ; <vul-end> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { \"Isikutuvastus\" , \"Allkirjastamine\" } ; static char const * esteid_cert_paths [ 2 ] = { \"3f00eeeeaace\" , \"3f00eeeeddce\" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ;",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <vul-end> ] = '\\\\0'\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> \"read document number failed\" ) ; if ( r < sizeof ( buff ) ) return SC_ERROR_INTERNAL ;\n"
  },
  {
    "id": 806,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( \"%s: metadata is null!\" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = \"camera_metadata\" , . alignment = METADATA_ALIGNMENT } , { . name = \"camera_metadata_buffer_entry\" , . alignment = ENTRY_ALIGNMENT } , { . name = \"camera_metadata_data\" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( \"%s: Metadata pointer is not aligned (actual %p, \" \"expected %p) to type %s\" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( \"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( \"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ERROR ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( \"%s: Data count (%\" PRIu32 \") should be <= data capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , \"30591838\" ) ; return ERROR ; }\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; } const metadata_size_t entries_end = ( metadata -> entries_start + metadata -> entry_capacity ) - ( metadata -> data_start + metadata -> data_capacity ) ; if ( entries_end < entries. entries_start || entries_end > metadata -> data_start ) { ALOGE ( \"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \" \"(%\" PRIu32 \")\", __FUNCTION__, ( metadata -> entries_start + metadata -> entry_capacity ), metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = ( metadata -> data_start + metadata -> data_capacity ) - ( metadata -> data_start ) ; if ( data_end < metadata -> entries_start || data_end > metadata -> data_capacity ) { ALOGE ( \"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \" \"(%\" PRIu32 \")\", __FUNCTION__, ( metadata -> data_start + metadata -> data_capacity ), metadata -> size ) ; return ERROR ; } const <vul-start> ERROR ; } <vul-end> for ( size_t\n"
  },
  {
    "id": 807,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) { <vul-start> const uint32_t c_w = <vul-end> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ; <vul-start> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <vul-end> match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] , <vul-start> img1 -> d_w ) == 0 ) ; <vul-end> for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> img2 ) { uint32_t l_w = img1 -> d_w ; <vul-end> uint32_t c_w = <vul-start> d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <vul-start> VPX_PLANE_Y ] , l_w <vul-end> ) == 0\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { const int is_valid = ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH )? 1 : 0 ; const <vul-start> d_h ) ; if ( is_valid ) { <vul-start> == 0 ) ; } else if ( is_valid ) { match = 0\n"
  },
  {
    "id": 808,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; <vul-start> ASSERT ( dpbSize ) ; <vul-end> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t *",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( \"b/28533562\" ) ; android_errorWriteLog ( 0x534e4554 , \"28533562\" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; ASSERT ( picSizeInMbs <vul-end> ) ; dpb\n"
  },
  {
    "id": 809,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int sysMapBlockFile ( FILE * mapf , MemMapping * pMap ) { char block_dev [ PATH_MAX + 1 ] ; size_t size ; unsigned int blksize ; <vul-start> unsigned int blocks ; <vul-end> unsigned int range_count ; unsigned int i ; if ( fgets ( block_dev , sizeof ( block_dev ) , mapf ) == NULL ) { LOGW ( \"failed to read block device from header\\\\n\" ) ; return - 1 ; } for ( i = 0 ; i < sizeof ( block_dev ) ; ++ i ) { if ( block_dev [ i ] == '\\\\n' ) { block_dev [ i ] = 0 ; break ; } } if ( fscanf ( mapf , \"%zu %u\\\\n%u\\\\n\" , & size , & blksize , & range_count ) != 3 ) { LOGW ( \"failed to parse block map header\\\\n\" ) ; return - 1 ; } <vul-start> blocks = ( ( size - 1 ) / blksize ) + 1 ; <vul-end> <vul-start> pMap -> range_count = range_count ; <vul-end> <vul-start> pMap -> ranges = malloc ( range_count * sizeof ( MappedRange ) ) ; <vul-end> <vul-start> memset ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) ) ; <vul-end> unsigned char * reserve ; reserve = mmap64 ( NULL , blocks * blksize , PROT_NONE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; if ( reserve == MAP_FAILED ) { LOGW ( \"failed to reserve address space: %s\\\\n\" , strerror ( errno ) ) ; <vul-start> return - 1 ; <vul-end> } <vul-start>",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> int blksize ; size_t <vul-end> blocks ; unsigned <vul-start> 1 ; } if ( blksize != 0 ) { <vul-start> + 1 ; } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( \"invalid data in block map file: size %zu, blksize %u, range_count %u\\\\n\" , size , blksize , range_count ) ; return - 1 ; } <vul-start> -> ranges = calloc ( range_count , <vul-end> sizeof ( MappedRange <vul-start> ) ) ; if <vul-end> ( pMap -> <vul-start> pMap -> ranges == NULL ) { LOGE ( \"calloc(%u, %zu) failed: %s\\\\n\" , range_count , <vul-end> sizeof ( MappedRange <vul-start> ( MappedRange ) , strerror ( errno ) ) ; return - 1 ; } <vul-end> unsigned char * <vul-start> ) ) ; free ( pMap -> ranges ) ; <vul-start> return - 1 ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( \"failed to open block device %s: %s\\\\n\" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , \"%zu %zu\\\\n\" , & start , & end ) != 2 ) { LOGW ( \"failed to parse range %d in block map\\\\n\" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( \"unexpected range in block map: %zu %zu\\\\n\" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( \"failed to map block %d: %s\\\\n\" , i , strerror ( errno ) ) ; success = false ; break <vul-start> -> ranges [ i <vul-end> ] . addr <vul-start> . addr = addr <vul-end> ; pMap -> <vul-start> -> ranges [ i <vul-end> ] . length <vul-start> . length = length <vul-end> ; next += <vul-start> ; next += length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( \"ranges in block map are invalid: remaining_size = %zu\\\\n\" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free ( <vul-start> pMap -> ranges ) ; return - 1 ; } close ( fd ) ; pMap -> addr = reserve ; pMap -> length <vul-end> = size ;\n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; unsigned int size64 ; unsigned int <vul-start> 1 ; } size64 = <vul-end> ( size - <vul-start> ) / blksize ; if ( size64 < 1 ) { LOGW ( \"failed to parse block map header\\\\n\" ) ; return - 1 ; } if ( size64 > UINT64_MAX / blksize ) { LOGW ( \"too large block map size: %zu\\\\n\", size64 ) ; return - 1 ; } if ( size64 > UINT64_MAX / blksize ) { LOGW ( \"too large block map size: %zu\\\\n\", size64 ) ; return - 1 ; } pMap -> ranges [ range_count - 1 ]. addr = reserve ; pMap -> ranges [ range_count - 1 ]. length = blocks * blksize ; pMap -> addr = reserve ; pMap -> length = size ; LOGI ( \"mmapped %d ranges\\\\n\", range_count ) ; return 0 ; } else { pMap -> ranges [ range_count - 1 ]. addr = reserve ; pMap -> ranges [ range_count - 1 ]. length = blocks * blksize ; int fd = open ( block_dev, O_RDONLY ) ; if ( fd < 0 ) { LOGW ( \"failed to open block device %s: %s\\\\n\", block_dev, strerror ( errno ) ) ; return - 1 ; } unsigned char * reserve ; reserve = mmap64 ( NULL, ( end - start ) * blksize, PROT_READ | MAP_PRIVATE | MAP_ANON, fd, ( ( off64_t ) start ) * blksize, PROT_READ, MAP_PRIVATE | MAP_ANON, fd, ( ( off64_t ) start ) * blksize, PROT_READ | MAP_ANON, fd, 0 ) ; if ( reserve == MAP_FAILED ) { LOGW ( \"failed to reserve address space: %s\\\\n\", strerror ( errno ) ) ; return - 1 ; } unsigned char * next = reserve ; for ( i = 0 ; i < range_count ; ++ i ) { int start, end ; if ( fscanf ( mapf, \"%d %d\\\\n\", & start, & end )!= 2 ) { LOGW ( \"failed to parse range %d in block map"
  },
  {
    "id": 810,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool extract_sockaddr ( struct pool * pool , char * url ) { char * url_begin , * url_end , * ipv6_begin , * ipv6_end , * port_start = NULL ; char url_address [ 256 ] , port [ 6 ] ; int url_len , port_len = 0 ; url_begin = strstr ( url , \"//\" ) ; if ( ! url_begin ) url_begin = url ; else url_begin += 2 ; ipv6_begin = strstr ( url_begin , \"[\" ) ; ipv6_end = strstr ( url_begin , \"]\" ) ; if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin ) url_end = strstr ( ipv6_end , \":\" ) ; else url_end = strstr ( url_begin , \":\" ) ; if ( url_end ) { url_len = url_end - url_begin ; port_len = strlen ( url_begin ) - url_len - 1 ; if ( port_len < 1 ) return false ; port_start = url_end + 1 ; } else url_len = strlen ( url_begin ) ; if ( url_len < 1 ) return false ; <vul-start> sprintf ( url_address , \"%.*s\" , url_len , url_begin ) ; <vul-end> if ( port_len ) snprintf ( port , 6 , \"%.*s\" , port_len , port_start ) ; else strcpy ( port , \"80\" ) ; free ( pool -> stratum_port ) ; pool -> stratum_port = strdup ( port ) ; free ( pool -> sockaddr_url ) ; pool -> sockaddr_url = strdup ( url_address ) ; return true ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , \"%s: Truncating overflowed address \\'%.*s\\'\" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return false ; snprintf ( url_address, sizeof ( url_address ) <vul-end>, \"%.*s\",\n"
  },
  {
    "id": 811,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , <vul-end> BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <vul-end> <vul-start> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-end> TOKENEXTRA * t_backup = * t ; const int ctx = vp9_get_skip_context ( xd ) ; <vul-start> const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <vul-end> SEG_LVL_SKIP ) ; <vul-start> struct tokenize_b_args arg = { cpi , xd , t } ; <vul-end> if ( mbmi -> skip ) { if ( ! dry_run ) <vul-start> cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ; <vul-end> reset_skip_context ( xd , bsize ) ; <vul-start> if ( dry_run ) <vul-end> * t = t_backup ; return ; } if ( ! dry_run ) { <vul-start> cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ; <vul-end> vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ; } else { vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ; <vul-start> * t = t_backup ; <vul-end> } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> -> common ; MACROBLOCK * const x = & td -> mb ; <vul-start> xd = & x -> <vul-end> e_mbd ; MB_MODE_INFO <vul-start> ] -> mbmi <vul-end> ; const int <vul-start> skip_inc = ! segfeature_active <vul-end> ( & cm <vul-start> { cpi , td <vul-end> , t } <vul-start> ! dry_run ) td -> counts -> <vul-end> skip [ ctx <vul-start> bsize ) ; <vul-end> return ; } <vul-start> dry_run ) { td -> counts -> <vul-end> skip [ ctx <vul-start> arg ) ; <vul-end> } }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, MACROBLOCKD * xd, <vul-start> & cpi -> td. <vul-start> ] -> mbmi <vul-end> ; const int <vul-start> ) ; const <vul-end> struct tokenize_b_args arg <vul-start> struct tokenize_b_args arg ; memset ( & arg, 0, sizeof ( arg ) ) <vul-start>! dry_run ) xd -> counts -> <vul-end> skip [ ctx <vul-start> 1 ] += vp9_skip_inc ; reset_skip_context ( xd, bsize ) <vul-end> ; return ; <vul-start> dry_run ) { xd -> counts -> <vul-end> skip [ ctx <vul-start> 0 ] += vp9_skip_inc ; vp9_foreach_transformed_block ( xd, bsize, tokenize_b, & arg ) ; } else { vp9_foreach_transformed_block ( xd, bsize, set_entropy_context_b, & arg ) ; * t = t_backup ; } } else { vp9_foreach_transformed_block ( xd, bsize, set_entropy_context_b, & arg ) ; * t = t_backup ; } } <vul-end>      \n"
  },
  {
    "id": 812,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> - ENOMEM ; <vul-end> dev -> rtnl_link_ops\n"
  },
  {
    "id": 813,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <vul-start> if ( cmd & 0x08 ) off",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ) off |= ( ( unsigned ) <vul-start> ++ << 24UL )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> cmd & 0x08 ) { if ( cmd & 0x10 ) len |= * delta ++ << 24UL ; else len |= * delta ++ << 24UL ; } <vul-end> if ( cmd\n"
  },
  {
    "id": 814,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , \"FORM\" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , \"XDIRINFO\" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , xmi_data , xmi_size ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> _XMI_Next_Event ; } else <vul-end> { _WM_GLOBAL_ERROR ( <vul-start>, __LINE__, WM_ERR_NOT_XMI, NULL, 0 ) ; goto _xmi_end ; } if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi, xmi_data, 0 ) ) == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0 ) ; goto _xmi_end ; } if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi, xmi_data, 0 ) ) == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0 ) ; goto _xmi_end ; } if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi, xmi_data, 0 ) ) == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__,\n"
  },
  {
    "id": 815,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val , <vul-start> struct pt_regs * regs , int nmi ) <vul-end> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <vul-start> if",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> pt_regs * regs <vul-end> ) { u64 <vul-start> ( event , <vul-end> & data ,\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> pt_regs * regs <vul-end> ) { u64 <vul-start> ( event, <vul-end> & data,\n"
  },
  {
    "id": 816,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block parameters invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 8 ) ; if ( s -> diff_start || s -> diff_height ) { avpriv_request_sample ( avctx, \"iframe\" ) ; return AVERROR_PATCHWELCOME ; }\n"
  },
  {
    "id": 817,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , \" #%u type=%s id=%s \" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <vul-start> < ep2 ) <vul-end> ND_PRINT ( (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, cp, ep2, map, nmap ) ; } else cp = ikev1_attr_print ( ndo, cp, ep2 ) ; } if ( cp < ep2 ) ND_PRINT ( ( ndo, \"...\" ) ) ; else ND_PRINT ( ( ndo, \" [|%s]\", NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if ( ep < ep2 ) ND_PRINT ( ( ndo, \" [|%s]\", NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) ND_PRINT ( ( ndo, \" [|%s]\", NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if ( cp == NULL ) goto trunc ; if"
  },
  {
    "id": 818,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <vul-start> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <vul-end> bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; bond_dev ->\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; bond_dev ->\n"
  },
  {
    "id": 819,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp9_receive_compressed_data ( VP9Decoder * pbi , <vul-start> size_t size , const uint8_t * * psource , <vul-end> int64_t time_stamp ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const uint8_t * source = * psource ; int retcode = 0 ; cm -> error . error_code = VPX_CODEC_OK ; if ( size == 0 ) { <vul-start> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <vul-end> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; } <vul-start> if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) <vul-end> <vul-start> cm -> release_fb_cb ( cm -> cb_priv , <vul-end> <vul-start> & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ; <vul-end> cm -> new_fb_idx = get_free_fb ( cm ) ; <vul-start> if ( setjmp ( cm -> error . jmp ) ) { <vul-end> <vul-start> cm -> error . setjmp = 0 ; <vul-end> <vul-start> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <vul-end> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return - 1 ; } cm -> error . setjmp = 1 ; <vul-start> retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ; <vul-end> <vul-start> if ( retcode < 0 ) {",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * * psource <vul-end> ) { VP9_COMMON <vul-start> { VP9_COMMON * volatile <vul-start> pbi -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <vul-start> ] . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <vul-end> cm -> frame_refs <vul-start> 1 ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && <vul-end> cm -> new_fb_idx <vul-start> >= 0 && <vul-end> frame_bufs [ cm <vul-start> == 0 ) pool <vul-end> -> release_fb_cb ( <vul-start> -> release_fb_cb ( pool <vul-end> -> cb_priv , <vul-start> cb_priv , & <vul-end> frame_bufs [ cm <vul-start> ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <vul-start> ) ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; <vul-start> = 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <vul-end> ; return - <vul-start> = 1 ; <vul-end> vp9_decode_frame ( pbi <vul-start> psource ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } <vul-end> cm -> error <vul-start> -> error . <vul-end> setjmp = 0 <vul-start> setjmp = 0 <vul-end> ; return retcode <vul-start> retcode ; } <vul-end>      \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_t size, ThreadData * td, <vul-start> pbi -> common ; ThreadData * const frame_buf = td -> frame_bufs <vul-start> 0 ) { int new_fb_idx = get_free_fb ( cm ) ; if ( new_fb_idx >= 0 ) { <vul-start> 1 ; } <vul-end> cm -> release_fb_cb <vul-start> -> cb_priv, frame_buf ) ; <vul-end> cm -> new_fb_idx <vul-start> cm ) ; } <vul-start> ; if ( frame_buf -> ref_count > 0 ) { <vul-end> if ( cm <vul-start> = 0 ; } if ( frame_buf -> ref_count > 0 ) { <vul-end> cm -> frame_bufs <vul-start> = 1 ; } <vul-start> ( pbi, frame_buf, <vul-start> size, psource, td <vul-start> 0 ) { if ( frame_buf -> <vul-end> error_code = VPX_CODE_ERROR <vul-start> = VPX_CODE_ERROR ; frame_buf -> <vul-end> ref_count -- ; <vul-start> retcode ; } if ( frame_buf -> new_fb_idx >= 0 ) { <vul-start> = 0 ; frame_buf -> new_fb_idx = get_free_fb ( cm ) ; <vul-start> = 1 ; } <vul-start> ( pbi, frame_buf, <vul-end> source + size <vul-start> size, psource, td <vul-start> 0 ) { if ( frame_buf -> <vul-end> error_code = VPX_CODE_ERROR <vul-start> = VPX_CODE_ERROR ; frame_buf -> <vul-end> ref_count -- ; <vul-start> retcode ; } if ( frame_buf -> new_fb_idx >= 0 ) { <vul-start> = 0 ; frame_buf -> new_fb_idx = get_free_fb ( cm ) ; } <vul-start> ( pbi, frame_buf, <vul-end> source + size <vul-start> size, psource, td\n"
  },
  {
    "id": 820,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> -> length , 0 ,\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> flags | RE_FLAGS_SCAN | RE_FLAGS_NOFOLLOW\n"
  },
  {
    "id": 821,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , <vul-start> int_mv * prev_golden_ref_mv , <vul-end> YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * golden_ref , const MV <vul-end> * prev_golden_ref_mv , <vul-start> & cpi -> td .\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * golden_ref, const <vul-start> & cpi -> td.\n"
  },
  {
    "id": 822,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type =",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> current_emoji_type ) ; if ( iter -> is_emoji ) { if ( current_emoji_type == PANGO_EMOJI_TYPE_INVALID && g_hash_table_get_size ( iter -> channels, current_emoji_type ) == 0 ) { iter -> is_emoji = FALSE ; break ; } }\n"
  },
  {
    "id": 823,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( \"Initializing child process\\\\n\" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( \"PID namespace installed\\\\n\" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( \"sethostname\" ) ; } if ( mount ( NULL , \"/\" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR \"/firejail\" , RUN_FIREJAIL_LIB_DIR , \"none\" , MS_BIND , NULL ) < 0 ) errExit ( \"mounting \" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( \"sandbox name:\" , cfg . name ) ; fs_logger2int ( \"sandbox pid:\" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( \"sandbox filesystem: chroot\" ) ; else if ( arg_overlay ) fs_logger ( \"sandbox filesystem: overlay\" ) ; else fs_logger ( \"sandbox filesystem: local\" ) ; fs_logger ( \"install mount namespace\" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( \"lo\"",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> save_cpu ( ) <vul-start> rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <vul-end> FILE * rj\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; set_caps ( <vul-end> ) ; save_cpu <vul-start> ; set_caps ( <vul-end> ) ; set_cpu\n"
  },
  {
    "id": 824,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <vul-start> opj_write_bytes ( p_data , J2K_MS_SOD , <vul-end> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot encode tile\\\\n\" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not enough bytes in output buffer to write SOD marker\\\\n\" ) ; return OPJ_FALSE ; }\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> p_stream ) ; if ( p_total_data_size < J2K_MS_SOD + 4 ) { opj_event_msg ( p_manager, EVT_ERROR, \"opj_tcd_write_sod: Too many bytes for SOD\\\\n\" ) ; return FALSE ; }\n"
  },
  {
    "id": 825,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int mwifiex_ret_wmm_get_status ( struct mwifiex_private * priv , const struct host_cmd_ds_command * resp ) { u8 * curr = ( u8 * ) & resp -> params . get_wmm_status ; uint16_t resp_len = le16_to_cpu ( resp -> size ) , tlv_len ; int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK ; bool valid = true ; struct mwifiex_ie_types_data * tlv_hdr ; struct mwifiex_ie_types_wmm_queue_status * tlv_wmm_qstatus ; struct ieee_types_wmm_parameter * wmm_param_ie = NULL ; struct mwifiex_wmm_ac_status * ac_status ; mwifiex_dbg ( priv -> adapter , INFO , \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\\\n\" , resp_len ) ; while ( ( resp_len >= sizeof ( tlv_hdr -> header ) ) && valid ) { tlv_hdr = ( struct mwifiex_ie_types_data * ) curr ; tlv_len = le16_to_cpu ( tlv_hdr -> header . len ) ; if ( resp_len < tlv_len + sizeof ( tlv_hdr -> header ) ) break ; switch ( le16_to_cpu ( tlv_hdr -> header . type ) ) { case TLV_TYPE_WMMQSTATUS : tlv_wmm_qstatus = ( struct mwifiex_ie_types_wmm_queue_status * ) tlv_hdr ; mwifiex_dbg ( priv -> adapter , CMD , \"info: CMD_RESP: WMM_GET_STATUS:\\\\t\" \"QSTATUS TLV: %d, %d, %d\\\\n\" , tlv_wmm_qstatus -> queue_index , tlv_wmm_qstatus -> flow_required , tlv_wmm_qstatus -> disabled ) ; ac_status = & priv -> wmm . ac_status [ tlv_wmm_qstatus -> queue_index ] ; ac_status -> disabled = tlv_wmm_qstatus -> disabled ; ac_status -> flow_required = tlv_wmm_qstatus -> flow_required ; ac_status -> flow_created = tlv_wmm_qstatus -> flow_created ; break ; case WLAN_EID_VENDOR_SPECIFIC : wmm_param_ie = ( struct ieee_types_wmm_parameter * ) ( curr + 2 ) ; wmm_param_ie -> vend_hdr . len = ( u8 ) tlv_len ; wmm_param_ie",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> mask ) ; if ( wmm_param_ie -> vend_hdr. len + 2 > sizeof ( struct mwifiex_types_wmm_parameter ) ) { mwifiex_dbg ( priv -> adapter, ERROR, \"Invalid param length!\\\\n\" ) ; break ; }\n"
  },
  {
    "id": 826,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( \"%s: fd = %d, changedlockstates = 0x%x\" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting CAPSLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting NUMLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting SCROLLLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( \"Writing hidreport #1 to os: \" \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <vul-start> usleep ( 200000 ) ; <vul-end> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( \"Writing hidreport #2 to os: \"",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ) ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 200000 )\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 200000 )\n"
  },
  {
    "id": 827,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <vul-start> struct ipv6_pinfo * np = inet6_sk ( sk ) ; <vul-end> struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , &",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <vul-start> } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <vul-end> if ( flowlabel <vul-start> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( sk ) ; struct ipv6_txoptions * opt_to_free <vul-start> ; out : opt_to_free = opt ; <vul-start> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free\n"
  },
  {
    "id": 828,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ; <vul-start> unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; <vul-end> unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ; <vul-start> uint32_t valign , falign , hdr_size , j ; <vul-end> struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int i , j , <vul-start> overlays = 0 , rescan = 1 <vul-start> falign , hdr_size <vul-end> ; struct cli_exe_section <vul-start> ; # endif while ( rescan == 1 ) { rescan = 0 ; <vul-start> ++ ) { exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( \"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\\\n\" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , \"Heuristics.Broken.Executable\" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <vul-start> ] = 0 <vul-end> ; # if <vul-start> rsz ) { <vul-end> if ( SCAN_ALGO\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> max = 0, opt_size = 0 <vul-start> hdr_size, j ; const char * const epbuff_copy [ 1024 ], * epbuff_copy [ 1024 ] <vul-start> ; # endif epbuff_copy = memalign ( epbuff, sizeof ( epbuff ), GFP_KERNEL ) ; if ( epbuff_copy == NULL ) { return CL_FAULTOUT ; } <vul-start> ; if ( epbuff_copy == NULL ) { # if HAVE_JSON if ( ( pe_json ) ) cli_jsonstr ( pe_json, \"Type\", \"Default\" ) ; # endif cli_append_virus ( ctx, \"Default. Executable\" ) ; return CL_VIRUS ; } <vul-start> ; if ( opt_size > sizeof ( epbuff ) ) { ret = CL_ETIMEOUT ; goto out ; } if (\n"
  },
  {
    "id": 829,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req ->",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt )\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <vul-start> ( & fl6, rcu_dereference ( <vul-end> np -> opt <vul-start> np -> opt ) <vul-start>, & final )\n"
  },
  {
    "id": 830,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; ue -> card = card ; ue ->\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> - ENOMEM ; memset ( & kctl, 0, sizeof ( kctl ) ) ;\n"
  },
  {
    "id": 831,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ;",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; } if (! shrink ) { inode -> i_size = ext4_get_node_size ( inode ) ; <vul-start> inode ) ; }\n"
  },
  {
    "id": 832,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void save_bt_to_dump_dir ( const char * bt , const char * exe , const char * reason ) { time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! ( g_opts & OPT_x ) ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <vul-start> pid_t my_pid = getpid ( ) ; <vul-end> char base [ sizeof ( \"xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu\" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , \"xorg-%s-%lu-%u\" , iso_date , ( long ) my_pid , g_bt_count ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , \"xorg\" ) ; dd_save_text ( dd , FILENAME_TYPE , \"xorg\" ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; dd_save_text ( dd , FILENAME_BACKTRACE , bt ) ; if ( ! exe ) { exe = \"/usr/bin/X\" ; if ( access ( \"/usr/bin/Xorg\" , X_OK ) == 0 ) exe = \"/usr/bin/Xorg\" ; } dd_save_text ( dd , FILENAME_EXECUTABLE , exe ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } free ( path ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( \"Not going to make dump directories world readable because PrivateReports is on\" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ; } if ( g_opts & OPT_i ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }\n"
  },
  {
    "id": 833,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; BITS_PARSE ( \"video_parameter_set_id\" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( \"sps_max_sub_layers_minus1\" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( \"sps_temporal_id_nesting_flag\" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( \"seq_parameter_set_id\" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( \"chroma_format_idc\" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value ; if ( ps_sps ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <vul-start> = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> + 1 ; if ( ( ps_sps -> i1_sps_max_num_reorder_pics >= MAX_SPS_NT ) || ( ps_sps -> i1_sps_max_num_pic_layers_minus1\", value, ps_bitstrm, MAX_SPS_NT - 1 ) ) { return IHEVCD_INVALID_PARAMETER ; }\n"
  },
  {
    "id": 834,
    "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <vul-start> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <vul-end> { mutt_error ( _ ( \"Bad mailbox name\" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , \"INBOX\" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <vul-start> snprintf ( mbox , sizeof ( mbox ) , \"%smailboxes \\\\\"%s\\\\\"\" , subscribe ? \"\" : \"un\" , path ) ; <vul-end> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , \"Error adding subscribed mailbox: %s\\\\n\" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( \"Subscribing to %s...\" ) , buf ) ; else mutt_message ( _ ( \"Unsubscribing from %s...\" ) , buf ) ; imap_munge_mbox_name ( idata , mbox",
    "golden_answers": [
      "CWE-78 Fixed Code Lines are: <vul-start> ImapMbox mx ; size_t len = 0 ; <vul-start> errstr ) ; len = <vul-start> mbox ) , \"%smailboxes \" <vul-end> , subscribe ? <vul-start> \"\" : \"un\" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> ImapMbox mx ; char * s ; <vul-start> errstr ) ; s = mutt_strdup ( path ) ; if (! s ) goto fail ; <vul-start> \"un\", path ) ; mutt_free ( s\n"
  },
  {
    "id": 835,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <vul-start> isoclns_print ( ndo , p , length , length ) ; <vul-end> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , \"compressed PPP data\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"%s \" , tok2str ( ppptype2str , \"unknown PPP protocol (0x%04x)\" , proto",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> p , length <vul-end> ) ; break\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> p, length <vul-end> ) ; break\n"
  },
  {
    "id": 836,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <vul-start> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <vul-end> rc -> frames_to_key == 0 || <vul-start> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <vul-end> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <vul-start> rc -> frames_to_key = cpi -> key_frame_frequency ; <vul-end> rc -> kf_boost = DEFAULT_KF_BOOST ; <vul-start> rc -> source_alt_ref_active = 0 ; <vul-end> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <vul-start> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <vul-end> <vul-start> } <vul-end> vp9_rc_set_frame_target ( cpi , target ) ; <vul-start> rc -> frames_till_gf_update_due = INT_MAX ; <vul-end> rc -> baseline_gf_interval = INT_MAX ; }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 0 || ( cpi <vul-end> -> frame_flags & <vul-start> . auto_key && 0 <vul-end> ) ) ) <vul-start> = cpi -> oxcf . key_freq <vul-end> ; rc -> <vul-start> source_alt_ref_active = 0 <vul-end> ; } else <vul-start> = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <vul-end> calc_pframe_target_size_one_pass_cbr ( cpi <vul-start> cpi ) ; <vul-end> vp9_rc_set_frame_target ( cpi <vul-start> target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0 || ( cpi <vul-end> -> frame_flags & <vul-start>. auto_key && ( cpi -> oxcf. key_freq == KEY_FREQ_8X8 || cpi -> oxcf. key_freq == KEY_FREQ_10X8 ) ) || ( cpi -> oxcf. auto_key && <vul-start> = cpi -> oxcf. key_freq <vul-end> ; rc -> <vul-start> ; rc -> kf_boost = DEFAULT_KF_BOOST ; rc -> <vul-start> ; target = calc_iframe_target_size_one_pass_cbr_target <vul-end> ( cpi ) <vul-start> ) ; } if ( cpi -> oxcf. auto_key ) { target = calc_pframe_target_size_one_pass_cbr_target_key ( cpi ) ; } else { target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } <vul-start> ; rc -> <vul-end> baseline_gf_interval = INT_MAX\n"
  },
  {
    "id": 837,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <vul-start> u8 * data , * output ; <vul-end> <vul-start> u32 pck_size , prev_pck_size ; <vul-end> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <vul-start> } <vul-end> <vul-start> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <vul-end> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> u8 * data = NULL <vul-start> ; u32 pck_size = 0 <vul-start> ; } } else { <vul-start> pck_size ) ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> u32 pos ; u32 pck_size ; <vul-start>, * output ; u64 cts = GF_FILTER_NO_TS ; u8 * data ; u32 prev_pck_size <vul-end> ; if ( <vul-start> GF_OK ; } } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck &&! ctx -> resume_from ) { if ( ctx -> latm_buffer_alloc ||! ctx -> src_pck ) { gf_filter_pid_unref ( ctx -> ipid ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } data = ( char * ) gf_filter_pck_get_data ( pck, & pck_size ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) { gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } if ( ctx -> in_seek ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } } if (! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer, ctx -> latm_buffer_size, GF_BITSTREAM_READ ) ; else { if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; if ( ctx -> timescale && pck ) { cts = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; ctx -> prev_pck_size = ctx -> latm_buffer_size ; if ( pck &&! ctx -> resume_from ) { if"
  },
  {
    "id": 838,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int VP8_UVSSE ( MACROBLOCK * x ) { unsigned char * uptr , * vptr ; unsigned char * upred_ptr = ( * ( x -> block [ 16 ] . base_src ) + x -> block [ 16 ] . src ) ; unsigned char * vpred_ptr = ( * ( x -> block [ 20 ] . base_src ) + x -> block [ 20 ] . src ) ; int uv_stride = x -> block [ 16 ] . src_stride ; unsigned int sse1 = 0 ; unsigned int sse2 = 0 ; int mv_row = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . row ; int mv_col = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . col ; int offset ; int pre_stride = x -> e_mbd . pre . uv_stride ; if ( mv_row < 0 ) mv_row -= 1 ; else mv_row += 1 ; if ( mv_col < 0 ) mv_col -= 1 ; else mv_col += 1 ; mv_row /= 2 ; mv_col /= 2 ; offset = ( mv_row >> 3 ) * pre_stride + ( mv_col >> 3 ) ; uptr = x -> e_mbd . pre . u_buffer + offset ; vptr = x -> e_mbd . pre . v_buffer + offset ; if ( ( mv_row | mv_col ) & 7 ) { <vul-start> vp8_sub_pixel_variance8x8 ( uptr , pre_stride , <vul-end> mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ; <vul-start> vp8_sub_pixel_variance8x8 ( vptr , pre_stride , <vul-end>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 7 ) { vpx_sub_pixel_variance8x8 <vul-end> ( uptr , <vul-start> sse2 ) ; vpx_sub_pixel_variance8x8 <vul-end> ( vptr , <vul-start> } else { vpx_variance8x8 <vul-end> ( uptr , <vul-start> sse2 ) ; vpx_variance8x8 <vul-end> ( vptr ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 7 ) { sub_pixel_variance8x8 <vul-end> ( uptr, <vul-start> sse2 ) ; sub_pixel_variance8x8 <vul-end> ( vptr, <vul-start> } else { sub_pixel_variance8x8 <vul-end> ( uptr, <vul-start> sse2 ) ; sub_pixel_variance8x8 <vul-end> ( vptr,\n"
  },
  {
    "id": 839,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , <vul-end> int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) { MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ; <vul-end> int plane ; int pnrate = 0 , pnskip = 1 ; int64_t pndist = 0 , pnsse = 0 ; <vul-start> if ( ref_best_rd < 0 ) <vul-end> <vul-start> goto term ; <vul-end> <vul-start> if ( is_inter_block ( mbmi ) ) { <vul-end> int plane ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ; } * rate = 0 ; * distortion = 0 ; * sse = 0 ; * skippable = 1 ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) { txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse , <vul-start> ref_best_rd , plane , bsize , uv_txfm_size , <vul-end> cpi -> sf . use_fast_coef_costing ) ; if ( pnrate == INT_MAX ) <vul-start> goto term ; <vul-end> * rate += pnrate ; * distortion += pndist ; * sse += pnsse ; * skippable &= pnskip ; } <vul-start> return ; <vul-end> term : * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> super_block_uvrd ( const <vul-start> -> mbmi ; const TX_SIZE uv_tx_size <vul-end> = get_uv_tx_size ( <vul-start> get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <vul-start> = 0 ; int is_cost_valid = 1 ; <vul-start> < 0 ) is_cost_valid = 0 <vul-end> ; if ( <vul-start> ( mbmi ) && is_cost_valid <vul-start> , bsize , uv_tx_size <vul-end> , cpi -> <vul-start> == INT_MAX ) { is_cost_valid = 0 ; break ; } <vul-end> * rate += <vul-start> pnskip ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> super_uvrd ( const <vul-start> TX_SIZE uv_txfm_size = xd -> mbmi. mbmi_ext_info. txfm_size <vul-end> ; int plane <vul-start> < 0 ) { <vul-start> goto term ; } <vul-start> ( mbmi ) && xd -> mbmi. mbmi_ext_info. skippable_txfm_skippable <vul-start> == INT_MAX ) { <vul-start> goto term ; } <vul-start> pnskip ; } xd -> mbmi. mbmi_ext_info. skippable_txfm_skippable = 0 ;\n"
  },
  {
    "id": 840,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> int sctp_verify_asconf ( const struct sctp_association * asoc , <vul-end> <vul-start> struct sctp_paramhdr * param_hdr , void * chunk_end , <vul-end> struct sctp_paramhdr * * errp ) { <vul-start> sctp_addip_param_t * asconf_param ; <vul-end> union sctp_params param ; <vul-start> int length , plen ; <vul-end> <vul-start> param . v = ( sctp_paramhdr_t * ) param_hdr ; <vul-end> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start>       bool <vul-end> sctp_verify_asconf ( const <vul-start> asoc , struct sctp_chunk * chunk , bool addr_param_needed <vul-end> , struct sctp_paramhdr <vul-start> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <vul-end> ; union sctp_params <vul-start> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <vul-end> param . v <vul-start> param . v != chunk -> chunk_end ) return false ; return true <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> asoc, struct sctp_params * param, const <vul-start> void * chunk_end <vul-end>, struct sctp_paramhdr <vul-start> errp ) { sctp_addip_param_t * addip = ( sctp_addip_param_t * ) param. p ; <vul-start> sctp_params param ; __u32 param_hdr_len = sizeof ( sctp_paramhdr_t ) + param. p -> param_hdr. length ; sctp_walk_params ( param, addip, param_hdr_len, errp ) { sctp_paramhdr_t * addip_hdr = ( sctp_paramhdr_t * ) param. p ; <vul-end> param. v <vul-start> * ) param_hdr ; if ( addip -> param_hdr. p -> type == SCTP_PARAM_ADDIP || addip -> param_hdr. p -> type == SCTP_PARAM_DEL_IP || addip -> param_hdr. p -> type == SCTP_PARAM_SET_PRIMARY ) addip_hdr -> param_hdr. v = ( sctp_paramhdr_t * ) param. p\n"
  },
  {
    "id": 841,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) { <vul-start> if ( vma -> vm_ops ) { <vul-end> if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte , <vul-start> pmd , flags , entry ) ; <vul-end> } return do_anonymous_page ( mm , vma , address , <vul-start> pte , pmd , flags ) ; <vul-end> } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache (",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> -> vm_ops ) <vul-end> return do_fault ( <vul-start> , pte , pmd , flags , entry ) ; <vul-end> return do_anonymous_page ( <vul-start> , address , pte , pmd , <vul-end> flags ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) { struct page_struct * pgd = pte_to_page ( * pte ) ; if ( unlikely (! pgd_none ( pgd ) ) ) goto skip_mm ; <vul-start>, pte, pgd, <vul-start>, pmd, pgd, <vul-start>, flags ) ; skip_mm : if ( pgd_none ( pgd ) ) goto skip_mm\n"
  },
  {
    "id": 842,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <vul-end> } else {\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> case S_IFDIR : if ( di_size == 0 ) return __this_address ;\n"
  },
  {
    "id": 843,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int hidp_setup_hid ( struct hidp_session * session , struct hidp_connadd_req * req ) { struct hid_device * hid ; int err ; session -> rd_data = kzalloc ( req -> rd_size , GFP_KERNEL ) ; if ( ! session -> rd_data ) return - ENOMEM ; if ( copy_from_user ( session -> rd_data , req -> rd_data , req -> rd_size ) ) { err = - EFAULT ; goto fault ; } session -> rd_size = req -> rd_size ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { err = PTR_ERR ( hid ) ; goto fault ; } session -> hid = hid ; hid -> driver_data = session ; hid -> bus = BUS_BLUETOOTH ; hid -> vendor = req -> vendor ; hid -> product = req -> product ; hid -> version = req -> version ; hid -> country = req -> country ; <vul-start> strncpy ( hid -> name , req -> name , 128 ) ; <vul-end> snprintf ( hid -> phys , sizeof ( hid -> phys ) , \"%pMR\" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ; snprintf ( hid -> uniq , sizeof ( hid -> uniq ) , \"%pMR\" , & bt_sk ( session -> ctrl_sock -> sk ) -> dst ) ; hid -> dev . parent = & session -> conn -> dev ; hid -> ll_driver = & hidp_hid_driver ; hid -> hid_get_raw_report = hidp_get_raw_report ; hid -> hid_output_raw_report = hidp_output_raw_report ; if ( hid_ignore ( hid",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> -> name , sizeof ( req -> name ) - 1 <vul-end> ) ; snprintf\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> -> country ; strlcpy <vul-end> ( hid ->\n"
  },
  {
    "id": 844,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> , buffer , t2p -> tiff_datasize ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, & bufferoffset <vul-end>, i,\n"
  },
  {
    "id": 845,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ;",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> -> opt : rcu_dereference ( <vul-start> np -> opt ) <vul-start> , & final ) ; rcu_read_unlock (\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> -> opt ; rcu_read_unlock ( ) ; <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt ), & final ) ; rcu_read_lock ( <vul-end> ) ; dst\n"
  },
  {
    "id": 846,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <vul-end> { jas_matrix_t * matrix ; <vul-start> int i ; <vul-end> size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix ->",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> * jas_matrix_create ( jas_matind_t numrows , jas_matind_t <vul-end> numcols ) { <vul-start> * matrix ; jas_matind_t <vul-end> i ; size_t\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * jas_matrix_create ( jas_matind_t numrows, jas_matind_t <vul-end> numcols ) { <vul-start> * matrix ; jas_matind_t <vul-end> i ; size_t\n"
  },
  {
    "id": 847,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && <vul-start> ! inode_capable ( inode , CAP_CHOWN ) ) <vul-end> return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && <vul-start> ! inode_capable ( inode , CAP_CHOWN ) ) <vul-end> return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <vul-start> ! inode_capable ( inode , CAP_FSETID ) ) <vul-end> attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode , <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode , <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode ,\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode, <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode, <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode, <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode,\n"
  },
  {
    "id": 848,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; <vul-start> int family = sk -> sk_family ; <vul-end> struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( \"ping_recvmsg(sk=%p,sk->num=%u)\\\\n\" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <vul-start> if ( addr_len ) { <vul-end> if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> sk -> sk_family <vul-end> ; struct sk_buff <vul-start> goto out ; <vul-end> if ( flags <vul-start> AF_INET ) { struct sockaddr_in * <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ; <vul-start> skb ) ; <vul-end> struct sockaddr_in6 * <vul-start> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin6\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> sk -> sk_family <vul-end> ; struct sk_buff <vul-start> ; if ( addr_len && family == AF_INET ) { struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; sin = ( struct sockaddr_in * ) msg -> msg_name ; sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr. s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero, 0, sizeof ( sin -> sin_zero ) ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk, msg, len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } else if ( family == AF_INET6 ) { return ipv6_iface_scope_id ( & sin6 -> sin6_addr, IP6CB ( skb ) -> iif ) ; } if ( <vul-start> AF_INET ) { * addr_len = sizeof ( * sin ) ; * <vul-end> sin6 = ( <vul-start> struct sockaddr_in6 * <vul-end> sin6 = ( <vul-start> ) msg -> msg_name ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_CHECKSUM ) { * addr_len = sizeof ( * sin6 ) ; * addr_len = sizeof ( * sin6 ) ; } else { * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_CHECKSUM ) { * addr_len = sizeof ( * sin6 ) ; } else { * addr_len = sizeof ( * sin6 ) ; } if ( addr_len ) { * addr_len = sizeof ( * sin6"
  },
  {
    "id": 849,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; <vul-start> if ( ! port -> interrupt_in_urb ) { <vul-end> dev_err ( & port -> dev , \"%s - interrupt_in_urb is empty!\\\\n\" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , \"%s - failed submitting read urb, error %d\\\\n\" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> tmp_termios ) ; <vul-end> usb_fill_int_urb ( port\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( port -> interrupt_in_urb ) { dev_err ( & port -> dev, \"interrupt_in_urb is empty!\\\\n\" ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb, serial -> dev, usb_rcvintpipe ( serial -> dev, port -> interrupt_in_endpointAddress ), port -> interrupt_in_urb -> transfer_buffer, port -> interrupt_in_urb -> transfer_buffer_length, cypress_read_int_callback, port, priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb, GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev, \"failed submitting read urb, error %d\\\\n\", result ) ; cypress_set_dead ( port ) ; } return result <vul-end> ; }  \n"
  },
  {
    "id": 850,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <vul-start> . pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; } else { <vul-end> po -> tp_version <vul-start> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <vul-end> } case PACKET_RESERVE\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>. pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; goto out ; } <vul-start> val ) ) ) { ret = - EINVAL ; goto out ; } <vul-end> switch ( val <vul-start> = val ; ret = 0 ; out :\n"
  },
  {
    "id": 851,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <vul-start> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <vul-end> <vul-start> addModuleArgument ( db , pTab , 0 ) ; <vul-end> <vul-start> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <vul-end> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , \"%s\" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab , <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab , <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab ,\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab, <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab, <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab,\n"
  },
  {
    "id": 852,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , \"8BIM\" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> size_t ) count + 1\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) AcquireQuantumMemory ( <vul-end> count, sizeof\n"
  },
  {
    "id": 853,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) { struct rtable * rt ; const struct inet_request_sock * ireq = inet_rsk ( req ) ; <vul-start> struct ip_options * opt = inet_rsk ( req ) -> opt ; <vul-end> struct net * net = sock_net ( sk ) ; struct flowi4 fl4 ; flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) , <vul-start> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <vul-end> ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) goto no_route ; <vul-start> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <vul-end> goto route_err ; return & rt -> dst ; route_err : ip_rt_put ( rt ) ; no_route : IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; return NULL ; }",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu <vul-end> * opt = <vul-start> && opt -> opt . <vul-start> ? opt -> opt . <vul-start> && opt -> opt .\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu * inet_opt <vul-end> = inet_rsk ( <vul-start> ( req ) <vul-end> ; struct net <vul-start> ), ( inet_opt && inet_opt -> opt. <vul-end> srr )? <vul-start>? opt -> opt. <vul-start> ; if ( inet_opt && inet_opt -> opt. <vul-end> is_strictroute && rt\n"
  },
  {
    "id": 854,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> outbuff ) - 128 <vul-end> ) ) {\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } if ( ( i + 20 ) >= sizeof ( outbuff ) ) { fprintf ( f, \"%s\", outbuff ) ; i = 0 ; } if (\n"
  },
  {
    "id": 855,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int test_candidate_kf ( struct twopass_rc * twopass , <vul-end> const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ; <vul-start> if ( ( this_frame -> pcnt_second_ref < 0.10 ) && <vul-end> <vul-start> ( next_frame -> pcnt_second_ref < 0.10 ) && <vul-end> ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && <vul-end> ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) || <vul-end> ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) || <vul-end> ( ( next_frame -> intra_error / <vul-start> DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { <vul-end> int i ; const FIRSTPASS_STATS * start_pos = twopass -> stats_in ; FIRSTPASS_STATS local_next_frame = * next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; for ( i = 0 ; i < 16 ; ++ i ) { <vul-start> double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / <vul-end> DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ; <vul-start> if ( next_iiratio > RMAX ) <vul-end> next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator *= local_next_frame . pcnt_inter ; else decay_accumulator *=",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> int test_candidate_kf ( TWO_PASS <vul-end> * twopass , <vul-start> = 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; <vul-start> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH <vul-end> ) && ( <vul-start> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <vul-end> ) && ( <vul-start> ) ) < KF_II_ERR_THRESHOLD <vul-end> ) && ( <vul-start> coded_error ) > ERR_CHANGE_THRESHOLD <vul-end> ) || ( <vul-start> intra_error ) > ERR_CHANGE_THRESHOLD <vul-end> ) || ( <vul-start> ) ) > II_IMPROVEMENT_THRESHOLD <vul-end> ) ) ) <vul-start> next_iiratio = ( BOOST_FACTOR <vul-end> * local_next_frame . <vul-start> ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int test_candidate_kf ( TWO_PASS <vul-end> * twopass, <vul-start> ; if ( twopass -> num_temporal_layers == 1 && <vul-start> this_frame -> pcnt_second_ref >= <vul-end> 0.10 ) && <vul-start> next_frame -> pcnt_second_ref >= <vul-end> 0.10 ) && <vul-start> this_frame -> intra_error / <vul-end> DOUBLE_DIVIDE_CHECK ( this_frame <vul-start> coded_error ) ) < 2.5 ) || ( fabs ( last_frame -> coded_error - <vul-end> this_frame -> coded_error <vul-start> coded_error ) / <vul-end> DOUBLE_DIVIDE_CHECK ( this_frame <vul-start> intra_error ) / <vul-end> DOUBLE_DIVIDE_CHECK ( this_frame <vul-start> coded_error ) > 0.40 ) || ( fabs ( next_frame -> intra_error / <vul-end> DOUBLE_DIVIDE_CHECK ( next_frame <vul-start> ) ) > 3.5 ) ) ) || ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) > <vul-end> 3.5 ) ) <vul-start> ) { double decay_error <vul-end> = ( IIKFACTOR1 <vul-start> local_next_frame. intra_error / <vul-end> DOUBLE_DIVIDE_CHECK ( local_next_frame <vul-start> ) ) ; const FIRSTPASS_STATS * start_pos = twopass -> stats_in ; FIRSTPASS_STATS * local_next_frame = * next_frame ; double boost_score = 0.0 ; double old_boost_score = boost_score ; if ( twopass -> stats_out > twopass -> stats_in ) { is_viable_kf = 1 ; } else { is_viable_kf = 0 ; } if ( ( local_frame. pcnt_inter < 0.05 ) && ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> coded_error / <vul-end> DOUBLE_DIVIDE_CHECK ( this_frame <vul-start> coded_error ) > 0.40 ) || ( fabs ( last_frame -> intra"
  },
  {
    "id": 856,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , \"invalid insn idx %d insn_cnt %d\\\\n\" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , \"BPF program is too large. Processed %d insn\\\\n\" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , \"\\\\nfrom %d to %d: safe\\\\n\" , prev_insn_idx , insn_idx ) ; else verbose ( env , \"%d: safe\\\\n\" , insn_idx ) ; } goto process_bpf_exit ; } if",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <vul-start> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( is_alu_op_state ( env, insn ) ) { err = check_alu_op ( env, insn ) ; if ( err ) return err ; } else if ( <vul-start> ; if ( is_ldx_reg ( env, insn ) ) { err = check_indirect_reg ( env, insn, insn_idx ) ; if ( err ) return err ; } if (\n"
  },
  {
    "id": 857,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyMODINIT_FUNC PyInit__ast3 ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ; <vul-start> m = PyModule_Create ( & _astmodule3 ) ; <vul-end> if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , \"AST\" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"mod\" , ( PyObject * ) mod_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Module\" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Interactive\" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Expression\" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionType\" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Suite\" , ( PyObject * ) Suite_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"stmt\" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionDef\" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"AsyncFunctionDef\" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if (",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> PyModule_Create ( & _astmodule <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> PyModule_Create ( & _astmodule3_0 <vul-end> ) ; if\n"
  },
  {
    "id": 858,
    "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static int download ( struct SPDBDownloader * pd ) { SPDBDownloaderOpt * opt = pd -> opt ; <vul-start> char * curl_cmd = NULL ; <vul-end> char * extractor_cmd = NULL ; char * abspath_to_archive = NULL ; char * abspath_to_file = NULL ; char * archive_name = NULL ; size_t archive_name_len = 0 ; char * symbol_store_path = NULL ; char * dbg_file = NULL ; char * guid = NULL ; char * archive_name_escaped = NULL ; char * user_agent = NULL ; char * symbol_server = NULL ; int res = 0 ; int cmd_ret ; if ( ! opt -> dbg_file || ! * opt -> dbg_file ) { return 0 ; } <vul-start> if ( ! checkCurl ( ) ) { <vul-end> return 0 ; } archive_name_len = strlen ( opt -> dbg_file ) ; archive_name = malloc ( archive_name_len + 1 ) ; if ( ! archive_name ) { return 0 ; } memcpy ( archive_name , opt -> dbg_file , archive_name_len + 1 ) ; archive_name [ archive_name_len - 1 ] = '_' ; <vul-start> symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ; <vul-end> dbg_file = r_str_escape ( opt -> dbg_file ) ; guid = r_str_escape ( opt -> guid ) ; archive_name_escaped = r_str_escape ( archive_name ) ; user_agent = r_str_escape ( opt -> user_agent ) ; symbol_server = r_str_escape ( opt -> symbol_server ) ; <vul-start> abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , <vul-end> symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ; abspath_to_file = strdup ( abspath_to_archive ) ;",
    "golden_answers": [
      "CWE-78 Fixed Code Lines are: <vul-start> -> opt ; <vul-end> int res = <vul-start> 0 ; } char * abspath_to_file = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( \"File already downloaded.\\\\n\" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name ) <vul-end> - 1 ] <vul-start> = '_' ; char * abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( \"Attempting to download compressed pdb in %s\\\\n\" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd <vul-end> = r_str_newf ( <vul-start> = r_str_newf ( \"expand \\\\\"%s\\\\\" \\\\\"%s\\\\\"\" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc <vul-end> ) ; # <vul-start> ; # else <vul-end> char * abspath_to_dir <vul-start> abspath_to_archive ) ; char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ; <vul-start> = r_str_newf ( \"cabextract -d \\\\\"%s\\\\\" \\\\\"%s\\\\\"\" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free <vul-end> ( abspath_to_dir ) <vul-start> ; # endif free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name <vul-end> ) ; if <vul-start> extract > 0 && res ) { eprintf ( \"Attempting to decompress pdb\\\\n\" ) ; if ( res && <vul-end> ( ( cmd_ret <vul-start> ) ; } free ( archive_name ) ; free ( abspath_to_archive <vul-end> ) ; } <vul-start> \"Falling back to uncompressed pdb\\\\n\" ) ; <vul-end> eprintf ( \"Attempting to download uncompressed pdb in %s\\\\n\" <vul-start> abspath_to_file ) ; res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> -> opt ; R_ASSERT ( opt -> user_agent ) ; R_ASSERT ( opt -> guid ) ; R_ASSERT ( opt -> symbol_server ) ; <vul-start> 0 ; } char * archive_name_escaped = r_str_escape ( opt -> archive_name ) ; <vul-start> = '_' ; <vul-end> # endif eprintf <vul-start> = r_str_newf ( \"%s%s%s%s%s%s%s\" <vul-end>, symbol_store_path, <vul-start> ( \"%s%s%s%s%s%s\" <vul-end>, symbol_store_path, <vul-start> ( \"%s%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s\", archive_name_escaped <vul-end>, R_SYS_DIR, <vul-start> ( \"%s%s%s%s\", archive_name_escaped <vul-end>"
  },
  {
    "id": 859,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 PHP_MINIT_FUNCTION ( spl_array ) { REGISTER_SPL_STD_CLASS_EX ( ArrayObject , spl_array_object_new , spl_funcs_ArrayObject ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Aggregate ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Countable ) ; memcpy ( & spl_handler_ArrayObject , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; spl_handler_ArrayObject . clone_obj = spl_array_object_clone ; spl_handler_ArrayObject . read_dimension = spl_array_read_dimension ; spl_handler_ArrayObject . write_dimension = spl_array_write_dimension ; spl_handler_ArrayObject . unset_dimension = spl_array_unset_dimension ; spl_handler_ArrayObject . has_dimension = spl_array_has_dimension ; spl_handler_ArrayObject . count_elements = spl_array_object_count_elements ; spl_handler_ArrayObject . get_properties = spl_array_get_properties ; <vul-start> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <vul-end> spl_handler_ArrayObject . read_property = spl_array_read_property ; spl_handler_ArrayObject . write_property = spl_array_write_property ; spl_handler_ArrayObject . get_property_ptr_ptr = spl_array_get_property_ptr_ptr ; spl_handler_ArrayObject . has_property = spl_array_has_property ; spl_handler_ArrayObject . unset_property = spl_array_unset_property ; spl_handler_ArrayObject . compare_objects = spl_array_compare_objects ; REGISTER_SPL_STD_CLASS_EX ( ArrayIterator , spl_array_object_new , spl_funcs_ArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Iterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , SeekableIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Countable ) ; memcpy ( & spl_handler_ArrayIterator , & spl_handler_ArrayObject , sizeof ( zend_object_handlers ) ) ; spl_ce_ArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_SUB_CLASS_EX ( RecursiveArrayIterator , ArrayIterator , spl_array_object_new , spl_funcs_RecursiveArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveArrayIterator , RecursiveIterator ) ; spl_ce_RecursiveArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , \"STD_PROP_LIST\" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , \"ARRAY_AS_PROPS\" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , \"STD_PROP_LIST\" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , \"ARRAY_AS_PROPS\" , SPL_ARRAY_ARRAY_AS_PROPS",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; spl_handler_ArrayObject. get_gc = spl_array_get_gc ; spl_handler_ArrayObject.\n"
  },
  {
    "id": 860,
    "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 int i2400m_op_rfkill_sw_toggle ( struct wimax_dev * wimax_dev , enum wimax_rf_state state ) { int result ; struct i2400m * i2400m = wimax_dev_to_i2400m ( wimax_dev ) ; struct device * dev = i2400m_dev ( i2400m ) ; struct sk_buff * ack_skb ; struct { struct i2400m_l3l4_hdr hdr ; struct i2400m_tlv_rf_operation sw_rf ; } __packed * cmd ; char strerr [ 32 ] ; d_fnstart ( 4 , dev , \"(wimax_dev %p state %d)\\\\n\" , wimax_dev , state ) ; result = - ENOMEM ; cmd = kzalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; if ( cmd == NULL ) goto error_alloc ; cmd -> hdr . type = cpu_to_le16 ( I2400M_MT_CMD_RF_CONTROL ) ; cmd -> hdr . length = sizeof ( cmd -> sw_rf ) ; cmd -> hdr . version = cpu_to_le16 ( I2400M_L3L4_VERSION ) ; cmd -> sw_rf . hdr . type = cpu_to_le16 ( I2400M_TLV_RF_OPERATION ) ; cmd -> sw_rf . hdr . length = cpu_to_le16 ( sizeof ( cmd -> sw_rf . status ) ) ; switch ( state ) { case WIMAX_RF_OFF : cmd -> sw_rf . status = cpu_to_le32 ( 2 ) ; break ; case WIMAX_RF_ON : cmd -> sw_rf . status = cpu_to_le32 ( 1 ) ; break ; default : BUG ( ) ; } ack_skb = i2400m_msg_to_dev ( i2400m , cmd , sizeof ( * cmd ) ) ; result = PTR_ERR ( ack_skb ) ; if ( IS_ERR ( ack_skb ) ) { dev_err ( dev , \"Failed to issue \\'RF Control\\' command: %d\\\\n\" , result ) ; goto error_msg_to_dev ;",
    "golden_answers": [
      "CWE-401 Fixed Code Lines are: <vul-start> ; error_cmd : kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , \"(wimax_dev %p state %d) = %d\\\\n\" , wimax_dev , state , result ) ; <vul-start> kfree ( cmd <vul-end> ) ; return\n"
    ],
    "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> ; error_cmd : kfree_skb ( ack_skb ) ;\n"
  },
  {
    "id": 861,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , \"tune\" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , \"ERROR\" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , \"ERROR hot and warm pcts must not exceed 80\" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , \"ERROR hot/warm age factors must be greater than 0\" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , \"OK\" ) ; } } <vul-start> } else if ( strcmp ( tokens [ 1 ] . value , \"mode\" ) == 0 && ntokens >= 3 && <vul-end> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , \"flat\" ) == 0 ) {",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> && ntokens >= 4 <vul-end> && settings . <vul-start> && ntokens >= 4 <vul-end> && settings .\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> else if ( settings. lru_maintainer_thread ) { if ( <vul-start> ) ; } <vul-end> } else if <vul-start> == 0 && <vul-end> settings. lru_maintainer_thread\n"
  },
  {
    "id": 862,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> static int isofs_read_inode ( struct inode * inode ) <vul-end> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO \"%s: out of memory\\\\n\" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> inode * inode , int relocated <vul-start> de , inode , relocated\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> inode * inode, struct isofs_directory_record * de, int relocated ) { int ret = 0 ; if (! relocated ) { ret = isofs_initialize_dir_entry ( inode ) ; if ( ret ) goto out_badread ; } <vul-end> if ( sbi <vul-start> high_sierra ) { ret = <vul-start>, inode ) ; if ( ret ) goto out_badread\n"
  },
  {
    "id": 863,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <vul-start> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <vul-end> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( \"Software\\\\\\\\FreeRDP\\\\\\\\Server\" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( \"Using SSPI",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( SecBuffer ) ) ; ZeroMemory ( & credssp -> sasl_username, sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> sasl_password, sizeof ( SecBuffer )\n"
  },
  {
    "id": 864,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int sqlite3ExprCodeTarget ( Parse * pParse , Expr * pExpr , int target ) { Vdbe * v = pParse -> pVdbe ; int op ; int inReg = target ; int regFree1 = 0 ; int regFree2 = 0 ; int r1 , r2 ; Expr tempX ; int p5 = 0 ; assert ( target > 0 && target <= pParse -> nMem ) ; if ( v == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return 0 ; } expr_code_doover : if ( pExpr == 0 ) { op = TK_NULL ; } else { op = pExpr -> op ; } switch ( op ) { case TK_AGG_COLUMN : { AggInfo * pAggInfo = pExpr -> pAggInfo ; struct AggInfo_col * pCol = & pAggInfo -> aCol [ pExpr -> iAgg ] ; if ( ! pAggInfo -> directMode ) { assert ( pCol -> iMem > 0 ) ; return pCol -> iMem ; } else if ( pAggInfo -> useSortingIdx ) { sqlite3VdbeAddOp3 ( v , OP_Column , pAggInfo -> sortingIdxPTab , pCol -> iSorterColumn , target ) ; return target ; } } case TK_COLUMN : { int iTab = pExpr -> iTable ; if ( ExprHasProperty ( pExpr , EP_FixedCol ) ) { int iReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; <vul-start> int aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ; <vul-end> if ( aff > SQLITE_AFF_BLOB ) { static const char zAff [ ] = \"B\\\\000C\\\\000D\\\\000E\" ; assert",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ; int aff ; if ( pExpr -> y . pTab ) { aff <vul-start> iColumn ) ; } else { aff = pExpr -> affExpr ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> target ) ; sqlite3_int64 <vul-end> aff = sqlite3TableColumnAffinity\n"
  },
  {
    "id": 865,
    "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static netsnmp_pdu * _clone_pdu_header ( netsnmp_pdu * pdu ) { netsnmp_pdu * newpdu ; struct snmp_secmod_def * sptr ; int ret ; if ( ! pdu ) return NULL ; newpdu = ( netsnmp_pdu * ) malloc ( sizeof ( netsnmp_pdu ) ) ; if ( ! newpdu ) return NULL ; memmove ( newpdu , pdu , sizeof ( netsnmp_pdu ) ) ; newpdu -> variables = NULL ; newpdu -> enterprise = NULL ; newpdu -> community = NULL ; newpdu -> securityEngineID = NULL ; newpdu -> securityName = NULL ; newpdu -> contextEngineID = NULL ; newpdu -> contextName = NULL ; newpdu -> transport_data = NULL ; if ( snmp_clone_mem ( ( void * * ) & newpdu -> enterprise , pdu -> enterprise , sizeof ( oid ) * pdu -> enterprise_length ) || snmp_clone_mem ( ( void * * ) & newpdu -> community , pdu -> community , pdu -> community_len ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextEngineID , pdu -> contextEngineID , pdu -> contextEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityEngineID , pdu -> securityEngineID , pdu -> securityEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextName , pdu -> contextName , pdu -> contextNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityName , pdu -> securityName , pdu -> securityNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> transport_data , pdu -> transport_data , pdu -> transport_data_length )",
    "golden_answers": [
      "CWE-415 Fixed Code Lines are: <vul-start> NULL ; } sptr = find_sec_mod ( newpdu -> securityModel ) ; if ( sptr && sptr -> pdu_clone ) { ret = sptr -> pdu_clone ( pdu , newpdu <vul-end> ) ; if <vul-start> NULL ; } <vul-end> } return newpdu\n"
    ],
    "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> NULL ; } <vul-end> ret = usm_clone_usmStateReference <vul-start> NULL ; } <vul-end> if ( (\n"
  },
  {
    "id": 866,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <vul-start> struct dw2102_state * state = d -> priv ; <vul-end> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x02 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; msleep ( 300 ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 ,",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> d -> priv <vul-end> ; struct i2c_adapter <vul-start> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x02 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> 300 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> err ( \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> d -> priv <vul-end> ; struct i2c_adapter <vul-start> ( d, 0xe, 3, ibuf, 1, 0 ) < 0 ) err ( \"command 0x0e transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0xe ; state -> priv <vul-end> [ 1 ] <vul-start> = 0x02 ; state -> priv <vul-end> [ 2 ] <vul-start> ( d, 0xe, 3, ibuf, 1, 0 ) <vul-end> ; if ( <vul-start> ( d, 0xe, 3, ibuf, 1, 0 ) <vul-end> < 0 ) <vul-start> 300 ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0xe ; state -> priv <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 2 ] <vul-start> ( d, 0xe, 3, ibuf, 1, 0 ) <vul-end> < 0 ) <vul-start> \"command 0x0e transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 2 ] <vul-start> \"command 0x0e transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 2 ] <vul-start> \"command 0x83 transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 2 ] <vul-start> \"command 0x83 transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 2 ] <vul-start> ( d, state -> priv <vul-end>, 3, <vul-start>, 3, ibuf, 1, 0 ) <vul-end> < 0 ) <vul-start> \"command 0x51 transfer failed.\" ) ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x83 ; state -> priv <vul-end> [ 1 ] <vul-start> \"command 0x83 transfer failed.\" ) ; state -> priv <vul-end> [ 2 ] <vul-start> = 0 ; state -> priv <vul-end> [ 0 ] <vul-start> = 0 ; state -> priv <vul-end> [ 1 ] <vul-start> = 0 ; state -> priv <vul-end> [ 2 ] <vul-start> = 0 ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x80 ; state -> priv <vul-end> [ 0 ] <vul-start> = 0x02 ; state -> priv <vul-end> [ 1 ]"
  },
  {
    "id": 867,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; <vul-start> mrb_value value ; <vul-end> <vul-start> fiber_check_cfunc ( mrb , c ) ; <vul-end> <vul-start> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming transferred fiber\" ) ; } <vul-start> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"double resume (fib)\" ) ; } <vul-start> if ( c -> status == MRB_FIBER_TERMINATED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming dead fiber\" ) ; } <vul-start> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <vul-end> c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; <vul-start> if ( c -> status == MRB_FIBER_CREATED ) { <vul-end> mrb_value * b , * e ; <vul-start> if ( len >= c -> stend - c -> stack ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"too many arguments to fiber\" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> -> c ; enum mrb_fiber_state status ; <vul-start> , c ) ; status = c -> status <vul-start> ( resume && <vul-end> status == MRB_FIBER_TRANSFERRED <vul-start> } if ( <vul-end> status == MRB_FIBER_RUNNING <vul-start> == MRB_FIBER_RUNNING || <vul-end> status == MRB_FIBER_RESUMED <vul-start> } if ( <vul-end> status == MRB_FIBER_TERMINATED <vul-start> ) ; } old_c <vul-end> -> status = <vul-start> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <vul-end> status == MRB_FIBER_CREATED <vul-start> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <vul-end> b = c <vul-start> ) ; } <vul-end> if ( vmexec\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; mrb_value value = mrb_raise ( mrb, E_FIBER_ERROR, \"illegal fiber switch\" ) <vul-start> mrb, c ) ; assert ( len >= c -> stend - c -> stack <vul-start> status == MRB_FIBER_TRANSFERRED || c -> status == MRB_FIBER_TERMINATED ) ; if ( c -> status == MRB_FIBER_CREATED <vul-start> } if ( <vul-end> c -> status <vul-start> status == MRB_FIBER_RUNNING <vul-end> ) { mrb_raise <vul-start> } if ( <vul-end> c -> status <vul-start> status == MRB_FIBER_RESUMED || c -> status == MRB_FIBER_TERMINATED ) { mrb_raise ( mrb, E_FIBER_ERROR, \"double resume (fib)\" ) ; } mrb -> c -> status = resume? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; c -> prev = resume? mrb -> c : ( c -> prev? c -> prev : mrb -> root_c ) ; if ( c -> status == MRB_FIBER_CREATED <vul-start> ; if ( c -> status == MRB_FIBER_CREATED <vul-end> ) { mrb_value <vul-start> * e ; <vul-end> b = c <vul-start> ) ; } <vul-end> if ( vmexec\n"
  },
  {
    "id": 868,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif <vul-start> n = s -> method -> ssl_get_message ( s , <vul-end> SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; <vul-start> if ( ! ok ) return ( ( int ) n ) ; <vul-end> if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { <vul-start> # ifndef OPENSSL_NO_PSK <vul-end> <vul-start> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <vul-end> { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <vul-start> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <vul-start> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <vul-start> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <vul-start> . new_cipher -> algorithm_auth <vul-end> ; al =\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ; # endif if ( s -> s3 -> tmp. message_type!= SSL3_MT_SERVER_KEY_EXCHANGE ) { # ifndef OPENSSL_NO_PSK if ( s -> s3 -> tmp. new_cipher -> algorithm_mkey & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif <vul-start> if (! s -> s3 -> tmp. new_cipher <vul-end> ) return ( <vul-start> int ) n <vul-end> ) ; if <vul-start> SSL3_MT_SERVER_KEY_EXCHANGE ) { <vul-end> if ( s <vul-start> -> tmp. <vul-end> new_cipher -> algorithm_mkey <vul-start> algorithm_mkey & SSL_kPSK <vul-end> ) { s\n"
  },
  {
    "id": 869,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <vul-end> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , message ) \\\\\\n{ <vul-end> if ( tile_image <vul-start> ) ) ; \\\\\\n} <vul-end> char geometry [ <vul-start> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length <vul-start> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length <vul-start> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length > <vul-start> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; <vul-start> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, message ) \\\\\\n{ <vul-end> if ( tile_image <vul-start> ) ) ; \\\\\\n} <vul-end> char geometry [ <vul-start> ( length!= 0x000a <vul-end> ) { for <vul-start> ( length!= 0x000a <vul-end> ) { for\n"
  },
  {
    "id": 870,
    "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put (",
    "golden_answers": [
      "CWE-362 Fixed Code Lines are: <vul-start> rds_loop_transport ; } <vul-end> } conn ->\n"
    ],
    "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> rds_loop_transport ; } if (! trans ) { kmem_cache_free ( rds_conn_slab, conn ) ; conn = ERR_PTR ( - EINVAL ) ; goto out ; }\n"
  },
  {
    "id": 871,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } if ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { context -> pass ++ ; context -> curY = i -> posY + 4 ;\n"
  },
  {
    "id": 872,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <vul-start> if ( likely ( walk . nbytes == nbytes ) ) <vul-end> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> iv ) ; <vul-end> while ( walk\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> iv ) ; <vul-end> while ( walk\n"
  },
  {
    "id": 873,
    "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; <vul-start> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <vul-end> rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize =",
    "golden_answers": [
      "CWE-369 Fixed Code Lines are: <vul-start> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , \"Invalid image dimensions\" ) ; goto done ; }\n"
    ],
    "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> -> rbuf [ 7 <vul-end> ] ) ;\n"
  },
  {
    "id": 874,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; <vul-start> int tlen ; <vul-end> uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ; <vul-start> ND_TCHECK ( * vqp_common_header ) ; <vul-end> if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , \"VQP version %u packet not supported\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"VQPv%u %s Message, error-code %s (%u), length %u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown (%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown (%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , \"\\\\n\\\\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown (%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown (%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> uint32_t vqp_obj_type ; u_int <vul-end> tlen ; uint8_t <vul-start> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <vul-start> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <vul-start> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <vul-start> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <vul-start> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> uint32_t vqp_obj_type ; uint32_t <vul-end> vqp_obj_len ; tptr <vul-start> vqp_obj_len ) ; ND_TCHECK_32BITS ( vqp_obj_tlv -> obj_type ) ; <vul-start> case VQP_OBJ_IP_ADDRESS : if ( len!= 4 ) { ND_PRINT ( ( ndo, \"VQP header too short\" ) ) ; return ; } <vul-start> case VQP_OBJ_MAC_NULL : if ( len!= vqp_obj_len ) { ND_PRINT ( ( ndo, \"VQP header too short\" ) ) ; return ; }\n"
  },
  {
    "id": 875,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , \"picture will move %s one line\\\\n\" , s -> dst_tff ? \"up\" : \"down\" ) ; h = frame -> height ; <vul-start> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <vul-end> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size )",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
  },
  {
    "id": 876,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( \"Aiee, killing interrupt handler!\" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( \"Attempted to kill the idle task!\" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT \"Fixing recursive fault but reboot is needed!\\\\n\" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO \"note: %s[%d] exited with preempt_count %d\\\\n\" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ;",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ) exit_io_context ( tsk\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> -> io_context ) { struct mm_struct * old, * new ; old = tsk -> signal -> user ; new = tsk -> signal -> mm ; if ( unlikely ( old!= tsk -> signal ) ) { mmget_tgid ( old, old -> pid ) ; release_mm ( old ) ; } } <vul-end> if ( tsk\n"
  },
  {
    "id": 877,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) { int rc = pcmk_ok ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( private -> passwd == NULL ) { struct termios settings ; int rc ; rc = tcgetattr ( 0 , & settings ) ; settings . c_lflag &= ~ ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; fprintf ( stderr , \"Password: \" ) ; private -> passwd = calloc ( 1 , 1024 ) ; rc = scanf ( \"%s\" , private -> passwd ) ; fprintf ( stdout , \"\\\\n\" ) ; if ( rc < 1 ) { private -> passwd = NULL ; } settings . c_lflag |= ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; } if ( private -> server == NULL || private -> user == NULL ) { rc = - EINVAL ; } if ( rc == pcmk_ok ) { <vul-start> rc = cib_tls_signon ( cib , & ( private -> command ) ) ; <vul-end> } if ( rc == pcmk_ok ) { <vul-start> rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; <vul-end> } if ( rc == pcmk_ok ) { xmlNode * hello = cib_create_op ( 0 , private -> callback . token , CRM_OP_REGISTER , NULL , NULL , NULL , 0 , NULL ) ; crm_xml_add ( hello , F_CIB_CLIENTNAME , name ) ; crm_send_remote_msg ( private -> command . session ,",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> -> command ) , FALSE <vul-start> -> callback ) , TRUE\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( cib, name, <vul-start> ( cib, name,\n"
  },
  {
    "id": 878,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <vul-start> msg . msg_name = ( struct sockaddr * ) & address ; <vul-end> <vul-start> msg . msg_namelen = sizeof ( address ) ; <vul-end> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> . msg_name = addr ? <vul-start> ) & address : NULL <vul-start> . msg_namelen = 0 <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = ubuf ; memset ( & address, 0, sizeof ( address ) ) ; <vul-start> = sizeof ( address ) ; memset ( & address, 0, sizeof ( address ) <vul-end> ) ; if\n"
  },
  {
    "id": 879,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int main_loop ( int argc , const char * * argv_ ) { <vul-end> vpx_codec_ctx_t decoder ; char * fn = NULL ; int i ; uint8_t * buf = NULL ; size_t bytes_in_buffer = 0 , buffer_size = 0 ; FILE * infile ; int frame_in = 0 , frame_out = 0 , flipuv = 0 , noblit = 0 ; <vul-start> int do_md5 = 0 , progress = 0 ; <vul-end> int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ; int arg_skip = 0 ; <vul-start> int ec_enabled = 0 ; <vul-end> const VpxInterface * interface = NULL ; const VpxInterface * fourcc_interface = NULL ; uint64_t dx_time = 0 ; struct arg arg ; char * * argv , * * argi , * * argj ; int single_file ; int use_y4m = 1 ; <vul-start> vpx_codec_dec_cfg_t cfg = { 0 } ; <vul-end> # if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = { 0 } ; int vp8_dbg_color_ref_frame = 0 ; int vp8_dbg_color_mb_modes = 0 ; int vp8_dbg_color_b_modes = 0 ; int vp8_dbg_display_mv = 0 ; # endif int frames_corrupted = 0 ; int dec_flags = 0 ; int do_scale = 0 ; vpx_image_t * scaled_img = NULL ; <vul-start> int frame_avail , got_data ; <vul-end> int num_external_frame_buffers = 0 ; <vul-start> struct ExternalFrameBufferList ext_fb_list = { 0 } ; <vul-end> const char * outfile_pattern = NULL ; char outfile_name [ PATH_MAX ] = { 0 } ; FILE * outfile = NULL ; MD5Context md5_ctx ; unsigned char md5_digest [ 16 ] ; <vul-start>",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> progress = 0 , frame_parallel = 0 <vul-start> ; int ec_enabled = 0 ; int keep_going <vul-start> = 1 ; int opt_yv12 = 0 ; int opt_i420 = 0 ; <vul-start> = { 0 , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif <vul-end> # if CONFIG_VP8_DECODER <vul-start> = NULL ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif <vul-start> frame_avail , got_data , flush_decoder = 0 <vul-start> = { 0 , NULL <vul-start> input = { NULL , NULL <vul-end> } ; struct <vul-start> struct VpxInputContext vpx_input_ctx ; # if CONFIG_WEBM_IO <vul-end> struct WebmInputContext webm_ctx <vul-start> struct WebmInputContext webm_ctx ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) <vul-end> ; input . <vul-start> ; input . webm_ctx = & webm_ctx ; # endif input . <vul-start> = & vpx_input_ctx <vul-end> ; exec_name = <vul-start> = 1 ; opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif <vul-start> = 0 ; opt_i420 = 1 ; <vul-start> arg , & rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , & <vul-start> arg ) ; # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER <vul-start> arg , & frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , & <vul-start> arg ) ; else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif <vul-start> ! fn ) { free ( argv ) ; <vul-start> ( ) ; } <vul-start> infile ) { fatal ( \"Failed to open input file \\'%s\\'\" <vul-end> , strcmp ( <vul-start> : \"stdin\" ) <vul-end> ; } # <vul-start> stderr , \"YUV4MPEG2 not supported with output patterns,\" \" try --i420 or --yv12 or --rawvideo.\\\\n\" <vul-end> ) ; return <vul-start> : 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) <vul-start> , interface -> codec_interface ( ) , <vul-end> & cfg , <vul-start> ; int corrupted = 0 <vul-start> detail ) ; if ( ! keep_going ) <vul-start> ) ; } else { flush_decoder = 1 ; } } else { flush_decoder = 1 ; <vul-start> timer ) ; if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( \"Failed to flush decoder: %s\" , vpx_codec_error ( & decoder ) ) ; } } <vul-start> ; if ( ! frame_parallel && <vul-start> ) ) ; if ( ! keep_going ) <vul-start> ( NULL , img -> fmt <vul-end> , display_width , <vul-start> , 16 ) ; scaled_img -> bit_depth = img -> bit_depth <vul-start> d_h ) { # if CONFIG_LIBYUV libyuv_scale <vul-end> ( img , <vul-start> = scaled_img ; # else fprintf ( stderr , \"Failed  to scale output frame: %s.\\\\n\" \"Scaling is disabled in this configuration. \" \"To enable scaling, configure with --enable-libyuv\\\\n\" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif <vul-end> if ( single_file <vul-start> ; if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , \"Cannot produce y4m output for 440 sampling.\\\\n\" ) ; goto fail ; } if ( <vul-start> img -> fmt , img -> bit_depth <vul-start> ; } } else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , \"Cannot produce i420 output for bit-stream.\\\\n\" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , \"Cannot produce yv12 output for bit-stream.\\\\n\" ) ; goto fail ; } } } } <vul-start> } } } <vul-end> } if ( <vul-start> scaled_img ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> argv_ ) { vpx_codec_ctx_t decoder ; const char * const output_file = NULL ; <vul-start> ; int do_md5 = 0 ; int do_vpx <vul-start> ; int progress = 0 ; int do_summary <vul-start> ; int arg_skip = 0 ; int ec_enabled = 0 ; const VpxInterface * interface = NULL ; const VpxInterface * fourcc_interface = NULL ; uint8_t * scaled_img_data <vul-start> ; vpx_codec_dec_cfg_t cfg <vul-end> ; # if <vul-start> ; int frame_avail <vul-end> ; # endif <vul-start> struct ExternalFrameBufferList ext_fb_list ; struct ExternalFrameBufferList * tmp_ext_fb_list <vul-start> 16 ] ; tmp_ext_fb_list = NULL ; <vul-start> arg, & i2c_default_interface, argi ) ) { const VpxInterface * const vpx_interface = & vpx_interface -> vpx_interface ; const VpxInterface * const webm_interface = & webm_interface -> vpx_interface ; const int num_external_frame_buffers = 0 ; tmp_ext_fb_list = & tmp_ext_fb_list ; } else if ( arg_match ( & arg, & use_i420, argi ) ) { use_y4m = 0 ; vp8_pp_cfg. post_proc_flag |= V8_POSTPROC ; vp8_pp_cfg. noise_level = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg, & use_i420, argi ) ) { vp8_pp_cfg. post_proc_flag |= V8_FLIPUV ; vp8_pp_cfg. noise_level = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg, & <vul-start> 16 ] ; memset ( & md5_ctx, 0, sizeof ( md5_ctx ) ) ; <vul-start> arg, & vpx_input_ctx, sizeof ( vpx_input_ctx ) ) ; memset ( & webm_ctx, 0, sizeof ( webm_ctx ) ) ; input. vpx_input_ctx = & vpx_input_ctx ; input"
  },
  {
    "id": 880,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ; <vul-start> int num00 , tmp_err , n , sr = 0 ; <vul-end> int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; <vul-start> int new_mv_mode_penalty = 256 ; <vul-end> <vul-start> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <vul-end> while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; <vul-start> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <vul-end> step_param , <vul-start> x -> sadperbit16 , & num00 , & v_fn_ptr , <vul-end> x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <vul-start> best_mv",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> tmp_err , n <vul-end> ; const BLOCK_SIZE <vul-start> bsize ] ; const <vul-start> int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <vul-end> ; const int <vul-start> ; const int sr = get_search_range ( cpi ) <vul-end> ; step_param += <vul-start> bsize ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <vul-start> x , & cpi -> ss_cfg , & <vul-start> , & v_fn_ptr <vul-end> , ref_mv ) <vul-start> = tmp_err ; * best_mv = tmp_mv <vul-end> ; } n <vul-start> diamond_search_sad ( x , & cpi -> ss_cfg <vul-start> & v_fn_ptr , <vul-end> ref_mv ) ; <vul-start> = tmp_err ; * best_mv = tmp_mv <vul-end> ; } }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } ; int <vul-end> tmp_err, n <vul-start> bsize ] ; const MV_SEARCH_STEPS * const sr = MIN ( MAX_MVSEARCH_STEPS, 3 ) ; int new_mv_mode_penalty = MIN ( cpi -> common. width, cpi -> common. height ) ; while ( sr < further_steps ) { ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr. vf = get_block_variance_fn ( bsize ) ; } <vul-end> const BLOCK_SIZE bsize <vul-start> bsize ] ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int <vul-end> quart_frm = MIN <vul-start> height ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { const int max_penalty = ( cpi -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH )? MIN ( cpi -> cur_buf -> flags, MAX_MVSEARCH_STEPS - 1 ) : MIN ( cpi -> cur_buf -> flags, MAX_MVSEARCH_STEPS - 1 ) ; if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { const int max_penalty = MIN ( cpi -> cur_buf -> flags, MAX_MVSEARCH_STEPS - 1 ) ; if ( cpi -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_err = cpi -> diamond_search_sad ( x, & ref_mv_full, & tmp_mv, step_param, x -> sadperbit16, & num00, & v_fn_ptr, x -> nmvjointcost, x -> mvcost, ref_mv ) ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv. row ; best_mv ->"
  },
  {
    "id": 881,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <vul-end> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <vul-start> if ( event_data [ 0 ] >= 0x80 ) { <vul-end> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <vul-start> ret_cnt ++ ; <vul-end> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> * event_data , uint32_t siz , <vul-start> ; if ( ! siz ) goto shortbuf ; if ( <vul-start> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <vul-start> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <vul-start> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 4 ) goto shortbuf ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ) ) { if ( siz < 3 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 3 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 2 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 5 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 7 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 6 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 4 ) goto shortbuf ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <vul-start> sysex_len ) break <vul-end> ; sysex_store = <vul-start> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , \"(input too short)\" , 0 ) ; return 0 ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> uint8_t * event_data, uint32_t length <vul-start> = NULL ; uint32_t data_length = 0 ; <vul-start> [ 0 ] > <vul-end> 0x80 ) { <vul-start> & 0x0f ; event_data ++ ; ret_cnt ++ ; data_length ++ <vul-end> ; } switch <vul-start> : _SETUP_NOTEOFF : if ( length < 2 ) { return - 1 ; } data_1 = * event_data ++ ; data_2 = * event_data ++ ; text = malloc ( tmp_length + 1 ) ; memcpy ( text, event_data, tmp_length ) ; text [ tmp_length ] = '\\\\0' ; midi_setup_noteoff ( mdi, channel, data_1, data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; data_1 = * event_data ++ ; data_2 = * event_data ++ ; text = malloc ( tmp_length + 1 ) ; memcpy ( text, event_data, tmp_length ) ; text [ tmp_length ] = '\\\\0' ; midi_setup_trackname ( mdi, text ) ; ret_cnt += tmp_length ; break ; case 0xa0 : data_1 = * event_data ++ ; data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi, channel, data_1, data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : data_1 = * event_data ++ ; data_2 = * event_data ++ ; midi_setup_control ( mdi, channel, data_1, data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; data_2 = * event_data ++ ; text = malloc ( tmp_length + 1 ) ; memcpy ( text, event_data, tmp_length ) ; text [ tmp_length ] = '\\\\0' ; midi_setup_midi ( mdi, text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++"
  },
  {
    "id": 882,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = \" \" ; <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = \"xtractprotos\" ; if ( argc == 1 ) { fprintf ( stderr , \"xtractprotos [-prestring=<string>] [-protos=<where>] \" \"[list of C files]\\\\n\" \"where the prestring is prepended to each prototype, and \\\\n\" \"protos can be either \\'inline\\' or the name of an output \" \"prototype file\\\\n\" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , \"-prestring\" , 10 ) ) { nflags ++ ; <vul-start> ret = sscanf ( argv [ i ] + 1 , \"prestring=%s\" , buf ) ; <vul-end> if ( ret != 1 ) { fprintf ( stderr , \"parse failure for prestring\\\\n\" ) ; return 1 ; } <vul-start> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; l_uint8 <vul-start> + 1 , \"prestring=%490s\" <vul-end> , buf ) <vul-start> ) ) > L_BUFSIZE <vul-end> - 3 ) <vul-start> + 1 , \"protos=%490s\" <vul-end> , buf ) <vul-start> ( buf , L_BUFSIZE <vul-end> , \" *  These prototypes were autogen\\'d by xtractprotos, v. %s\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"cpp -ansi -DNO_PROTOS %s %s\" ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; l_uint8 <vul-start> ; ret = l_parse_options ( argv [ i ] <vul-end>, \"prestring=%s\", <vul-start> ) ) > L_BUFSIZE <vul-end> - 3 ) <vul-start> + 1, \"protos=%s\" <vul-end>, buf ) <vul-start> ( buf, L_BUFSIZE <vul-end>, \" * These prototypes were autogen\\'d by xtractprotos, v. %s\",\n"
  },
  {
    "id": 883,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> char emptystring [ ] = \"\" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( \"gplotAddPlot\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot not defined\" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( \"nay not defined\" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( \"invalid plotstyle\" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( \"no points to plot\" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( \"nax and nay sizes differ\" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( \"only 1 pt; changing style to points\\\\n\" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf , L_BUFSIZE <vul-end> , \"%s.data.%d\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"%f %f\\\\n\" ,\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> plottitle ) { <vul-end> char emptystring [ <vul-start> nplots ++ ; sarrayAddString ( gplot -> datanames, buf, L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax, i, & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay, i, & valy ) ; snprintf ( buf, L_BUF_SIZE, \"%f %f\\\\n\", valx, valy ) ; } datastr = sarrayToString ( sa, 0 ) ; sarrayDestroy ( & sa ) ; if (! buf ) { <vul-start> valy ) ; } <vul-end> sarrayAddString ( sa\n"
  },
  {
    "id": 884,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <vul-start> struct mount * n , * p ; <vul-end> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <vul-start> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <vul-end> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( &",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> , * p ; bool done <vul-start> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <vul-end> type = CL_SLAVE\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, * p ; if ( last_dest -> mnt_master!= dest_master ) goto out <vul-start> ; if ( <vul-end> IS_MNT_MARKED ( p <vul-start> p ) ) break ; out : <vul-end> type = CL_SLAVE\n"
  },
  {
    "id": 885,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int dse_bind ( Slapi_PBlock * pb ) { ber_tag_t method ; struct berval * cred ; Slapi_Value * * bvals ; struct dse * pdse ; Slapi_Attr * attr ; Slapi_DN * sdn = NULL ; Slapi_Entry * ec = NULL ; if ( slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & pdse ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_TARGET_SDN , & sdn ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) < 0 ) { slapi_send_ldap_result ( pb , LDAP_OPERATIONS_ERROR , NULL , NULL , 0 , NULL ) ; return SLAPI_BIND_FAIL ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { slapi_send_ldap_result ( pb , LDAP_SUCCESS , NULL , NULL , 0 , NULL ) ; return ( SLAPI_BIND_FAIL ) ; } ec = dse_get_entry_copy ( pdse , sdn , DSE_USE_LOCK ) ; if ( ec == NULL ) { <vul-start> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <vul-end> return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec , \"userpassword\" , & attr ) != 0 ) { <vul-start> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <vul-end> slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) !=",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry does not exist\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <vul-end> , NULL , <vul-start> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry does not have userpassword set\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <vul-end> , NULL , <vul-start> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Invalid credentials\" ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec, \"userpassword\", & attr )!= 0 ) { slapi_send_ldap_result ( pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv, cred ) ; if ( slapi_value_init_berval ( & cv, cred )!= 0 ) { slapi_send_ldap_result ( pb, LDAP_OPERATIONS_ERROR, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } slapi_send_ldap_result ( pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } if ( slapi_entry_attr_find ( ec, \"userpassword\", & attr )!= 0 ) { slapi_send_ldap_result ( pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv, cred ) ; if ( slapi_value_init_berval ( & cv, cred )!= 0 ) { slapi_send_ldap_result ( pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv, cred ) ; if ( slapi_value_init_berval ( & cv"
  },
  {
    "id": 886,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( \"Usage: %s mj2filename output_location\\\\n\" , argv [ 0 ] ) ; printf ( \"Example: %s foreman.mj2 output/foreman\\\\n\" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , \"rb\" ) ; if ( ! file ) { fprintf ( stderr , \"failed to open %s for reading\\\\n\" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf (",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> file ) ; int num = snprintf <vul-end> ( outfilename , <vul-start> ( outfilename , sizeof ( outfilename ) , <vul-start> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , \"maximum length of output prefix exceeded\\\\n\" ) ; return 1 ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, \"%s_%05d.j2k\", mj2_get_tstr ( <vul-start> ], snum )\n"
  },
  {
    "id": 887,
    "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <vul-start> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <vul-end> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <vul-start> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <vul-end> if ( host_error < 0 ) <vul-start> goto out_release ; <vul-end> if ( S_ISDIR ( inode -> i_mode ) ) { <vul-start> host_error = inode -> i_op -> set_acl ( inode , dpacl , <vul-end> ACL_TYPE_DEFAULT ) ; } <vul-start> out_release : <vul-end> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }",
    "golden_answers": [
      "CWE-284 Fixed Code Lines are: <vul-start> ; if ( <vul-end> S_ISDIR ( inode <vul-start> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <vul-end> ) ; if <vul-start> 0 ) goto out_drop_lock <vul-end> ; if ( <vul-start> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <vul-end> ) ; } <vul-start> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <vul-end> posix_acl_release ( pacl\n"
    ],
    "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> -> i_op -> set_acl2 ||! inode -> i_sb -> s_set_mode <vul-end> ) return nfserr_attrnotsupp <vul-start> goto out_nfserr ; if (! inode -> i_sb -> s_set_mode ) return nfserr_attrnotsupp ; <vul-start> ) goto out_release ; inode -> i_sb -> s_set_mode <vul-start> ) ; } if (! inode -> i_sb -> s_set_mode ) return nfserr_attrnotsupp ;\n"
  },
  {
    "id": 888,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( \"HIVEX_DEBUG\" ) ; if ( debug && STREQ ( debug , \"1\" ) ) h -> msglvl = 2 ; DEBUG ( 2 , \"created handle %p\" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , \"%s: file is too small to be a Windows NT Registry hive file\" , filename ) ; goto",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ENOTSUP , \"%s: page size %zu at 0x%zx, bad registry\" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , \"%s: page size %zu at 0x%zx extends beyond end of file, bad registry\"\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( EINVAL, \"%s: file is too small to be a Windows NT Registry hive file\" <vul-end>, filename )\n"
  },
  {
    "id": 889,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static void pci_bus_write_dsdt ( int bus ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev ; int count , func , slot ; bi = pci_businfo [ bus ] ; if ( bi == NULL ) { if ( bus != 0 ) return ; } dsdt_line ( \" Device (PCI%01X)\" , bus ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" Name (_HID, EisaId (\\\\\"PNP0A03\\\\\"))\" ) ; dsdt_line ( \" Name (_ADR, Zero)\" ) ; dsdt_line ( \" Method (_BBN, 0, NotSerialized)\" ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" Return (0x%08X)\" , bus ) ; dsdt_line ( \" }\" ) ; dsdt_line ( \" Name (_CRS, ResourceTemplate ()\" ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" WordBusNumber (ResourceProducer, MinFixed, \" \"MaxFixed, PosDecode,\" ) ; dsdt_line ( \" 0x0000, // Granularity\" ) ; dsdt_line ( \" 0x%04X, // Range Minimum\" , bus ) ; dsdt_line ( \" 0x%04X, // Range Maximum\" , bus ) ; dsdt_line ( \" 0x0000, // Translation Offset\" ) ; dsdt_line ( \" 0x0001, // Length\" ) ; dsdt_line ( \" ,, )\" ) ; if ( bus == 0 ) { dsdt_indent ( 3 ) ; dsdt_fixed_ioport ( 0xCF8 , 8 ) ; dsdt_unindent ( 3 ) ; dsdt_line ( \" WordIO (ResourceProducer, MinFixed, MaxFixed, \" \"PosDecode, EntireRange,\" ) ; dsdt_line ( \" 0x0000, // Granularity\" ) ; dsdt_line ( \" 0x0000, // Range Minimum\" ) ; dsdt_line ( \" 0x0CF7, // Range Maximum\" ) ; dsdt_line ( \" 0x0000, // Translation Offset\" )",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> ; } } <vul-end> dsdt_line ( \"      WordIO (ResourceProducer, MinFixed, MaxFixed, \"\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ; } } <vul-end> dsdt_line ( \" WordIO (ResourceProducer, MinFixed, MaxFixed, \"\n"
  },
  {
    "id": 890,
    "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int fb_mmap ( struct file * file , struct vm_area_struct * vma ) { struct fb_info * info = file_fb_info ( file ) ; struct fb_ops * fb ; <vul-start> unsigned long off ; <vul-end> unsigned long start ; u32 len ; if ( ! info ) return - ENODEV ; <vul-start> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) <vul-end> return - EINVAL ; <vul-start> off = vma -> vm_pgoff << PAGE_SHIFT ; <vul-end> fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; <vul-start> if ( fb -> fb_mmap ) { <vul-end> int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ; if ( off >= len ) { off -= len ; if ( info -> var . accel_flags ) { mutex_unlock ( & info -> mm_lock ) ; return - EINVAL ; } start = info -> fix . mmio_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ; } mutex_unlock ( & info -> mm_lock ) ; start &= PAGE_MASK ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ; off += start ; vma -> vm_pgoff =",
    "golden_answers": [
      "CWE-189 Fixed Code Lines are: <vul-start> ; unsigned long mmio_pgoff <vul-end> ; unsigned long <vul-start> - ENODEV ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <vul-end> vma -> vm_pgoff <vul-start> vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <vul-end> ( & info <vul-start> mm_lock ) ; <vul-end> vma -> vm_page_prot <vul-start> , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <vul-end> ; }  \n"
    ],
    "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; unsigned long start ; unsigned long pgoff <vul-end> ; if ( <vul-start> ; if ( vma -> vm_pgoff < vma -> vm_start ) return - EINVAL ; pgoff = vma -> vm_pgoff << PAGE_SHIFT ; fb = info -> fbops ; if (! fb ) return - ENODEV ; if ( <vul-start> vm_flags ) ; if ( pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) return - EINVAL ; off = pgoff << PAGE_SHIFT ; <vul-start> vma, off ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info, vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix. smem_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix. smem_len ) ; if ( off >= len ) { off -= len ; res = fb -> fb_mmap ( info, vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } vma -> vm_pgoff = off ; vma -> vm_page_prot = vma -> vm_page_prot ; if ( io_remap_pfn_range ( vma, vma -> vm_start, off >> PAGE_SHIFT, vma -> vm_end - vma -> vm_start, vma -> vm_page_prot ) ) return - EAGAIN ; if ( info -> vm_end - vma -> vm_start > off + len ) return - EINVAL ; vma -> vm_pgoff = off + start ; vma -> vm_flags = vma -> vm_flags ; fb_pgprotect ( file, vma, off\n"
  },
  {
    "id": 891,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <vul-start> if ( tmp == NULL ) goto failed ; <vul-end> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <vul-start> if ( tmp == NULL ) goto failed ; <vul-end> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <vul-start> Py_ssize_t i ; <vul-end> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"comprehension field \\\\\"ifs\\\\\" must be a list, not",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"ifs\\\\\" missing from comprehension\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ; Py_ssize_t i <vul-end> ; if ( <vul-start> ) { expr_ty val <vul-end> ; res = <vul-start> ) , & val <vul-end> , arena ) <vul-start> , i , val <vul-end> ) ; } <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"is_async\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ( tmp ) <vul-end> ; } *\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_target, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ; res = obj2ast_expr ( tmp, & target, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { int res ; tmp = _PyObject_GetAttrId <vul-end> ( obj, <vul-start>, & PyId_iter, & tmp ) ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_ifs, & tmp ) < 0 ) { return 1 ; } else { int res ; res = obj2ast_expr ( tmp, & iter, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_ifs, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"ifs\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp, & is_async, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = comprehension ( target, iter, ifs, is_async, arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; } else { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"is_async\\\\\" missing from comprehension\" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj, & PyId_target ) ) { int res ; res = obj2ast_expr ( tmp, & target, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR"
  },
  {
    "id": 892,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) { png_structp png_ptr = NULL ; png_infop info_ptr = NULL ; png_size_t rowbytes ; int color_type , bit_depth ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; if ( ! png_ptr ) { return PNG_OUT_OF_MEMORY_ERROR ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return LIBPNG_FATAL_ERROR ; } # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; # endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) \"pHYs\\\\0iTXt\\\\0tEXt\\\\0zTXt\" , 4 ) ; # endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; struct rwpng_read_data read_data = { infile , 0 } ; png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ; <vul-start> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <vul-end> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( ! ( color_type &",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> NULL ) ; <vul-end> if ( ! <vul-start> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; if ( png_get_valid ( png_ptr, info_ptr, PNG_INFO_IHDR ) ) { png_destroy_read_struct ( & png_ptr, & info_ptr, NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( <vul-start> ; if ( png_get_valid ( png_ptr, info_ptr, PNG_INFO_IHDR ) ) { png_destroy_read_struct ( & png_ptr, & info_ptr, NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (\n"
  },
  {
    "id": 893,
    "question": "CWE-611 Code Input Vulnerable Code Is: CWE-611 void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , \"Merge parent %pp child %pp RESULT %pp\" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child",
    "golden_answers": [
      "CWE-611 Fixed Code Lines are: <vul-start> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;\n"
    ],
    "generated_answer": "CWE-611 Fixed Code Lines are: <vul-start> -> crypto_hash_framesrc_pm ; merged -> phase_request_body_hash = ( child -> phase_request_body == NULL )? child -> phase_request_body_hash : child -> phase_request_body_hash ;\n"
  },
  {
    "id": 894,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void isoclns_print ( netdissect_options * ndo , <vul-start> const uint8_t * p , u_int length , u_int caplen ) <vul-end> { <vul-start> if ( caplen <= 1 ) { <vul-end> ND_PRINT ( ( ndo , \"|OSI\" ) ) ; return ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"OSI NLPID %s (0x%02x): \" , tok2str ( nlpid_values , \"Unknown\" , * p ) , * p ) ) ; switch ( * p ) { case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) <vul-start> print_unknown_data ( ndo , p , \"\\\\n\\\\t\" , caplen ) ; <vul-end> break ; case NLPID_ESIS : esis_print ( ndo , p , length ) ; return ; case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) <vul-start> print_unknown_data ( ndo , p , \"\\\\n\\\\t\" , caplen ) ; <vul-end> break ; case NLPID_NULLNS : ND_PRINT ( ( ndo , \"%slength: %u\" , ndo -> ndo_eflag ? \"\" : \", \" , length ) ) ; break ; case NLPID_Q933 : q933_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP : ip_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_PPP : ppp_print ( ndo , p + 1 , length - 1 ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> , u_int length <vul-end> ) { if <vul-start> { if ( ! ND_TTEST ( * p ) <vul-end> ) { ND_PRINT <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break <vul-start> ; if ( length <vul-end> > 1 ) <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length, u_int flags <vul-end> ) { if <vul-start> { if ( flags & ND_T_SYNCHRONOUS ) ND_PRINT ( ( ndo, \"|OSI\" ) ) ; else <vul-end> if ( ndo <vul-start>, p, flags <vul-end> ) ; break <vul-start>, p, flags <vul-end> ) ; break\n"
  },
  {
    "id": 895,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int xid_map_enter ( netdissect_options * ndo , const struct sunrpc_msg * rp , const u_char * bp ) { const struct ip * ip = NULL ; const struct ip6_hdr * ip6 = NULL ; struct xid_map_entry * xmep ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ; switch ( IP_V ( ( const struct ip * ) bp ) ) { case 4 : ip = ( const struct ip * ) bp ; break ; case 6 : ip6 = ( const struct ip6_hdr * ) bp ; break ; default : return ( 1 ) ; } xmep = & xid_map [ xid_map_next ] ; if ( ++ xid_map_next >= XIDMAPSIZE ) xid_map_next = 0 ; UNALIGNED_MEMCPY ( & xmep -> xid , & rp -> rm_xid , sizeof ( xmep -> xid ) ) ; if ( ip ) { xmep -> ipver = 4 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip -> ip_src , sizeof ( ip -> ip_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip -> ip_dst , sizeof ( ip -> ip_dst ) ) ; } else if ( ip6 ) { xmep -> ipver = 6 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip6 -> ip6_src , sizeof ( ip6 -> ip6_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip6 -> ip6_dst , sizeof ( ip6 -> ip6_dst ) ) ; } <vul-start> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <vul-start> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> proc = EXTRACT_16BITS <vul-end> ( & rp <vul-start> rm_call. cb_proc <vul-end> ) ; xmep\n"
  },
  {
    "id": 896,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <vul-start> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <vul-end> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr )",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, & prevhdr, sizeof ( * prevhdr )\n"
  },
  {
    "id": 897,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> ( used_address && msg_sys -> msg_name && <vul-start> -> name , msg_sys <vul-end> -> msg_name , <vul-start> -> msg_namelen ; if ( msg_sys -> msg_name ) <vul-start> -> name , msg_sys <vul-end> -> msg_name ,\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> |= MSG_DONTWAIT ; used_address -> name_len = sizeof ( used_address -> name ) ; <vul-start> msg_sys -> msg_namelen ) { if (! msg -> msg_name ) return - EFAULT ; memcpy ( & used_address -> name, msg -> msg_name, used_address -> name_len ) ; err = sock_sendmsg_nosec ( sock, msg_sys, total_len ) ; goto out_freectl ; } err = sock_sendmsg ( sock, msg_sys, total_len ) ; if ( used_address && err >= 0 ) { used_address -> name_len = msg_sys -> msg_namelen ; memcpy ( & used_address -> name, msg -> msg_name, used_address -> name_len ) ; } out_freectl : if ( ctl_buf!= ctl ) sock_kfree_s ( sock -> sk, ctl_buf, ctl_len ) ; if ( ctl_buf!= ctl ) sock_kfree_s ( sock -> sk, ctl_buf, ctl_len ) ; out_freeiov : if ( iov!= iovstack ) sock_kfree_s ( sock -> sk, iov, iov_size ) ; out : return err <vul-end> ; }  \n"
  },
  {
    "id": 898,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <vul-start> lock_sock ( sk ) ; <vul-end> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) <vul-end> ; for (\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) <vul-end> ; for (\n"
  },
  {
    "id": 899,
    "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ; <vul-start> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <vul-end> skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Failed to read full block when scanning \" \"ISO9660 directory list\" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ;",
    "golden_answers": [
      "CWE-190 Fixed Code Lines are: <vul-start> = LOGICAL_BLOCK_SIZE * ( int64_t ) <vul-start> = LOGICAL_BLOCK_SIZE * ( int64_t )\n"
    ],
    "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; skipsize = archive_block_size ( a, <vul-start> vd -> location )\n"
  },
  {
    "id": 900,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <vul-start> const TileInfo * const tile , <vul-end> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> VP9_COMMON * cm = & cpi -> common ; <vul-end> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <vul-end> int bestsme = INT_MAX ; <vul-start> int further_steps , step_param ; <vul-end> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <vul-start> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <vul-end> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <vul-start> int tmp_row_max = x -> mv_row_max ; <vul-end> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <vul-start> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <vul-end> <vul-start> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <vul-end> <vul-start> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <vul-end> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> * x , <vul-end> BLOCK_SIZE bsize , <vul-start> -> e_mbd ; const <vul-start> { { 0 , 0 <vul-start> INT_MAX ; int <vul-end> step_param ; int <vul-start> MV ref_mv = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> x -> mv_row_max ; int cost_list [ 5 ] <vul-start> 0 ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> 1 ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> [ ref ] <vul-end> ; if ( <vul-start> -> sf . mv . auto_mv_step_size && cm -> <vul-end> show_frame ) { <vul-start> ( vp9_init_search_range ( <vul-end> x -> max_mv_context <vul-start> -> mv_step_param ) / 2 <vul-end> ; } else <vul-start> bsize < BLOCK_64X64 <vul-end> ) { int <vul-start> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <vul-end> - MIN ( <vul-start> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <vul-end> ) ) ; <vul-start> [ bsize ] <vul-end> ; int tlevel <vul-start> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <vul-start> <= ALTREF_FRAME && cm -> <vul-end> show_frame ; ++ <vul-start> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <vul-end> = 0 ; <vul-start> < MAX_MB_PLANE ; ++ i <vul-end> ) xd -> <vul-start> } return ; } <vul-start> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <vul-end> ; if ( <vul-start> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <vul-end> ( x , <vul-start> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <vul-start> bsize ] , <vul-end> cpi -> sf <vul-start> -> sf . mv . subpel_force_stop , <vul-end> cpi -> sf <vul-start> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <vul-end> , & x <vul-start> [ ref ] , NULL , 0 , 0 <vul-start> sf . adaptive_motion_search <vul-end> ) x -> <vul-start> [ ref ] <vul-end> = tmp_mv -> <vul-start> = tmp_mv -> as_mv <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x, const TileDataEnc * tile_data <vul-end>, BLOCK_SIZE bsize <vul-start> cpi -> common ; MB_MODE_INFO_EXT * const mbmi_ext = & cpi -> mbmi_ext <vul-start> -> mbmi ; const int bsize_ext = cpi -> sf. bsize_ext <vul-start> bestsme = INT_MAX ; int step_param ; int boffset = x -> mbmi_ext_offset <vul-start> 0 ] ; const MV_MODE_INFO_EXT * const ref_mv = & mbmi_ext <vul-end> -> ref_mvs [ <vul-start> ] [ 0 ]. as_mv ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_row_max ; int tmp_row_max = x -> mv_row_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi, ref ) ; const MV pred_mv [ 3 ] ; pred_mv [ 0 ] = mbmi_ext <vul-end> -> ref_mvs [ <vul-start> ] [ 0 <vul-end> ] ; pred_mv <vul-start> 1 ] = mbmi_ext <vul-end> -> ref_mvs [ <vul-start> 2 ] = mbmi_ext <vul-end> -> ref_mvs [ <vul-start> ref ] [ 1 <vul-end> ] ; if <vul-start> ] ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ]. pre [ 0 ] = backup_yv12 [ i ] ; } else { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ]. pre [ 0 ] = backup_yv12 [ i ] ; } } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full. col >>= 3 ; mvp_full. row >>= 3 ; further_steps = ( cpi -> sf. max_step_search_steps - 1 ) - step_param ; if ( cpi"
  },
  {
    "id": 901,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static INT AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) { guint8 key_version ; guint8 * key_data ; guint8 * szEncryptedKey ; guint16 key_bytes_len = 0 ; guint16 key_len ; static AIRPDCAP_KEY_ITEM dummy_key ; AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; if ( key_bytes_len < 16 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } <vul-start> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <vul-end> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; DEBUG_DUMP ( \"Encrypted Broadcast key:\" , szEncryptedKey , key_bytes_len ) ; DEBUG_DUMP ( \"KeyIV:\" , pEAPKey -> key_iv , 16 ) ; DEBUG_DUMP ( \"decryption_key:\" , decryption_key , 16 ) ; tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { guint8 new_key [ 32 ] ; guint8 dummy [ 256 ] ; rc4_state_struct rc4_state ; sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; memcpy ( new_key , pEAPKey -> key_iv , 16 ) ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> } if ( ( <vul-start> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <vul-end> key_bytes_len > eapol_len <vul-start> sizeof ( EAPOL_RSN_KEY )\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( ( key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) || ( <vul-start> key_bytes_len < GROUP_KEY_MIN_LEN )\n"
  },
  {
    "id": 902,
    "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <vul-start> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <vul-end> <vul-start> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <vul-end> sizeof ( ualg -> cru_driver_name ) ) ; <vul-start> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <vul-end> <vul-start> CRYPTO_MAX_ALG_NAME ) ; <vul-end> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <vul-start> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , \"%s\" , \"larval\" ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE",
    "golden_answers": [
      "CWE-310 Fixed Code Lines are: <vul-start> skb ) { strncpy ( <vul-end> ualg -> cru_name <vul-start> -> cru_name , <vul-end> alg -> cra_name <vul-start> ) ) ; strncpy ( <vul-end> ualg -> cru_driver_name <vul-start> -> cru_driver_name , <vul-end> alg -> cra_driver_name <vul-start> ) ) ; strncpy ( <vul-end> ualg -> cru_module_name <vul-start> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <vul-end> ; ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl . <vul-start> . type , \"larval\" , sizeof ( rl . type ) <vul-end> ) ; if\n"
    ],
    "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> skb ) { strlcpy <vul-end> ( & ualg <vul-start> ) ) ; strlcpy <vul-end> ( & ualg <vul-start> ) ) ; strlcpy <vul-end> ( & ualg <vul-start> ), CRYPTO_MAX_ALG_NAME ) ; strlcpy ( & ualg -> cru_flags, alg -> cra_flags, sizeof ( ualg -> cru_flags ) <vul-start> crypto_report_larval rl ; strlcpy <vul-end> ( rl. <vul-start>. type, \"larval\", sizeof ( rl. type ) <vul-end> ) ; if\n"
  },
  {
    "id": 903,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> case LZX_BLOCKTYPE_UNCOMPRESSED : if ( window_posn + this_run > lzx -> window_size ) { D ( ( \"match ran over window boundary\" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case LZX_BLOCKTYPE_UNCOMPRESSED : if ( lzx -> o_end - lzx -> o_ptr < LZX_BLOCK_SIZE ) { return lzx -> error = MSPACK_ERR_IO_CORRUPT ; }\n"
  },
  {
    "id": 904,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error: cannot get box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error: expecting signature box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect magic number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting file type box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { <vul-start> jas_eprintf",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> { jas_eprintf ( \"got box type %s\\\\n\" <vul-end> , box ->\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> 1 ) { if (! dec -> cmap ) { goto error ; }\n"
  },
  {
    "id": 905,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <vul-start> offset , <vul-end> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\"",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> , one , pixel_info_length ; ssize_t count , offset <vul-end> , y ; <vul-start> ; if ( ( offset < 0 ) || ( <vul-start> ) > pixel_info_length ) <vul-start> + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } <vul-start> + offset ; <vul-end> for ( i\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, one, pixel_info_length ; ssize_t count, offset <vul-end>, y ; <vul-start> ; if ( ( <vul-start> number_colormaps!= 0 ) && ( number_planes_filled!= 0 ) <vul-start> ; if ( ( <vul-start> number_planes_filled!= 0 ) && ( number_planes_filled!= 0 ) <vul-start> ; if ( ( <vul-start> number_planes_filled!= 0 ) && ( number_planes_filled!= 0 )\n"
  },
  {
    "id": 906,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <vul-start> wait_for_unix_gc ( ) ; <vul-end> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; int sk_locked ; <vul-start> out_free ; } sk_locked = 0 ; <vul-start> other ) ; restart_locked : <vul-start> ; if ( unlikely ( <vul-start> SOCK_DEAD ) ) ) <vul-start> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <vul-start> = 0 ; <vul-end> if ( unix_peer <vul-start> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <vul-start> } if ( unlikely ( <vul-start> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <vul-end> if ( ! <vul-start> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <vul-end> ) { err <vul-start> - EAGAIN ; sk_locked = 1 ; <vul-start> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <vul-end> if ( sock_flag <vul-start> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; bool peer_out = false ; <vul-start> out_free ; } peer_out = true ; <vul-start> ( other ) ; if ( peer_out ) goto out_unlock <vul-start> other ) ; peer_out = false ; <vul-start> } if ( peer_out ) { struct unix_dgram_peer * dgram_peer = unix_peer ( other ) ; if ( dgram_peer ) unix_dgram_peer_put ( dgram_peer ) ; } if ( <vul-start> ) ) { struct unix_dgram_peer * peer = unix_peer ( other ) ; <vul-start> (! timeo ||! peer_out ) { err = - ECONNREFUSED ; goto out_unlock ; } timeo = unix_wait_for_peer ( other, timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } unix_state_lock ( sk ) ; if ( peer_out ) { unix_dgram_peer_put ( peer ) ; peer = NULL ; goto out_free ; } err = - ECONNREFUSED ; if ( peer_out ) { unix_dgram_peer_put ( peer ) ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_type!= SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket, other -> sk_socket ) ; if ( err ) goto out_unlock ; err = - EAGAIN ; goto out_free ; goto out_free ; } if ( peer_out ) { <vul-start> ( other ) ; peer -> sk_data_ready ( sk ) ; sock_put ( sk ) ; return err ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( skb ) ; if (! peer_out ) unix_dgram_peer_put ( peer ) ; unix_state_unlock ( sk ) ; unix_dgram_peer_put ( peer ) ; unix_state_unlock ( sk ) ; unix_peer_put ( other ) ; if ( peer ) unix_dgram_peer_"
  },
  {
    "id": 907,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( \"%s unable to load config file; attempting to transcode legacy file.\" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( \"%s unable to transcode legacy file, starting unconfigured.\" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( \"%s unable to allocate a config object.\" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } btif_config_remove_unpaired ( config ) ; <vul-start> alarm_timer = alarm_new ( ) ; <vul-end> if ( ! alarm_timer ) { LOG_ERROR ( \"%s unable to create alarm.\" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> config ) ; if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = alarm_new ( 0\n"
  },
  {
    "id": 908,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( void ) { <vul-start> # line 52 \"dt_test2.pgc\" <vul-end> date date1 ; <vul-start> # line 53 \"dt_test2.pgc\" <vul-end> timestamp ts1 , ts2 ; <vul-start> # line 54 \"dt_test2.pgc\" <vul-end> char * text ; <vul-start> # line 55 \"dt_test2.pgc\" <vul-end> interval * i1 ; <vul-start> # line 56 \"dt_test2.pgc\" <vul-end> date * dc ; <vul-start> # line 57 \"dt_test2.pgc\" <vul-end> int i , j ; char * endptr ; ECPGdebug ( 1 , stderr ) ; ts1 = PGTYPEStimestamp_from_asc ( \"2003-12-04 17:34:29\" , NULL ) ; text = PGTYPEStimestamp_to_asc ( ts1 ) ; printf ( \"timestamp: %s\\\\n\" , text ) ; free ( text ) ; date1 = PGTYPESdate_from_timestamp ( ts1 ) ; dc = PGTYPESdate_new ( ) ; * dc = date1 ; text = PGTYPESdate_to_asc ( * dc ) ; printf ( \"Date of timestamp: %s\\\\n\" , text ) ; free ( text ) ; PGTYPESdate_free ( dc ) ; for ( i = 0 ; dates [ i ] ; i ++ ) { bool err = false ; date1 = PGTYPESdate_from_asc ( dates [ i ] , & endptr ) ; if ( date1 == INT_MIN ) { err = true ; } text = PGTYPESdate_to_asc ( date1 ) ; printf ( \"Date[%d]: %s (%c - %c)\\\\n\" , i , err ? \"-\" : text , endptr ? 'N' : 'Y' , err ? 'T' : 'F' ) ; free ( text ) ; if ( ! err ) { for ( j = 0 ; times [ j ] ; j ++ ) { int length = strlen",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { # line 62 <vul-end> \"dt_test2.pgc\" date date1 <vul-start> ; # line 63 <vul-end> \"dt_test2.pgc\" timestamp ts1 <vul-start> ; # line 64 <vul-end> \"dt_test2.pgc\" char * <vul-start> ; # line 65 <vul-end> \"dt_test2.pgc\" interval * <vul-start> ; # line 66 <vul-end> \"dt_test2.pgc\" date * <vul-start> ; # line 67 <vul-end> \"dt_test2.pgc\" int i\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { # line 51 <vul-end> \"dt_test2.pgc\" date date1 <vul-start> ; # line 51 <vul-end> \"dt_test2.pgc\" timestamp ts1 <vul-start> ; # line 51 <vul-end> \"dt_test2.pgc\" timestamp ts2 <vul-start> ; # line 51 <vul-end> \"dt_test2.pgc\" char * <vul-start> ; # line 55 <vul-end> \"dt_test2.pgc\" interval * <vul-start> ; # line 56 <vul-end> \"dt_test2.pgc\" date * <vul-start> ; # line 57 <vul-end> \"dt_test2.pgc\" int i\n"
  },
  {
    "id": 909,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"ES-IS\" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? \"bad pkt!\" : \"no header at all!\" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , \" nlpid 0x%02x packet not supported\" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , \" version %d packet not supported\" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , \" length indicator(%u) > PDU size (%u)!\" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , \" length indicator %u < min PDU size:\" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , \"%02X\" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t  SNPA (length: %u): %s\" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t  SNPA (length: %u): %s\" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <vul-end> 0 ) ND_PRINT <vul-start> ( ndo , \"\\\\n\\\\t  NET (length: %u) %s\" , netal , <vul-end> isonsap_string ( ndo\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> == 0 ) { ND_TCHECK2 ( * pptr, snpa ) ; if ( li < snpa ) { ND_PRINT ( ( ndo, \", bad redirect/li\" ) ) ; return ; } snpa = pptr ; pptr += snpal ; li -= snpal ; ND_PRINT ( ( ndo, \"\\\\n\\\\t %s\", isonsap_string ( ndo, dst, dstl ) ) ) ; <vul-start> ) ) ; }\n"
  },
  {
    "id": 910,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb ,",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , \"first meta block group too large: %u \" \"(group descriptor block count %u)\" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> EXT4_DESC_PER_BLOCK ( sb ) ; if ( db_count > EXT4_DEF_MAX_BLOCKS ) goto out_free_base ; sbi -> s_mb_cache = ext4_get_block_cache ( sb, sbi -> s_mb_cache\n"
  },
  {
    "id": 911,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void ov518_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t get altsetting\\\\n\" ) ; sd -> gspca_dev . usb_err = - EIO ; return ; } <vul-start> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <vul-end> ov518_reg_w32 ( sd , R51x_FIFO_PSIZE , packet_size & ~ 7 , 2 ) ; reg_w ( sd , 0x2b , 0 ) ; reg_w ( sd , 0x2c , 0 ) ; reg_w ( sd , 0x2d , 0 ) ; reg_w ( sd , 0x2e , 0 ) ; reg_w ( sd , 0x3b , 0 ) ; reg_w ( sd , 0x3c , 0 ) ; reg_w ( sd , 0x3d , 0 ) ; reg_w ( sd , 0x3e , 0 ) ; if ( sd -> bridge == BRIDGE_OV518 ) { reg_w_mask ( sd , 0x20 , 0x08 , 0x08 ) ; reg_w_mask ( sd , 0x28 , 0x80 , 0xf0 ) ; reg_w_mask ( sd , 0x38 , 0x80 , 0xf0 ) ; } else { reg_w ( sd , 0x28 , 0x80 ) ; reg_w ( sd , 0x38 , 0x80 ) ; } hsegs",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } packet_size = <vul-end> alt -> desc <vul-start> desc. wMaxPacketSize <vul-end> ; ov518_reg_w32 (\n"
  },
  {
    "id": 912,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void _isdn_setup ( struct net_device * dev ) { isdn_net_local * lp = netdev_priv ( dev ) ; ether_setup ( dev ) ; dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; <vul-start> dev -> header_ops = NULL ; <vul-end> dev -> netdev_ops = & isdn_netdev_ops ; dev -> tx_queue_len = 30 ; lp -> p_encap = ISDN_NET_ENCAP_RAWIP ; lp -> magic = ISDN_NET_MAGIC ; lp -> last = lp ; lp -> next = lp ; lp -> isdn_device = - 1 ; lp -> isdn_channel = - 1 ; lp -> pre_device = - 1 ; lp -> pre_channel = - 1 ; lp -> exclusive = - 1 ; lp -> ppp_slot = - 1 ; lp -> pppbind = - 1 ; skb_queue_head_init ( & lp -> super_tx_queue ) ; lp -> l2_proto = ISDN_PROTO_L2_X75I ; lp -> l3_proto = ISDN_PROTO_L3_TRANS ; lp -> triggercps = 6000 ; lp -> slavedelay = 10 * HZ ; lp -> hupflags = ISDN_INHUP ; lp -> onhtime = 10 ; lp -> dialmax = 1 ; lp -> flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL ; lp -> cbdelay = 25 ; lp -> dialtimeout = - 1 ; lp -> dialwait = 5 * HZ ; lp -> dialstarted = 0 ; lp -> dialwait_timer = 0 ; }",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->\n"
  },
  {
    "id": 913,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int raptor_rdfxml_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rdfxml_parser * rdf_xml_parser ; rdf_xml_parser = ( raptor_rdfxml_parser * ) rdf_parser -> context ; if ( ! uri ) return 1 ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NORMALIZE_LANGUAGE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NORMALIZE_LANGUAGE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <vul-start> if ( rdf_parser -> uri_filter ) <vul-end> raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rdf_xml_parser -> sax2 , uri ) ; if ( rdf_xml_parser -> id_set ) { raptor_free_id_set ( rdf_xml_parser -> id_set ) ; rdf_xml_parser -> id_set = NULL ; } if ( RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_CHECK_RDF_ID ) ) { rdf_xml_parser -> id_set = raptor_new_id_set ( rdf_parser -> world ) ; if ( ! rdf_xml_parser -> id_set ) return 1 ; } return 0 ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL, RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;\n"
  },
  {
    "id": 914,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int newkeys_to_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b ; struct sshcipher_ctx * cc ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey ; int r ; if ( ( newkey = ssh -> state -> newkeys [ mode ] ) == NULL ) return SSH_ERR_INTERNAL_ERROR ; enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; cc = ( mode == MODE_OUT ) ? ssh -> state -> send_context : ssh -> state -> receive_context ; if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ; if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ; if ( ( r = sshbuf_put_cstring ( b , enc -> name ) ) != 0 || ( r = sshbuf_put ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> enabled ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> block_size ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> key , enc -> key_len ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> iv , enc -> iv_len ) ) != 0 ) goto out ; if ( cipher_authlen",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ( r = <vul-end> sshbuf_put_cstring ( b\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> comp -> enabled <vul-end> ) )!=\n"
  },
  {
    "id": 915,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static Image * handle_add_command ( GraphicsManager * self , const GraphicsCommand * g , const uint8_t * payload , bool * is_dirty , uint32_t iid ) { # define ABRT ( code , ... ) { set_add_response ( # code , __VA_ARGS__ ) ; self -> loading_image = 0 ; if ( img ) img -> data_loaded = false ; return NULL ; } # define MAX_DATA_SZ ( 4u * 100000000u ) has_add_respose = false ; bool existing , init_img = true ; Image * img = NULL ; unsigned char tt = g -> transmission_type ? g -> transmission_type : 'd' ; enum FORMATS { RGB = 24 , RGBA = 32 , PNG = 100 } ; uint32_t fmt = g -> format ? g -> format : RGBA ; if ( tt == 'd' && self -> loading_image ) init_img = false ; if ( init_img ) { self -> last_init_graphics_command = * g ; self -> last_init_graphics_command . id = iid ; self -> loading_image = 0 ; if ( g -> data_width > 10000 || g -> data_height > 10000 ) ABRT ( EINVAL , \"Image too large\" ) ; remove_images ( self , add_trim_predicate , 0 ) ; img = find_or_create_image ( self , iid , & existing ) ; if ( existing ) { free_load_data ( & img -> load_data ) ; img -> data_loaded = false ; free_refs_data ( img ) ; * is_dirty = true ; self -> layers_dirty = true ; } else { img -> internal_id = internal_id_counter ++ ; img -> client_id =",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> ( EBADF , \"Failed to open file for graphics transmission with error: [%d] %s\" <vul-end> , errno ,\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ( EBADF, \"Failed to open file %s for graphics transmission with error: [%d] %s\" <vul-end>, fname,\n"
  },
  {
    "id": 916,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <vul-start> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <vul-end> <vul-start> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <vul-end> sizeof ( ualg -> cru_driver_name ) ) ; <vul-start> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <vul-end> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <vul-start> strlcpy ( rl . type , \"larval\" , sizeof ( rl . type ) ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ;",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> skb ) { strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl .\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> skb ) { strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl.\n"
  },
  {
    "id": 917,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <vul-start> . pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; } else { <vul-end> po -> tp_version <vul-start> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <vul-end> } case PACKET_RESERVE\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>. pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; goto out ; } <vul-start> = val ; ret = 0 ; out :\n"
  },
  {
    "id": 918,
    "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int dissect_u3v ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) { gint offset = 0 ; proto_tree * u3v_tree = NULL , * ccd_tree_flag , * u3v_telegram_tree = NULL , * ccd_tree = NULL ; gint data_length = 0 ; gint req_id = 0 ; gint command_id = - 1 ; gint status = 0 ; guint prefix = 0 ; proto_item * ti = NULL ; proto_item * item = NULL ; const char * command_string ; usb_conv_info_t * usb_conv_info ; gint stream_detected = FALSE ; gint control_detected = FALSE ; u3v_conv_info_t * u3v_conv_info = NULL ; gencp_transaction_t * gencp_trans = NULL ; usb_conv_info = ( usb_conv_info_t * ) data ; u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; if ( ! u3v_conv_info ) { u3v_conv_info = wmem_new0 ( wmem_file_scope ( ) , u3v_conv_info_t ) ; <vul-start> usb_conv_info -> class_data = u3v_conv_info ; <vul-end> } prefix = tvb_get_letohl ( tvb , 0 ) ; if ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) { control_detected = TRUE ; } if ( ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) ) ) || ( usb_conv_info -> endpoint == u3v_conv_info -> ep_stream ) ) { stream_detected = TRUE ; } if ( control_detected || stream_detected ) { if ( usb_conv_info -> interfaceClass == IF_CLASS_UNKNOWN && usb_conv_info -> interfaceSubclass == IF_SUBCLASS_UNKNOWN ) { usb_conv_info ->",
    "golden_answers": [
      "CWE-476 Fixed Code Lines are: <vul-start> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0\n"
    ],
    "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> class_data = u3v_conv_info ; } else if ( usb_conv_info -> class_data ) { return 0\n"
  },
  {
    "id": 919,
    "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ; <vul-start> static size_t scanned ; <vul-end> static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read",
    "golden_answers": [
      "CWE-399 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> if ( scanned\n"
    ],
    "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> = 0 ; size_t scanned ; size_t <vul-end> readnbd ; if\n"
  },
  {
    "id": 920,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_modules ( ) { assert_true_rule ( <vul-start> \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.one + 1 == tests.constants.two \\\\\\n }\" , <vul-end> NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.empty == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.empty() == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[1].i == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 or true \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[0] == 0 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[1] == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,2) == 3 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.one + 1 == tests.constants.two \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.empty == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.empty() == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[1].i == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[0].i == 1 or true \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[0] == 0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[1] == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[256] == 256 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2) == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2,3) == 6 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) == tests.foobar(1) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) != tests.foobar(2) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.struct_array[0].i == 1 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.isum(1,1) == 3 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"foo\\\\\") == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"bar\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/i,\\\\\"FOO\\\\\\\\nBAR\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/is,\\\\\"FOO\\\\\\\\nBAR\\\\\") == 7\\\\\\n      }\" <vul-end> , NULL )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n }\" <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,1) == 3 \\\\\\n }\", NULL ) ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.0,2.0) == 3."
  },
  {
    "id": 921,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , \"%s()\\\\n\" , __func__ ) ; <vul-start> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <vul-end> flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , \"%s(), Received truncated frame (%zd < %zd)!\\\\n\" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , \"%s(), Starting IrTTP\\\\n\" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> __func__ ) ; msg -> msg_namelen = 0 ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( sk, msg -> msg_namelen,\n"
  },
  {
    "id": 922,
    "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <vul-start> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <vul-end> if ( ! newscratch ) { failf ( data , \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } <vul-start> } <vul-end> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent =",
    "golden_answers": [
      "CWE-787 Fixed Code Lines are: <vul-start> ( 2 * UPLOAD_BUFSIZE <vul-end> ) ; if <vul-start> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;\n"
    ],
    "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = scratch ; if ( data -> set. buffer_size > 0 ) { <vul-start> ; } } else { failf ( data, \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } }\n"
  },
  {
    "id": 923,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <vul-start> int n , len ; <vul-end> skb -> sk = NULL ; <vul-start> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <vul-end> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <vul-start> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <vul-end> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; int n <vul-end> ; skb -> <vul-start> rose_facilities_struct ) ) <vul-end> ; if ( <vul-start> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <vul-end> & facilities )\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> rose_facilities_struct facilities ; struct rose_facilities_struct * new_facilities ; <vul-start> = NULL ; if (! skb_is_gso ( skb ) ) return 0 ; new_facilities = rose_alloc_facilities ( ROSE_MIN_FACILITIES_OFF, sizeof ( struct rose_facilities_struct ) ) ; if (! new_facilities ) return 0 ; <vul-start>! rose_parse_facilities ( new_facilities <vul-end>, & facilities\n"
  },
  {
    "id": 924,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s (%u), length: %u\" , tok2str ( bgp_capcode_values , \"Unknown\" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { <vul-start> case BGP_CAPCODE_MP : <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tAFI %s (%u), SAFI %s (%u)\" , tok2str ( af_values , \"Unknown\" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , \"Unknown\" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tRestart Flags: [%s], Restart Time %us\" , ( ( opt [ i + 2 ] ) & 0x80 ) ? \"R\" : \"none\" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s\" , tok2str",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> case BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case BGP_CAPCODE_MP : ND_TCHECK_16BITS ( opt + i + 2 ) ;\n"
  },
  {
    "id": 925,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { SC_AC_OP_DELETE , SC_AC_OP_CREATE , SC_AC_OP_CREATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , SC_AC_OP_LOCK , SC_AC_OP_DELETE , - 1 } ; const int ef_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_UPDATE , SC_AC_OP_WRITE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; const int efi_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_ERASE , SC_AC_OP_UPDATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; u8 bValue ; int i ; int iKeyRef = 0 ; int iMethod ; int iPinCount ; int iOffset = 0 ; int iOperation ; const int * p_idx ; while ( len > 1 ) { size_t iACLen = buf [ iOffset ] & 0x0F ; if ( iACLen > len ) break ; iMethod = SC_AC_NONE ; if ( buf [ iOffset ] & 0X80 ) { size_t iParmLen = 1 ; size_t iKeyLen = 0 ; if ( buf [ iOffset ] & 0x20 ) iKeyLen ++ ; if ( buf [ iOffset + 1 ] & 0x40 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x20 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x10 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x08 ) iParmLen ++ ; if ( iKeyLen ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ;",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> break ; } if ( iACLen > 0 ) { <vul-start> - 1 ; }\n"
  },
  {
    "id": 926,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , apr_size_t len , int linelimit ) { apr_size_t i = 0 ; while ( i < len ) { char c = buffer [ i ] ; ap_xlate_proto_from_ascii ( & c , 1 ) ; <vul-start> if ( ctx -> state == BODY_CHUNK_END ) { <vul-end> if ( c == LF ) { <vul-start> ctx -> state = BODY_CHUNK ; <vul-end> } i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if ( ! apr_isxdigit ( c ) ) { <vul-start> return APR_EGENERAL ; <vul-end> } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; <vul-start> ctx -> chunkbits = sizeof ( long ) * 8 ; <vul-end> ctx -> chunk_used = 0 ; } <vul-start> if ( c == ';' || c == CR ) { <vul-end> ctx -> state = BODY_CHUNK_EXT ; } <vul-start> else if ( c == LF ) { <vul-end> if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state != BODY_CHUNK_EXT ) { <vul-start> int xvalue = 0 ; <vul-end> if ( ! ctx -> remaining && c == '0' ) { i ++ ; <vul-start> continue ; <vul-end> } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else if ( c >= 'A' && c <= 'F' ) { xvalue = c -",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <vul-start> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <vul-start> ) { return APR_EINVAL <vul-end> ; } else <vul-start> = sizeof ( apr_off_t <vul-end> ) * 8 <vul-start> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <vul-end> ) { ctx <vul-start> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <vul-end> ) { int <vul-start> { int xvalue <vul-end> ; if ( <vul-start> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <vul-start> else { return APR_EINVAL <vul-end> ; } ctx <vul-start> | xvalue ; if ( <vul-end> ctx -> remaining <vul-start> APR_ENOSPC ; } } else { return APR_EGENERAL ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( i >= len ) { return APR_EGENERAL ; } if ( <vul-start> -> state = BODY_CHUNK_END ; } else { ctx -> state = <vul-start> ) ) { ctx -> remaining = 0 ; ctx -> chunkbits = sizeof ( long ) * 8 ; ctx -> chunk_used = 0 ; } if ( c == ';' || c == CR ) { ctx -> state = BODY_CHUNK_EXT ; } else if ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_EXT ) { int xvalue = 0 ; if (! ctx -> remaining && c == '0' ) { i ++ ; continue ; } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else { xvalue = c - 'A' + 0xa ; } else { if ( c == LF ) { ctx -> state = BODY_CHUNK ; } else { <vul-end> ctx -> remaining <vul-start> ctx -> chunkbits = ( <vul-end> sizeof ( long <vul-start> ) * 8 ) * 8 <vul-start> 0 ; } <vul-end> if ( ctx <vul-start> ; } else <vul-end> { return APR_EGENERAL <vul-start> APR_EGENERAL ; } } <vul-start> | xvalue ; if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) { return APR_ENOSPC ; } } i ++ ; } ctx -> chunk_used += len ; if ( ctx -> chunk_used < 0 || ctx -> chunk_used > linelimit ) { return APR_ENOSPC ; } return APR_SUCCESS <vul-end> ; }  \n"
  },
  {
    "id": 927,
    "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <vul-start> krb5_data rspac ; <vul-end> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset",
    "golden_answers": [
      "CWE-295 Fixed Code Lines are: <vul-start> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <vul-start> , cp , tgt_realm ,\n"
    ],
    "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ; krb5_data rspac ; int has_tgs_req = 0 <vul-start> out ; } has_tgs_req = ( t -> enc_part. etype == KRB5_KDC_REQ_TYPE_TGS_REQ ) ; if ( has_tgs_req ) { if ( t -> enc_part. etype == KRB5_KDC_REQ_TYPE_TGS_REQ ) { if (! has_tgs_req ) { ret = KRB5KDC_ERR_NOENTRY ; goto out ; } ret = _krb5_get_tgs_req ( context, t, & sp, & spn ) ; if ( ret ) goto out ; } <vul-start> ; if ( has_tgs_req ) { if ( <vul-start> ; } } } if ( has_tgs_req ) { if (! t -> enc_part. etype ) { ret = KRB5KDC_ERR_NOENTRY ; goto out ; } ret = _krb5_get_tgs_req ( context, t, & sp, & spn ) ; if ( ret ) goto out ; ret = _krb5_get_tgs_req ( context, t, & sp, & spn ) ; if ( ret ) goto out ; } if (\n"
  },
  {
    "id": 928,
    "question": "CWE-918 Code Input Vulnerable Code Is: CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , \"Source string too long\" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , \"Read from client failed: %s\" , errbuf ) ; return - 1 ; } source [ nread ] = '\\\\0' ; plen -= nread ; <vul-start> if ( ( fp = pcap_open_live ( source , <vul-end> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error",
    "golden_answers": [
      "CWE-918 Fixed Code Lines are: <vul-start> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , \"Source string refers to a remote device\" ) ; goto error ; } if (\n"
    ],
    "generated_answer": "CWE-918 Fixed Code Lines are: <vul-start> ( source, 1500, 0, 1000, errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL, sizeof ( struct rpcap_header ), NULL, & sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header ), NULL, & sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl, sendbuf, sendbufidx <vul-end>, errbuf,\n"
  },
  {
    "id": 929,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int archive_read_format_rar_read_data ( struct archive_read * a , const void * * buff , size_t * size , int64_t * offset ) { struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; int ret ; if ( rar -> has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW ) { rar -> has_encrypted_entries = 0 ; } if ( rar -> bytes_unconsumed > 0 ) { __archive_read_consume ( a , rar -> bytes_unconsumed ) ; rar -> bytes_unconsumed = 0 ; } * buff = NULL ; if ( rar -> entry_eof || rar -> offset_seek >= rar -> unp_size ) { * size = 0 ; * offset = rar -> offset ; if ( * offset < rar -> unp_size ) * offset = rar -> unp_size ; return ( ARCHIVE_EOF ) ; } switch ( rar -> compression_method ) { case COMPRESS_METHOD_STORE : ret = read_data_stored ( a , buff , size , offset ) ; break ; case COMPRESS_METHOD_FASTEST : case COMPRESS_METHOD_FAST : case COMPRESS_METHOD_NORMAL : case COMPRESS_METHOD_GOOD : case COMPRESS_METHOD_BEST : ret = read_data_compressed ( a , buff , size , offset ) ; <vul-start> if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) <vul-end> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context ) ; <vul-start> break ; <vul-end> default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported compression method for RAR file.\" ) ; ret = ARCHIVE_FATAL ; break ; } return ( ret ) ; }",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> != ARCHIVE_WARN ) { <vul-start> ppmd7_context ) ; rar -> start_new_table = 1 ; }\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>!= ARCHIVE_WARN ) { <vul-start> ; break ; }\n"
  },
  {
    "id": 930,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 void handle_stdfmna ( struct pt_regs * regs , unsigned long sfar , unsigned long sfsr ) { unsigned long pc = regs -> tpc ; unsigned long tstate = regs -> tstate ; u32 insn ; u64 value ; u8 freg ; int flag ; struct fpustate * f = FPUSTATE ; if ( tstate & TSTATE_PRIV ) die_if_kernel ( \"stdfmna from kernel\" , regs ) ; <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <vul-end> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) { int asi = decode_asi ( insn , regs ) ; freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; value = 0 ; flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ( asi > ASI_SNFL ) || ( asi < ASI_P ) ) goto daex ; save_and_clear_fpu ( ) ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) value = * ( u64 * ) & f -> regs [ freg ] ; switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : value = __swab64p ( & value ) ; break ; default : goto daex ; } if ( put_user ( value >> 32 , ( u32 __user * ) sfar ) || __put_user ( (",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <vul-end> , regs ,\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS, 1 <vul-end>, regs,\n"
  },
  {
    "id": 931,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 const vpx_codec_cx_pkt_t * vpx_codec_get_cx_data ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { const vpx_codec_cx_pkt_t * pkt = NULL ; if ( ctx ) { if ( ! iter ) ctx -> err = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else <vul-start> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <vul-end> } if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { vpx_codec_priv_t * const priv = ctx -> priv ; char * const dst_buf = ( char * ) priv -> enc . cx_data_dst_buf . buf ; if ( dst_buf && pkt -> data . raw . buf != dst_buf && pkt -> data . raw . sz + priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after <= priv -> enc . cx_data_dst_buf . sz ) { vpx_codec_cx_pkt_t * modified_pkt = & priv -> enc . cx_data_pkt ; memcpy ( dst_buf + priv -> enc . cx_data_pad_before , pkt -> data . raw . buf , pkt -> data . raw . sz ) ; * modified_pkt = * pkt ; modified_pkt -> data . raw . buf = dst_buf ; modified_pkt -> data . raw . sz += priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after ; pkt = modified_pkt ; } if ( dst_buf == pkt -> data",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> . get_cx_data ( get_alg_priv ( ctx ) <vul-end> , iter )\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. get_cx_data ( get_alg_priv ( ctx ) <vul-end>, iter )\n"
  },
  {
    "id": 932,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-c\" ) || ! strcmp ( argv [ i ] , \"--config-file\" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error: Unable to open configuration file.\" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error: -c argument given, but no config file specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-d\" ) || ! strcmp ( argv [ i ] , \"--daemon\" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , \"-h\" ) || ! strcmp ( argv [ i ] , \"--help\" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) || ! strcmp ( argv [ i ] , \"--port\" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> endif config -> default_listener. security_options. password_file = config -> default_listener. password_file ; config ->\n"
  },
  {
    "id": 933,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void yv12_extend_frame_bottom_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = ybf -> y_height ; src_ptr1 = ybf -> y_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = ybf -> uv_height ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } }",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 ,\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2,\n"
  },
  {
    "id": 934,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 ctb_log2_size_y = 0 ; BITS_PARSE ( \"video_parameter_set_id\" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( \"sps_max_sub_layers_minus1\" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( \"sps_temporal_id_nesting_flag\" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( \"seq_parameter_set_id\" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( \"chroma_format_idc\" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( ( ps_sps -> i1_sps_max_num_reorder_pics < 0 ) || ( ps_sps -> i2_sps_max_num_reorder_pics + 1 ) >= MAX_SPS_NT ) { return IHEVCD_INVALID_PARAMETER ; }\n"
  },
  {
    "id": 935,
    "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <vul-start> u16 selector , int seg , u8 cpl , bool in_task_switch ) <vul-end> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ;",
    "golden_answers": [
      "CWE-264 Fixed Code Lines are: <vul-start> , bool in_task_switch , struct desc_struct * desc <vul-start> seg ) ; if ( desc ) * desc = seg_desc ;\n"
    ],
    "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, u8 cpl <vul-end> ) { struct <vul-start> seg ) ; if (! in_task_switch ) return X86EMUL_CONTINUE ;\n"
  },
  {
    "id": 936,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_setup_past_independence ( VP9_COMMON * cm ) { struct loopfilter * const lf = & cm -> lf ; int i ; vp9_clearall_segfeatures ( & cm -> seg ) ; cm -> seg . abs_delta = SEGMENT_DELTADATA ; <vul-start> if ( cm -> last_frame_seg_map ) <vul-end> <vul-start> vpx_memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <vul-end> vp9_zero ( lf -> last_ref_deltas ) ; vp9_zero ( lf -> last_mode_deltas ) ; set_default_lf_deltas ( lf ) ; lf -> last_sharpness_level = - 1 ; vp9_default_coef_probs ( cm ) ; <vul-start> vp9_init_mode_probs ( & cm -> fc ) ; <vul-end> <vul-start> vp9_init_mv_probs ( cm ) ; <vul-end> if ( cm -> frame_type == KEY_FRAME || cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { for ( i = 0 ; i < FRAME_CONTEXTS ; ++ i ) <vul-start> cm -> frame_contexts [ i ] = cm -> fc ; <vul-end> } else if ( cm -> reset_frame_context == 2 ) { <vul-start> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <vul-end> } <vul-start> if ( frame_is_intra_only ( cm ) ) <vul-end> <vul-start> vpx_memset ( cm -> prev_mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * <vul-end> <vul-start> sizeof ( * cm -> prev_mip ) ) ; <vul-end> vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ; vp9_zero ( cm -> ref_frame_sign_bias ) ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> cm -> last_frame_seg_map && ! cm -> frame_parallel_decode ) memset <vul-end> ( cm -> <vul-start> cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; if ( cm -> current_frame_seg_map ) memset ( cm -> current_frame_seg_map <vul-start> cm ) ; init_mode_probs ( <vul-end> cm -> fc <vul-start> ( cm ) ; cm -> fc -> initialized = 1 <vul-start> i ] = * <vul-start> frame_context_idx ] = * <vul-start> ( cm ) && <vul-end> cm -> prev_mip <vul-start> cm -> prev_mip && ! cm -> frame_parallel_decode ) memset ( cm -> prev_mip , 0 , <vul-end> cm -> mi_stride <vul-start> cm -> prev_mip <vul-end> ) ) ;\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> last_frame_seg_map ) memset <vul-end> ( cm -> <vul-start> cm -> mi_cols <vul-end> ) ) ; <vul-start> cm ) ; set_default_lf_deltas ( lf ) ; lf -> last_sharpness_level = - 1 ; vpx_init_mode_probs ( & cm -> fc ) ; vpx_init_mv_probs ( cm ) ; if ( cm -> frame_type == KEY_FRAME || cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { for ( i = 0 ; i < FRAME_CONTEXTS ; ++ i ) cm -> frame_contexts [ i ] = cm -> fc ; } else if ( cm -> reset_frame_context == 2 ) { <vul-end> cm -> frame_contexts <vul-start> cm -> fc ; } else if ( cm -> reset_frame_context == 3 ) { cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; } else if ( cm -> reset_frame_context == 2 ) { cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; } if ( frame_is_intra_only ( cm ) ) memset <vul-end> ( cm -> <vul-start> cm -> prev_mip ) ) ; memset <vul-end> ( cm -> <vul-start> -> mi_cols ) <vul-end> ) ) ; <vul-start> ) ) ; memset <vul-end> ( cm -> <vul-start> ref_frame_sign_bias ) ; memset <vul-end> ( cm -> <vul-start> cm -> fc, 0, cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> fc ) ) ; <vul-start> cm -> fc, 0, cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> fc ) ) ; cm -> ref_frame_sign_bias = 0 ; cm -> last_ref_deltas = lf -> last_mode_deltas = lf -> last_mode_deltas = - 1 ; set_default_lf_deltas ( lf ) ; set_default_lf_deltas ( lf ) ; set_default_lf_deltas ( lf ) ; set_default_lf_deltas ( lf ) ; set_default_lf_deltas ( lf ) ; set_default_lf_"
  },
  {
    "id": 937,
    "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <vul-start> rcu_read_lock ( ) ; <vul-end> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <vul-start> if ( ! head -> dev ) <vul-end> goto out_rcu_unlock ; <vul-start> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <vul-end> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <vul-start> } <vul-end> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q .",
    "golden_answers": [
      "CWE-000 Fixed Code Lines are: <vul-start> . fragments ; const struct iphdr * iph ; int err ; <vul-start> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <vul-start> == IP_DEFRAG_CONNTRACK_IN && <vul-end> skb_rtable ( head <vul-start> goto out_rcu_unlock ; <vul-end> icmp_send ( head\n"
    ],
    "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>. fragments ; struct iphdr * iph ; <vul-start> -> dev ) { err = ip_route_input ( head, iph -> daddr, iph -> saddr, iph -> tos, head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type!= RTN_LOCAL ) goto out_rcu_unlock ; } icmp_send ( head, ICMP_TIME_EXCEEDED, ICMP_EX_FRAGTIME, 0 ) ; <vul-start> user == IP_DEFRAG_CONNTRACK_IN <vul-end> ) goto out_rcu_unlock <vul-start> goto out_rcu_unlock ; <vul-end> } out :\n"
  },
  {
    "id": 938,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , blue , bytes_per_line , green , length , red ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; count = ReadBlob ( image , 2 , magick ) ; do { LongPixelPacket shift ; PixelPacket quantum_bits ; size_t profile_data , profile_size ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ;",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) break ; if ( bmp_info. ba_offset >= ( offset + bmp_info. ba_size ) ) { break ; }\n"
  },
  {
    "id": 939,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_yv12_extend_frame_borders_c ( YV12_BUFFER_CONFIG * ybf ) { <vul-start> assert ( ybf -> y_height - ybf -> y_crop_height < 16 ) ; <vul-end> assert ( ybf -> y_width - ybf -> y_crop_width < 16 ) ; assert ( ybf -> y_height - ybf -> y_crop_height >= 0 ) ; assert ( ybf -> y_width - ybf -> y_crop_width >= 0 ) ; <vul-start> extend_plane ( ybf -> y_buffer , ybf -> y_stride , <vul-end> ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane ( ybf -> u_buffer , ybf -> uv_stride , <vul-start> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <vul-end> ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf -> y_width - ybf -> y_crop_width + 1 ) / 2 ) ; extend_plane ( ybf -> v_buffer , ybf -> uv_stride , <vul-start> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <vul-end> ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf ->",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> ybf ) { const int uv_border = ybf -> border / 2 ; assert ( ybf -> border % 2 == 0 ) ; <vul-start> 0 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { extend_plane_high ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane_high ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; extend_plane_high ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; return ; } # endif <vul-start> -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <vul-end> ) ; extend_plane <vul-start> -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <vul-end> ) ; }\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ybf ) { int uv_width, uv_height, uv_height ; assert ( ybf -> uv_width - uv_height < 8 ) ; assert ( ybf -> uv_height - uv_width < 8 ) ; assert ( ybf -> uv_height - uv_height >= 0 ) ; assert ( ybf -> uv_width - uv_width >= 0 ) ; assert ( ybf -> uv_height - uv_height >= 0 ) ; assert ( ybf -> uv_width - uv_width >= 0 ) ; extend_plane ( ybf -> y_buffer, ybf -> uv_stride, ybf -> uv_crop_width, ybf -> uv_crop_height, ybf -> border, ybf -> border, ybf -> border + ybf -> y_height - ybf -> y_crop_height, ybf -> border + ybf -> y_height - ybf -> y_crop_height, ybf -> border + ybf -> y_crop_width, ybf -> border + ybf -> uv_height - ybf -> uv_crop_height, ybf -> border + ybf -> uv_width - ybf -> uv_crop_width, ybf -> border + ybf -> uv_height - ybf -> uv_crop_height, ybf -> border + ybf -> uv_width - ybf -> uv_width, ybf -> uv + ybf -> uv_height - ybf -> uv_height, ybf -> border + ybf -> uv_width - ybf -> uv_height + 1 ) / 2, ( ybf -> border + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf -> uv + ybf ->"
  },
  {
    "id": 940,
    "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( \"No USB device connected to ttyUSB%i\\\\n\" , co -> index ) ; return - ENODEV ; } serial = port ->",
    "golden_answers": [
      "CWE-416 Fixed Code Lines are: <vul-start> = 0 ; info -> port = NULL ;\n"
    ],
    "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> error_get_interface : usb_serial_put\n"
  },
  {
    "id": 941,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ALGobject * ALGnew ( PyObject * self , PyObject * args , PyObject * kwdict ) { unsigned char * key , * IV ; ALGobject * new = NULL ; int keylen , IVlen = 0 , mode = MODE_ECB , segment_size = 0 ; PyObject * counter = NULL ; int counter_shortcut = 0 ; # ifdef PCT_ARC2_MODULE int effective_keylen = 1024 ; # endif if ( ! PyArg_ParseTupleAndKeywords ( args , kwdict , \"s#|is#Oi\" # ifdef PCT_ARC2_MODULE \"i\" # endif , kwlist , & key , & keylen , & mode , & IV , & IVlen , & counter , & segment_size # ifdef PCT_ARC2_MODULE , & effective_keylen # endif ) ) { return NULL ; } if ( mode < MODE_ECB || mode > MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"Unknown cipher feedback mode %i\" , mode ) ; return NULL ; } if ( mode == MODE_PGP ) { PyErr_Format ( PyExc_ValueError , \"MODE_PGP is not supported anymore\" ) ; return NULL ; } if ( KEY_SIZE != 0 && keylen != KEY_SIZE ) { PyErr_Format ( PyExc_ValueError , \"Key must be %i bytes long, not %i\" , KEY_SIZE , keylen ) ; return NULL ; } if ( KEY_SIZE == 0 && keylen == 0 ) { PyErr_SetString ( PyExc_ValueError , <vul-start> \"Key cannot be the null string\" ) ; <vul-end> return NULL ; } if ( IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"IV must be %i bytes long\" , BLOCK_SIZE ) ; return NULL",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> PyExc_ValueError , \"Key cannot be the null string\" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_ECB ) { PyErr_Format ( PyExc_ValueError , \"ECB mode does not use IV\" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"CTR mode needs counter parameter, not IV\"\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( PyExc_ValueError, \"Key cannot be the null string\" <vul-end> ) ; return\n"
  },
  {
    "id": 942,
    "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <vul-start> struct blkif_response resp ; <vul-end> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <vul-start> resp . id = id ; <vul-end> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <vul-start> } <vul-end> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }",
    "golden_answers": [
      "CWE-200 Fixed Code Lines are: <vul-start> { struct blkif_response * <vul-start> int notify ; <vul-end> spin_lock_irqsave ( & <vul-start> case BLKIF_PROTOCOL_NATIVE : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> native . rsp_prod_pvt <vul-end> ) ; break <vul-start> case BLKIF_PROTOCOL_X86_32 : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> x86_32 . rsp_prod_pvt <vul-end> ) ; break <vul-start> case BLKIF_PROTOCOL_X86_64 : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> . rsp_prod_pvt ) <vul-end> ; break ; <vul-start> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;\n"
    ],
    "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> st ) { <vul-end> unsigned long flags <vul-start> int notify ; struct xen_blkif_response * rsp = & ring -> response ; struct blkif_response * resp = & ring -> response ; <vul-end> spin_lock_irqsave ( & <vul-start> case BLKIF_PROTOCOL_NATIVE : rsp -> id = id ; rsp -> operation = op ; rsp -> status = st ; memcpy ( & rsp -> data <vul-end>, blk_rings -> <vul-start> case BLKIF_PROTOCOL_X86_32 : rsp -> id = <vul-end> blk_rings -> x86_32 <vul-start> case BLKIF_PROTOCOL_X86_64 : rsp -> id = <vul-end> blk_rings -> x86_64 <vul-start> blk_rings -> x86_64 ; memcpy ( & rsp -> data <vul-end>, blk_rings -> <vul-start> ) ; } memcpy ( & rsp -> data [ 0 ], & resp, sizeof ( resp ) ) ; memcpy ( & rsp -> data [ 1 ], & resp, sizeof ( resp ) ) ;\n"
  },
  {
    "id": 943,
    "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES ( c_id , c_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_ID ) && POKE_UINT8 ( p_id_subtype",
    "golden_answers": [
      "CWE-617 Fixed Code Lines are: <vul-start> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <vul-end> ; if (\n"
    ],
    "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> -> m_family ; if (! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT16 ( mgmt -> m_id_subtype ) && POKE_BYTES ( mgmt -> m_id, p_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ;\n"
  },
  {
    "id": 944,
    "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; int cgroup_callbacks_done = 0 ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= p -> signal -> rlim [ RLIMIT_NPROC ] . rlim_cur ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } retval",
    "golden_answers": [
      "CWE-400 Fixed Code Lines are: <vul-start> ; bad_fork_cleanup_io : if <vul-end> ( p -> <vul-start> p -> io_context ) exit_io_context ( p\n"
    ],
    "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; bad_fork_cleanup_io : if ( p -> io_context )\n"
  },
  {
    "id": 945,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) { const uint8_t * frame_start = frame ; const uint8_t * frame_end = frame + width * height ; int mask = 0x10000 , bitbuf = 0 ; int i , v , offset , count , segments ; segments = bytestream2_get_le16 ( gb ) ; while ( segments -- ) { if ( bytestream2_get_bytes_left ( gb ) < 2 ) return AVERROR_INVALIDDATA ; if ( mask == 0x10000 ) { bitbuf = bytestream2_get_le16u ( gb ) ; mask = 1 ; } if ( bitbuf & mask ) { v = bytestream2_get_le16 ( gb ) ; offset = ( v & 0x1FFF ) << 2 ; count = ( ( v >> 13 ) + 2 ) << 1 ; if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < count ; i ++ ) { frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; frame += 2 ; } } else if ( bitbuf & ( mask << 1 ) ) { v = bytestream2_get_le16 ( gb ) * 2 ; if ( frame - frame_end < v ) return AVERROR_INVALIDDATA ; frame += v ; } else { <vul-start> if ( frame_end - frame < width + 3 ) <vul-end> return AVERROR_INVALIDDATA ; frame [ 0",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> < width + 4 <vul-end> ) return AVERROR_INVALIDDATA\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> frame < width <vul-end> ) return AVERROR_INVALIDDATA\n"
  },
  {
    "id": 946,
    "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) { phar_zip_dir_end locator ; char buf [ sizeof ( locator ) + 65536 ] ; zend_long size ; php_uint16 i ; phar_archive_data * mydata = NULL ; phar_entry_info entry = { 0 } ; char * p = buf , * ext , * actual_alias = NULL ; char * metadata = NULL ; size = php_stream_tell ( fp ) ; if ( size > sizeof ( locator ) + 65536 ) { size = sizeof ( locator ) + 65536 ; if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , \"phar error: unable to search for end of central directory in zip-based phar \\\\\"%s\\\\\"\" , fname ) ; } return FAILURE ; } } else { php_stream_seek ( fp , 0 , SEEK_SET ) ; } if ( ! php_stream_read ( fp , buf , size ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\\\"%s\\\\\"\" , fname ) ; } return FAILURE ; } while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf",
    "golden_answers": [
      "CWE-119 Fixed Code Lines are: <vul-start> entry . uncompressed_filesize || read <= 8\n"
    ],
    "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( read < 0 || read\n"
  },
  {
    "id": 947,
    "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) )",
    "golden_answers": [
      "CWE-20 Fixed Code Lines are: <vul-start> ; olddentry = lookup_one_len ( old <vul-end> -> d_name . <vul-start> . name , old_upperdir , old <vul-end> -> d_name . <vul-start> = PTR_ERR ( olddentry <vul-end> ) ; if <vul-start> ( IS_ERR ( olddentry <vul-end> ) ) goto <vul-start> goto out_unlock ; <vul-end> err = - <vul-start> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <vul-end> ) goto out_dput <vul-start> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <vul-end> ) goto out_dput <vul-start> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <vul-start> newdentry ) ; out_dput_old : dput ( olddentry ) ;\n"
    ],
    "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> old_upperdir ) ; if (! overwrite ) { err = - EEXIST ; goto out_revert_creds ; } <vul-start> = true ; err = PTR_ERR ( newdentry ) ; if (! err ) goto out_unlock ; err = - ESTALE ; if ( olddentry -> d_parent!= old_upperdir ) goto out_dput ; if ( newdentry -> d_parent!= new_upperdir ) goto out_dput ; if ( olddentry == trap ) goto out_dput ; if ( newdentry == trap ) goto out_dput ; if ( is_dir &&! new -> d_inode && new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } } if (! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) { if (! new_opaque ) { err = - EEXIST ; goto out_revert_creds ; } } else { new_create = true ; <vul-start> len ) ; if (! newdentry ) { err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_unlock ; } err = - ESTALE ; if ( olddentry -> d_parent!= old_upperdir ) goto out_dput ; if ( newdentry -> d_parent!= new_upperdir ) goto out_dput ; if ( newdentry -> d_parent!= new_upperdir ) goto out_dput ; if ( newdentry -> d_parent!= new_upperdir ) goto out_dput ; if ( is_dir &&! new -> d_inode && new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } else { flags |= RENAME_EXCHANGE ; } if (! overwrite && new_is_dir && new_opaque ) { flags |= RENAME_WHITEOUT ; } else { flags |= RENAME_EXCHANGE ; } else { flags |= RENAME_EXCHANGE ; } if (! overwrite && new_is_dir && new_opaque ) { flags |= RENAME_EXCHANGE ; } else { flags |="
  },
  {
    "id": 948,
    "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , \"match_at: str: %d, end: %d, start: %d, sprev: %d\\\\n\" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , \"size: %d, start offset: %d\\\\n\"",
    "golden_answers": [
      "CWE-125 Fixed Code Lines are: <vul-start> OP_EXACT1 ) ; <vul-end> DATA_ENSURE ( 1 <vul-start> ++ ; s <vul-end> ++ ; MOP_OUT\n"
    ],
    "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> OP_EXACT1 ) ; if ( num_mem < 1 ) goto fail ; <vul-start> s ++ ; if ( num_mem == 1 ) goto fail ;\n"
  }
]