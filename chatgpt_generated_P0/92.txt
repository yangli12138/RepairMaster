To address the vulnerability of authentication bypass by spoofing present in the code, we should use a stronger method to verify the client's authenticity. The original code only checks if the request is from a trusted IP address, which can easily be spoofed. We should implement a proper authentication mechanism. Here, let's use a simplistic approach by adding a shared secret or token that both the client and server must use to validate each other. 

Additionally, we should fix the incorrect socket variable naming `servr` to `serv`.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_MSG 1024
#define SECRET "sharedSecret"

int main() {
    int sd, n;
    socklen_t clilen;
    struct sockaddr_in serv, cli;
    char msg[MAX_MSG];
    char receivedSecret[MAX_MSG];
  
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sd < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    memset(&serv, 0, sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = htonl(INADDR_ANY);
    serv.sin_port = htons(1008);
    
    if (bind(sd, (struct sockaddr *) &serv, sizeof(serv)) < 0) {
        perror("bind failed");
        close(sd);
        exit(EXIT_FAILURE);
    }

    while (1) {
        memset(msg, 0x0, MAX_MSG);
        clilen = sizeof(cli);
        
        n = recvfrom(sd, receivedSecret, MAX_MSG, 0, (struct sockaddr *) &cli, &clilen);
        if (n < 0) {
            perror("recvfrom failed");
            continue;
        }
        
        // Check if the secret matches
        if (strncmp(receivedSecret, SECRET, strlen(SECRET)) == 0) {
            // Secret is valid, receive the actual message
            n = recvfrom(sd, msg, MAX_MSG, 0, (struct sockaddr *) &cli, &clilen);
            if (n > 0) {
                printf("Message received from client: %s\n", msg);
                // Process the message
            }
        } else {
            // Invalid secret, ignore or log the event
            printf("Received message from untrusted source\n");
        }
    }

    close(sd);
    return 0;
}
```

In this revised code, the server first receives a token or secret (`receivedSecret`) that the client sends initially to authenticate. If the received secret matches the expected secret (`SECRET`), the server proceeds to receive the actual message. This basic method helps to mitigate the risk of simple IP spoofing attacks by requiring knowledge of a shared secret for interaction, enhancing security. 

For a real-world application, consider using more robust authentication mechanisms like SSL/TLS for encrypting and securing the communication.
